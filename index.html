<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/blog/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="tomoat的笔记">
<meta property="og:url" content="https://tomoat.github.io/index.html">
<meta property="og:site_name" content="tomoat的笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tomoat的笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tomoat.github.io/"/>





  <title> tomoat的笔记 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">tomoat的笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/LCS最长公共子序列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/LCS最长公共子序列/" itemprop="url">
                  动态规划方法（算法）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-18T11:46:54+08:00">
                2017-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>LCS（最长公共子序列）<code>O(n^2)</code>的时间复杂度,<code>O(n^2)</code>的空间复杂度；</li>
<li>与之类似但不同的最长公共子串方法。<br>最长公共子串用动态规划可实现<code>O(n^2)</code>的时间复杂度，<code>O(n^2)</code>的空间复杂度；还可以进一步优化，用后缀数组的方法优化成线性时间<code>O(nlogn)</code>；空间也可以用其他方法优化成线性。<br>3.LIS（最长递增序列）DP方法可实现<code>O(n^2)</code>的时间复杂度，进一步优化最佳可达到<code>O(nlogn)</code></li>
</ol>
<p>一些定义：<br>字符串 <code>X</code>， <code>Y</code> 长度 分别<code>m</code>，<code>n</code></p>
<p>子串：字符串S的子串<code>r[i,...,j],i&lt;=j</code>,表示<code>r</code>串从i到j这一段，也就是顺次排列<code>r[i],r[i+1],...,r[j]</code>形成的字符串</p>
<p>前缀：<code>Xi =﹤x1，⋯，xi﹥</code> 即 <code>X</code> 序列的前 <code>i</code> 个字符 <code>(1≤i≤m)</code>；<br><code>Yj=﹤y1，⋯，yj﹥</code>即 <code>Y</code> 序列的前 <code>j</code> 个字符 <code>(1≤j≤n)</code>；<br>假定 <code>Z=﹤z1，⋯，zk﹥∈LCS(X , Y)</code></p>
<p><a href="http://segmentfault.com/a/1190000002646526" target="_blank" rel="external">有关后缀数组的定义</a></p>
<h1 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>定义：<br>一个数列 S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。<br>例如：输入两个字符串 BDCABA 和 ABCBDAB，字符串 BCBA 和 BDAB 都是是它们的最长公共子序列，则输出它们的长度 4，并打印任意一个子序列. （Note: 不要求连续）</p>
<p>判断字符串相似度的方法之一 - LCS 最长公共子序列越长，越相似。</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>对于一般性的 LCS 问题（即任意数量的序列）是属于 NP-hard。但当序列的数量确定时，问题可以使用动态规划（Dynamic Programming）在多项式时间解决。可达时间复杂度：<code>O(m*n)</code><br><a href="http://www.julyedu.com/video/play/id/9" target="_blank" rel="external">July 10分钟讲LCS视频</a>，</p>
<h2 id="暴力方法"><a href="#暴力方法" class="headerlink" title="暴力方法"></a>暴力方法</h2><p><img src="https://segmentfault.com/img/bVlvzf" alt="img"></p>
<h2 id="动态规划方法"><a href="#动态规划方法" class="headerlink" title="动态规划方法"></a>动态规划方法</h2><p><strong>最优子结构性质：</strong><br>设序列 <code>X=&lt;x1, x2, …, xm&gt;</code> 和 <code>Y=&lt;y1, y2, …, yn&gt;</code> 的一个最长公共子序列 <code>Z=&lt;z1, z2, …, zk&gt;</code>，则：</p>
<ol>
<li>若 <code>xm = yn</code>，则 <code>zk = xm = yn</code> 则 <code>Zk-1</code> 是 <code>Xm-1</code> 和 <code>Yn-1</code> 的最长公共子序列；<br><img src="https://segmentfault.com/img/bVlvzm" alt="img"></li>
<li>若 <code>xm ≠ yn</code>， 要么<code>Z</code>是 <code>Xm-1</code> 和 <code>Y</code> 的最长公共子序列，要么 <code>Z</code> 是<code>X</code>和 <code>Yn-1</code> 的最长公共子序列。<br>2.1 若 <code>xm ≠ yn</code> 且 <code>zk≠xm</code> ，则 <code>Z</code>是 <code>Xm-1</code> 和 <code>Y</code> 的最长公共子序列；<br>2.2 若 <code>xm ≠ yn 且 zk ≠yn</code> ，则 <code>Z</code> 是<code>X</code>和 <code>Yn-1</code> 的最长公共子序列。<br>综合一下2 就是求二者的大者</li>
</ol>
<p><strong>递归结构：</strong><br><img src="https://segmentfault.com/img/bVlfds" alt="img"> 递归结构容易看到最长公共子序列问题具有子问题<strong>重叠性质</strong>。例如，在计算 <code>X</code> 和 <code>Y</code> 的最长公共子序列时，可能要计算出 <code>X</code> 和 <code>Yn-1</code> 及 <code>Xm-1</code> 和 <code>Y</code>的最长公共子序列。而这两个子问题都包含一个公共子问题，即计算 <code>Xm-1</code> 和 <code>Yn-1</code> 的最长公共子序列。<br><img src="https://segmentfault.com/img/bVlfdw" alt="img"></p>
<p>递归结构容易看到最长公共子序列问题具有子问题重叠性质。例如，在计算 <code>X</code> 和 <code>Y</code> 的最长公共子序列时，可能要计算出 <code>X</code> 和 <code>Yn-1</code>及 <code>Xm-1</code> 和 <code>Y</code> 的最长公共子序列。而这两个子问题都包含一个公共子问题，即计算<code>Xm-1</code> 和 <code>Yn-1</code> 的最长公共子序列。</p>
<p><strong>计算最优值：</strong><br>子问题空间中，总共只有<code>O(m*n)</code> 个不同的子问题，因此，用动态规划算法自底向上地计算最优值能提高算法的效率。</p>
<p>长度表C 和 方向变量B：<br><img src="https://segmentfault.com/img/bVlfeN" alt="img"> java实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"> /* 动态规划</div><div class="line"> * 求最长公共子序列</div><div class="line"> * @ author by gsm</div><div class="line"> * @ 2015.4.1</div><div class="line"> */</div><div class="line">import java.util.Random;</div><div class="line">public class LCS &#123;</div><div class="line"></div><div class="line">    public static int[][] lengthofLCS(char[] X, char[] Y)&#123;</div><div class="line">        /* 构造二维数组c[][]记录X[i]和Y[j]的LCS长度 (i,j)是前缀</div><div class="line">         * c[i][j]=0; 当 i = j = 0;</div><div class="line">         * c[i][j]=c[i-1][j-1]+1; 当 i = j &gt; 0; Xi == Y[i]</div><div class="line">         * c[i][j]=max(c[i-1][j],c[i][j+1]); 当 i = j &gt; 0; Xi != Y[i]</div><div class="line">         * 需要计算 m*n 个子问题的长度 即 任意c[i][j]的长度</div><div class="line">         * -- 填表过程</div><div class="line">         */</div><div class="line">        int[][]c = new int[X.length+1][Y.length+1];</div><div class="line"></div><div class="line">        // 动态规划计算所有子问题</div><div class="line">        for(int i=1;i&lt;=X.length;i++)&#123;</div><div class="line">            for (int j=1;j&lt;=Y.length;j++)&#123;</div><div class="line">                if(X[i-1]==Y[j-1])&#123;</div><div class="line">                    c[i][j] = c[i-1][j-1]+1;</div><div class="line">                &#125;</div><div class="line">                else if(c[i-1][j] &gt;= c[i][j-1])&#123;</div><div class="line">                    c[i][j] = c[i-1][j];</div><div class="line">                &#125;</div><div class="line">                else&#123;</div><div class="line">                    c[i][j] = c[i][j-1];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 打印C数组</div><div class="line">        for(int i=0;i&lt;=X.length;i++)&#123;</div><div class="line">            for (int j=0;j&lt;=Y.length;j++)&#123;</div><div class="line">                System.out.print(c[i][j]+&quot; &quot;);</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">        return c;</div><div class="line">    &#125;</div><div class="line">    // 输出LCS序列</div><div class="line">    public static void print(int[][] arr, char[] X, char[] Y, int i, int j) &#123;</div><div class="line">        if(i == 0 || j == 0)</div><div class="line">            return;</div><div class="line">        if(X[i-1] == Y[j-1]) &#123;</div><div class="line">            System.out.print(&quot;element &quot; + X[i-1] + &quot; &quot;);</div><div class="line">            // 寻找的</div><div class="line">            print(arr, X, Y, i-1, j-1);</div><div class="line">        &#125;else if(arr[i-1][j] &gt;= arr[i][j-1]) &#123;</div><div class="line">            print(arr, X, Y, i-1, j);</div><div class="line">        &#125;else&#123;</div><div class="line">            print(arr, X, Y, i, j-1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        char[] x =&#123;&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;B&apos;,&apos;D&apos;,&apos;A&apos;,&apos;B&apos;&#125;; </div><div class="line">        char[] y =&#123;&apos;B&apos;,&apos;D&apos;,&apos;C&apos;,&apos;A&apos;,&apos;B&apos;,&apos;A&apos;&#125;; </div><div class="line">        int[][] c = lengthofLCS(x,y);</div><div class="line">        print(c, x, y, x.length, y.length);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h1><h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>定义 2 个字符串 query 和 text, 如果 query 里最大连续字符子串在 text 中存在，则返回子串长度. 例如: query=”acbac”，text=”acaccbabb”， 则最大连续子串为 “cba”, 则返回长度 3.</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="时间复杂度：O-m-n-的DP"><a href="#时间复杂度：O-m-n-的DP" class="headerlink" title="时间复杂度：O(m*n)的DP"></a>时间复杂度：<code>O(m*n)</code>的DP</h3><p>这个 LCS 跟前面说的最长公共子序列的 LCS 不一样，不过也算是 LCS 的一个变体，在 LCS 中，子序列是不必要求连续的，而子串则是 “连续” 的</p>
<p>我们还是像之前一样 “从后向前” 考虑是否能分解这个问题，类似最长公共子序列的分析，这里，我们使用<code>c[i,j]</code> 表示 以 <code>Xi</code> 和 <code>Yj</code>结尾的最长公共子串的长度，<strong>因为要求子串连续，所以对于 Xi 与 Yj 来讲，它们要么与之前的公共子串构成新的公共子串；要么就是不构成公共子串。故状态转移方程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">X[i-1] == Y[j-1]，c[i,j] = c[i-1,j-1] + 1；</div><div class="line"></div><div class="line">X[i-1] != Y[j-1]，c[i,j] = 0；</div></pre></td></tr></table></figure>
<p>对于初始化，<code>i==0 或者 j==0，c[i,j] = 0</code><br>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class LCString &#123;</div><div class="line">    public  static int lengthofLCString(String X, String Y)&#123;</div><div class="line">        /* 构造二维数组c[][]记录X[i]和Y[j]的LCS长度 (i,j)是前缀</div><div class="line">         * c[i][j]=0; 当 i = j = 0;</div><div class="line">         * c[i][j]=c[i-1][j-1]+1; 当 i = j &gt; 0; Xi == Y[i]</div><div class="line">         * c[i][j]=0; 当 i = j &gt; 0; Xi != Y[i]</div><div class="line">         * 需要计算 m*n 个子问题的长度 即 任意c[i][j]的长度</div><div class="line">         * -- 填表过程</div><div class="line">         */</div><div class="line">        int[][]c = new int[X.length()+1][Y.length()+1];</div><div class="line">        int maxlen = 0;</div><div class="line">        int maxindex = 0;</div><div class="line">        for(int i =1;i&lt;=X.length();i++)&#123;</div><div class="line">            for(int j=1;j&lt;=Y.length();j++)&#123;</div><div class="line">                if(X.charAt(i-1) == Y.charAt(j-1))&#123;</div><div class="line">                    c[i][j] = c[i-1][j-1]+1;</div><div class="line">                    if(c[i][j] &gt; maxlen)</div><div class="line">                    &#123;</div><div class="line">                        maxlen = c[i][j];</div><div class="line">                        maxindex = i + 1 - maxlen;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return maxlen;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String X = &quot;acbac&quot;;</div><div class="line">        String Y = &quot;acaccbabb&quot;;</div><div class="line">        System.out.println(lengthofLCString(X,Y)); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="时间复杂度O-nlogn-的后缀数组的方法"><a href="#时间复杂度O-nlogn-的后缀数组的方法" class="headerlink" title="时间复杂度O(nlogn)的后缀数组的方法"></a>时间复杂度<code>O(nlogn)</code>的后缀数组的方法</h3><p><a href="http://segmentfault.com/a/1190000002646526" target="_blank" rel="external">有关后缀数组以及求最长重复子串</a><br>前面提过后缀数组的基本定义，与子串有关，可以尝试这方面思路。由于后缀数组最典型的是寻找一个字符串的重复子串，所以，对于两个字符串，我们可以将其连接到一起，如果某一个子串 s 是它们的公共子串，则 s 一定会在连接后字符串后缀数组中出现两次，这样就将最长公共子串转成最长重复子串的问题了，这里的后缀数组我们使用基本的实现方式。</p>
<p>值得一提的是，在找到两个重复子串时，不一定就是 X 与 Y 的公共子串，也可能是 X 或 Y 的自身重复子串，故在连接时候我们在 X 后面插入一个特殊字符‘#’，即连接后为 X#Y。这样一来，只有找到的两个重复子串恰好有一个在 #的前面，这两个重复子串才是 X 与 Y 的公共子串</p>
<h3 id="各方案复杂度对比"><a href="#各方案复杂度对比" class="headerlink" title="各方案复杂度对比"></a>各方案复杂度对比</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">设字符串 X 的长度为 m，Y 的长度为 n，最长公共子串长度为 l。</div><div class="line"></div><div class="line">对于基本算法（brute force），X 的子串（m 个）和 Y 的子串（n 个）一一对比，最坏情况下，复杂度为 O(m*n*l)，空间复杂度为 O(1)。</div><div class="line"></div><div class="line">对于 DP 算法，由于自底向上构建最优子问题的解，时间复杂度为 O(m*n)；空间复杂度为 O(m*n)，当然这里是可以使用滚动数组来优化空间的，滚动数组在动态规划基础回顾中多次提到。</div><div class="line"></div><div class="line">对于后缀数组方法，连接到一起并初始化后缀数组的时间复杂度为 O(m+n)，对后缀数组的字符串排序，由于后缀数组有 m+n 个后缀子串，子串间比较，故复杂度为 O((m+n)*l*lg(m+n))，求得最长子串遍历后缀数组，复杂度为 O(m+n)，所以总的时间复杂度为 O((m+n)*l*lg(m+n))，空间复杂度为 O(m+n)。</div><div class="line"></div><div class="line">总的来说使用后缀数组对数据做一些 “预处理”，在效率上还是能提升不少的。</div></pre></td></tr></table></figure>
<h1 id="LIS-最长递增子序列"><a href="#LIS-最长递增子序列" class="headerlink" title="LIS 最长递增子序列"></a>LIS 最长递增子序列</h1><p>问题描述：找出一个n个数的序列的最长单调递增子序列： 比如<code>A = {5,6,7,1,2,8}</code> 的LIS是<code>5,6,7,8</code></p>
<h2 id="1-O-n-2-的复杂度："><a href="#1-O-n-2-的复杂度：" class="headerlink" title="1. O(n^2)的复杂度："></a>1. <code>O(n^2)</code>的复杂度：</h2><p><strong>1.1 最优子结构：</strong><br><code>LIS[i]</code> 是以<code>arr[i]</code>为末尾的LIS序列的长度。则：<br><code>LIS[i] = {1+Max(LIS(j))}</code>; <code>j&lt;i, arr[j]&lt;arr[i]</code>;<br><code>LIS[i] = 1, j&lt;i</code>, 但是不存在<code>arr[j]&lt;arr[i]</code>;<br>所以问题转化为计算<code>Max(LIS(j))</code> <code>0&lt;i&lt;n</code></p>
<p><strong>1.2 重叠的子问题：</strong><br>以<code>arr[i] (1&lt;= i &lt;= n)</code>每个元素结尾的LIS序列的值是 重叠的子问题。<br>所以填表时候就是建立一个数组<code>DP[i]</code>, 记录以<code>arr[i]</code>为序列末尾的LIS长度。</p>
<p><strong>1.3 DP[i]怎么计算？</strong><br>遍历所有<code>j&lt;i</code>的元素，检查是否<code>DP[j]+1&gt;DP[i] &amp;&amp; arr[j]&lt;arry[i]</code> 若是，则可以更新<code>DP[i]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">int maxLength = 1, bestEnd = 0;</div><div class="line">DP[0] = 1;</div><div class="line">prev[0] = -1;</div><div class="line"></div><div class="line">for (int i = 1; i &lt; N; i++)</div><div class="line">&#123;</div><div class="line">   DP[i] = 1;</div><div class="line">   prev[i] = -1;</div><div class="line"></div><div class="line">   for (int j = i - 1; j &gt;= 0; j--)</div><div class="line">      if (DP[j] + 1 &gt; DP[i] &amp;&amp; array[j] &lt; array[i])</div><div class="line">      &#123;</div><div class="line">         DP[i] = DP[j] + 1;</div><div class="line">         prev[i] = j;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">   if (DP[i] &gt; maxLength)</div><div class="line">   &#123;</div><div class="line">      bestEnd = i;</div><div class="line">      maxLength = DP[i];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="2-O-nlog-的复杂度"><a href="#2-O-nlog-的复杂度" class="headerlink" title="2. O(nlog)的复杂度"></a>2. <code>O(nlog)</code>的复杂度</h2><p><strong>基本思想：</strong></p>
<p>首先通过一个数组<code>MaxV[nMaxLength]</code>来缓存递增子序列LIS的<code>末尾元素</code>最小值；通过<code>nMaxLength</code> 记录到当前遍历为止的最长子序列的长度;</p>
<p>然后我们从第2元素开始，遍历给定的数组<code>arr</code>，</p>
<ol>
<li><code>arr[i] &gt; MaxV[nMaxLength]</code>, 将<code>arr[i]</code>插入到<code>MaxV[++nMaxLength]</code>的末尾 – 意味着我们找到了一个新的最大LIS</li>
<li><code>arr[i] &lt;= MaxV[nMaxLength]</code>, 找到<code>MaxV[]</code>中刚刚大于<code>arr[i]</code>的元素，<code>arr[j]</code>.<code>arr[i]替换arr[j]</code><br>因为MaxV是一个有序数组，查找过程可以使用<code>log(N)</code>的折半查找。<br>这样运行时间: <code>n</code>个整数和每个都需要折半查找 – <code>n*logn = O(nlogn)</code></li>
</ol>
<ul>
<li><code>if &gt;</code> 说明<code>j</code>能够放在最长子序列的末尾形成一个新的最长子序列.</li>
<li><code>if&lt;</code> 说明<code>j</code>需要<code>替换</code>前面一个<code>刚刚大</code>与<code>array[j]</code>的元素</li>
</ul>
<p>最后，输出LIS时候，我们会用一个<code>LIS[]</code>数组，这边<code>LIS[i]</code>记录的是以元素<code>arr[i]</code>为结尾的最长序列的长度</p>
<hr>
<p><strong>初始化准备工作：</strong></p>
<p><code>MaxV[1]</code>首先会被设置成序列第一个元素 即 <code>MaxV[1] = arr[0]</code>，在遍历数组的过程中会不断的更新。<br><code>nMaxLength = 1</code></p>
<hr>
<p><strong>举个栗子：</strong><br><code>arr = {2 1 5 3 6 4 8 9 7}</code></p>
<ul>
<li>首先<code>i=1</code>, 遍历到1， 1 通过跟MaxV[nMaxLength]比较: <code>1&lt;MaxV[nMaxLength]</code>,<br>发现1更有<code>潜力</code>（更小的有潜力，更小的替换之）<br>1 更有潜力, 那么<code>1</code>就<code>替换MaxV[nMaxLength]</code> 即 <code>MaxV[nMaxLength] =1</code> ;<br>这个时候 <code>MaxV={1}， nMaxlength = 1，LIS[1] = 1</code>;</li>
<li>然后 <code>i =2</code>, 遍历到5， 5通过跟<code>MaxV[nMaxLength]</code>比较, <code>5&gt;MaxV[nMaxLength]</code>,<br>发现5 <code>更大</code>； 链接到目前得到的LIS尾部；<br>这个时候 <code>MaxV={1，5}</code>， <code>nMaxlength++ = 2</code>， <code>MaxV[nMaxLength]=5</code>， <code>LIS[i] = 1+1 = 2</code>;</li>
<li>然后 <code>i =3</code>，遍历到3, 3 通过跟MaxV[nMaxLength]比较, <code>3&lt;MaxV[nMaxLength]</code>,<br>发现3更有 <code>潜力</code>，然后从 <code>nMaxLength</code>往前比较，找到第一个刚刚比3大元素替换之。（稍后解释什么叫刚刚大）<br>这个时候 <code>MaxV={1,3}， nMaxlength = 2</code>; 3只是替换， <code>LIS[i]不变 = LIS[3]= 2</code>;</li>
<li>然后 <code>i =4</code>，遍历到6， 6 通过跟 <code>MaxV[nMaxLength]</code>比较, <code>6&gt;MaxV[nMaxLength]</code>,<br>发现6更大； 6就应该链接到目前得到的LIS尾部；<br>这个时候，<code>MaxV={1,3,6} ，nMaxlength = 3</code>，<code>MaxV[nMaxLength+1]=6 , LIS[4] = 3</code></li>
<li>然后<code>i =5</code>，遍历到4, 4 通过跟<code>MaxV[nMaxLength] = 6</code>比较, <code>4&lt;MaxV[nMaxLength]</code>,<br>发现4更有<code>潜力</code>，然后从<code>nMaxLength</code>往前比较，找到刚刚比4大元素 也就是 6替换之。<br>这个时候 <code>MaxV={1,3,4}， nMaxlength = 3</code>，4只是替换， <code>LIS[i]不变 = LIS[5]= 3</code>;</li>
<li>然后<code>i=6</code>, 遍历到8， 8通过跟<code>MaxV[nMaxLength]</code>比较, <code>8&gt;MaxV[nMaxLength]</code>,<br>发现8<code>更大</code>； 8就应该链接到目前得到的LIS尾部；<br>这个时候 <code>MaxV={1,3,4,8}， nMaxlength = 4, Maxv[nMaxlength]=8 LIS[6]=4</code>,</li>
<li>然后<code>i=7</code>, 遍历到9， 9通过跟<code>MaxV[nMaxLength]</code>比较, <code>9&gt;MaxV[nMaxLength]</code>,<br>发现9<code>更大</code>； 9就应该链接到目前得到的LIS尾部；<br>这个时候 <code>MaxV={1,3,4,8，9}， nMaxlength = 5, Maxv[nmaxlength]=9, LIS[7] = 5;</code></li>
<li>然后<code>i=8</code>, 遍历到7, 7 通过跟<code>MaxV[nMaxLength] = 9</code>比较, <code>7&lt;MaxV[nMaxLength]</code>,<br>发现7更有<code>潜力</code>，然后从<code>nMaxLength</code>往前比较，找到第一个比7大元素 也就是 8替换之。<br>这个时候 <code>MaxV={1,3,4,7,9}</code>, <code>nMaxLength = 5, Maxv[nMaxlength]=9</code><br><code>LIS[8] = LIS[替换掉的index] = 4</code>;</li>
</ul>
<table>
<thead>
<tr>
<th>–</th>
<th>2</th>
<th>1</th>
<th>5</th>
<th>3</th>
<th>6</th>
<th>4</th>
<th>8</th>
<th>9</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td>LIS</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>MaxV</td>
<td>2</td>
<td>1</td>
<td>1,5</td>
<td>1,3</td>
<td>1,3,6</td>
<td>1,3,4</td>
<td>1,3,4,8</td>
<td>1,3,4,8,9</td>
<td>1,3,4,7</td>
</tr>
</tbody>
</table>
<p>java实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class LIS &#123;</div><div class="line">    public static int lengthofLCS(int[] arr)&#123;</div><div class="line">        // 辅助变量</div><div class="line">        int[] MaxV = new int [arr.length+1]; // 记录递增子序列 LIS 的末尾元素最小值 </div><div class="line">        int nMaxLength = 1; // 当前LIS的长度</div><div class="line">        int [] LIS = new int[arr.length+1]; //LIS[i]记录的是以第i个元素为结尾的最长序列的长度</div><div class="line">        // 初始化</div><div class="line">        MaxV[0] = -100;</div><div class="line">        MaxV[nMaxLength] = arr[0];</div><div class="line">        LIS[0] = 0;LIS[1] = 1;</div><div class="line"></div><div class="line">        for(int i=1;i&lt;arr.length;i++)&#123;</div><div class="line">            if(arr[i] &gt;MaxV[nMaxLength])&#123;</div><div class="line">                MaxV[++nMaxLength] = arr[i];</div><div class="line">                LIS[i] = LIS[i-1]+1;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                // 新元素 更小，更有“潜力”，替换大的元素</div><div class="line">                int index = binarySearch(MaxV,arr[i],0,nMaxLength);     </div><div class="line">                //*     </div><div class="line">                LIS[i] =index;</div><div class="line">                MaxV[index] = arr[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(LIS);</div><div class="line">        return LIS[LIS.length-1];</div><div class="line">    &#125;</div><div class="line">    // 在MaxV数组中查找一个元素刚刚大于arr[i]</div><div class="line">    // 返回这个元素的index</div><div class="line">    public static int binarySearch(int []arr, int n, int start, int end)&#123;</div><div class="line">        while(start&lt;end)&#123;</div><div class="line">            int mid = (start + end)/2;</div><div class="line">            if(arr[mid]&lt; n)&#123;</div><div class="line">                start = mid+1;</div><div class="line">            &#125;</div><div class="line">            else if(arr[mid]&gt; n) &#123;</div><div class="line">                end = mid -1;</div><div class="line">            &#125;</div><div class="line">            else </div><div class="line">                return mid;</div><div class="line">        &#125;</div><div class="line">        return end;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int[] arr = &#123;2,1,5,3,6,4,8,9,7&#125;;</div><div class="line">        System.out.println(lengthofLCS(arr));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>* : MaxV里面的数组下标代表了长度为index的最长子序列末尾元素，反过来就是末尾元素在MaxV里对应的下标就是他子序列的长度</p>
<hr>
<h1 id="可以转化为LCS的问题"><a href="#可以转化为LCS的问题" class="headerlink" title="可以转化为LCS的问题"></a>可以转化为LCS的问题</h1><ul>
<li>给一个字符串，求这个字符串最少增加几个字符能变成回文</li>
<li>要在一条河的南北两边的各个城市之间造若干座桥．桥两边的城市分别是 a(1)…a(n) 和 b(1)…b(n). 且南边 a(1)…a(n) 是乱序的，北边同理，但是要求 a(i) 只可以和 b(i) 之间造桥, 同时两座桥之间不能交叉. 希望可以得到一个尽量多座桥的方案.</li>
</ul>
<hr>
<p>总结：</p>
<p>- 通常DP是一个不算最好，但是比最直接的算法好很多的方法。 DP一般是O（n^2）;但是如果想进一步优化 O（nlogn）就要考虑其他的了</p>
<p>- 对，要想更好的方法就是要挖掘题目本身更加隐匿的性质了</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000002641054" target="_blank" rel="external">算法设计 - LCS 最长公共子序列&amp;&amp;最长公共子串 &amp;&amp;LIS 最长递增子序列</a></p>
<p><a href="http://segmentfault.com/blog/exploring/" target="_blank" rel="external">http://segmentfault.com/blog/exploring/</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/在Node.js中查找JavaScript内存泄漏简略指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/在Node.js中查找JavaScript内存泄漏简略指南/" itemprop="url">
                  在Node.js中查找JavaScript内存泄漏简略指南
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-16T16:07:25+08:00">
                2017-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#intro" target="_blank" rel="external">介绍</a></li>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#min-theory" target="_blank" rel="external">最小理论</a></li>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#reproduce" target="_blank" rel="external">步骤1.重现并确认问题</a></li>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#heapdump" target="_blank" rel="external">第2步。至少取3堆堆</a></li>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#find-problem" target="_blank" rel="external">步骤3.查找问题</a></li>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#confirm" target="_blank" rel="external">步骤4.确认问题已解决</a></li>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#links" target="_blank" rel="external">链接到一些其他资源</a></li>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#summary" target="_blank" rel="external">概要</a></li>
</ul>
<blockquote>
<p>你可能想要的书签：简单指南查找JavaScript内存泄漏在Node.js由<a href="https://twitter.com/akras14" target="_blank" rel="external">@ akras14 </a><a href="https://t.co/oRyQboa8Uw" target="_blank" rel="external">https://t.co/oRyQboa8Uw</a></p>
<p>- Node.js（@nodejs）<a href="https://twitter.com/nodejs/status/684678799896625152" target="_blank" rel="external">2016年1月6日</a></p>
</blockquote>
<p>请考虑<a href="https://www.alexkras.com/recommends/kindle-memory-leak" target="_blank" rel="external">在亚马逊上查看本指南</a>，如果你会发现它有所帮助。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>几个月前，我不得不调试Node.js中的内存泄漏。我发现了很多文章专门的主题，但即使仔细阅读其中一些，我仍然很困惑，我究竟应该做什么来调试我们的问题。</p>
<p>我的目的是这个职位是一个简单的指南，在节点中查找内存泄漏。我将概述一个易于遵循的方法，应该（在我看来）成为任何内存泄漏调试在节点的起点。在某些情况下，这种方法可能不够。我将链接到您可能想要考虑的一些其他资源。</p>
<h2 id="最小理论"><a href="#最小理论" class="headerlink" title="最小理论"></a>最小理论</h2><p>JavaScript是一种垃圾收集语言。因此，Node进程使用的所有内存都由V8 JavaScript引擎自动分配和取消分配。</p>
<p>V8如何知道何时解除分配内存？V8保留程序中所有变量的图形，从根节点开始。JavaScript中有4种类型的数据类型：Boolean，String，Number和Object。前3个是简单类型，它们只能保留分配给它们的数据（即文本字符串）。对象和JavaScript中的一切都是一个对象（即数组是对象），可以保持引用（指针）到其他对象。</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/memory-graph.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/memory-graph.png" alt="内存图"></a></p>
<p>周期性地，V8将遍历存储器图，尝试识别从根节点不再能够到达的数据组。如果从根节点无法访问，V8假定数据不再使用并释放内存。这个过程称为<strong>垃圾收集</strong>。</p>
<h3 id="什么时候发生内存泄漏？"><a href="#什么时候发生内存泄漏？" class="headerlink" title="什么时候发生内存泄漏？"></a>什么时候发生内存泄漏？</h3><p>当一些不再需要的数据仍然可以从根节点到达时，在JavaScript中发生内存泄漏。V8将假设数据仍在使用，并且不会释放内存。<strong>为了调试内存泄漏，我们需要找到错误保存的数据，并确保V8能够清理它。</strong></p>
<p>还有一点很重要，要注意的是，垃圾回收不会一直运行。通常V8可以在认为合适时触发垃圾收集。例如，它可以定期运行垃圾收集，或者它可以触发垃圾收集，如果它感测到可用内存量越来越低。节点对每个进程可用的内存数量有限，因此V8必须明智地使用它。</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/node-error.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/node-error.png" alt="节点错误"></a></p>
<p>后来的情况下，<strong>垃圾收集</strong>可能是<strong>性能明显下降的来源</strong>。</p>
<p>想象一下，你有一个应用程序有很多内存泄漏。很快，Node进程会开始耗尽内存，这将导致V8触发一个无法回收的垃圾收集。但是由于大多数数据仍然可以从根节点到达，非常少的内存将被清理，保持大部分的位置。</p>
<p>比以后更快，Node进程会再次运行内存，触发另一个垃圾收集。在你知道它之前，你的应用程序进入一个不断的垃圾收集周期，只是为了保持过程的功能。由于V8花费大部分时间来处理垃圾收集，因此只剩下很少的资源来运行实际程序。</p>
<h2 id="步骤1-重现并确认问题"><a href="#步骤1-重现并确认问题" class="headerlink" title="步骤1.重现并确认问题"></a>步骤1.重现并确认问题</h2><p>正如我前面指出的，V8 JavaScript引擎有一个复杂的逻辑，它用于确定何时运行垃圾收集。记住这一点，即使我们可以看到Node进程的内存继续上升，<strong>我们不能确定我们目睹了内存泄漏，直到我们知道Garbage Collection已经运行</strong>，允许未使用的内存被清除。</p>
<p>幸运的是，Node允许我们手动触发垃圾收集，这是我们在尝试确认内存泄漏时应该做的第一件事。这可以通过运行带有<code>--expose-gc</code>标志（ie <code>node --expose-gc index.js</code>）的Node来实现。一旦节点在该模式下运行，您可以随时通过<code>global.gc()</code>从您的程序调用来以编程方式触发垃圾收集。</p>
<p>您还可以通过调用来检查进程使用的内存量<code>process.memoryUsage().heapUsed</code>。</p>
<p><strong>通过手动触发垃圾收集和检查使用的堆，你可以确定你是否实际上观察你的程序中的内存泄漏。</strong></p>
<h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><p>我创建了一个简单的内存泄漏程序，你可以在这里看到：<a href="https://github.com/akras14/memory-leak-example" target="_blank" rel="external">https</a> : <a href="https://github.com/akras14/memory-leak-example" target="_blank" rel="external">//github.com/akras14/memory-leak-example</a></p>
<p>您可以克隆它，运行<code>npm install</code>，然后运行<code>node --expose-gc index.js</code>以查看它的操作。</p>
<table>
<thead>
<tr>
<th>12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849</th>
<th>“use strict”;require(‘heapdump’); var leakyData = [];var nonLeakyData = []; class SimpleClass {  constructor(text){    this.text = text;  }} function cleanUpData(dataStore, randomObject){  var objectIndex = dataStore.indexOf(randomObject);  dataStore.splice(objectIndex, 1);} function getAndStoreRandomData(){  var randomData = Math.random().toString();  var randomObject = new SimpleClass(randomData);   leakyData.push(randomObject);  nonLeakyData.push(randomObject);   // cleanUpData(leakyData, randomObject); //&lt;– Forgot to clean up  cleanUpData(nonLeakyData, randomObject);} function generateHeapDumpAndStats(){  //1. Force garbage collection every time this function is called  try {    global.gc();  } catch (e) {    console.log(“You must run program with ‘node –expose-gc index.js’ or ‘npm start’”);    process.exit();  }   //2. Output Heap stats  var heapUsed = process.memoryUsage().heapUsed;  console.log(“Program is using “ + heapUsed + “ bytes of Heap.”)   //3. Get Heap dump  process.kill(process.pid, ‘SIGUSR2’);} //Kick off the programsetInterval(getAndStoreRandomData, 5); //Add random data every 5 millisecondssetInterval(generateHeapDumpAndStats, 2000); //Do garbage collection and heap dump every 2 seconds</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>程序将：</p>
<ol>
<li>每5毫秒生成一个随机对象并将其存储在2个数组中，一个名为<em>leakyData</em>和另一个<em>nonLeakyData</em>。我们将每5毫秒清除nonLeakyData数组，但是我们会<strong>“忘记”</strong>清理leakyData数组。</li>
<li>每2秒，程序将输出所使用的内存量（并生成堆转储，但我们将在下一节中讨论更多）。</li>
</ol>
<p>如果用<code>node --expose-gc index.js</code>（或<code>npm start</code>）运行程序，它将开始输出内存统计信息。让它运行一两分钟，并杀死它<code>Ctr + c</code>。</p>
<p>你会看到内存快速增长，即使我们每2秒触发一次垃圾收集，在我们得到统计数据之前：</p>
<table>
<thead>
<tr>
<th>123456789101112</th>
<th>//1. Force garbage collection every time this function is calledtry {  global.gc();} catch (e) {  console.log(“You must run program with ‘node –expose-gc index.js’ or ‘npm start’”);  process.exit();} //2. Output Heap statsvar heapUsed = process.memoryUsage().heapUsed;console.log(“Program is using “ + heapUsed + “ bytes of Heap.”)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>使用stats输出看起来像下面：</p>
<table>
<thead>
<tr>
<th>12345678910111213141516</th>
<th>Program is using 3783656 bytes of Heap.Program is using 3919520 bytes of Heap.Program is using 3849976 bytes of Heap.Program is using 3881480 bytes of Heap.Program is using 3907608 bytes of Heap.Program is using 3941752 bytes of Heap.Program is using 3968136 bytes of Heap.Program is using 3994504 bytes of Heap.Program is using 4032400 bytes of Heap.Program is using 4058464 bytes of Heap.Program is using 4084656 bytes of Heap.Program is using 4111128 bytes of Heap.Program is using 4137336 bytes of Heap.Program is using 4181240 bytes of Heap.Program is using 4207304 bytes of Heap.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>如果你绘制数据，内存增长变得更加明显。</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/with-memory-leak.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/with-memory-leak.png" alt="带内存泄漏"></a></p>
<p><em>注意：如果你好奇我如何绘制数据，请继续阅读。如果没有，请跳到下一节。</em></p>
<p>我将输出的统计信息保存到一个JSON文件中，然后读入它并用几行Python绘制它。我把它保持在单独的早午餐以避免混乱，但你可以在这里查看：<a href="https://github.com/akras14/memory-leak-example/tree/plot" target="_blank" rel="external">https</a>：<a href="https://github.com/akras14/memory-leak-example/tree/plot" target="_blank" rel="external">//github.com/akras14/memory-leak-example/tree/plot</a></p>
<p>相关部分为：</p>
<table>
<thead>
<tr>
<th>1234567891011121314151617181920212223</th>
<th>var fs = require(‘fs’);var stats = []; //— skip — var heapUsed = process.memoryUsage().heapUsed;stats.push(heapUsed); //— skip — //On ctrl+c save the stats and exitprocess.on(‘SIGINT’, function(){  var data = JSON.stringify(stats);  fs.writeFile(“stats.json”, data, function(err) {    if(err) {      console.log(err);    } else {      console.log(“\nSaved stats to stats.json”);    }    process.exit();  });});</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>和</p>
<table>
<thead>
<tr>
<th>1234567891011121314</th>
<th>#!/usr/bin/env python import matplotlib.pyplot as pltimport json statsFile = open(‘stats.json’, ‘r’)heapSizes = json.load(statsFile) print(‘Plotting %s’ % ‘, ‘.join(map(str, heapSizes))) plt.plot(heapSizes)plt.ylabel(‘Heap Size’)plt.show()</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>你可以检查出<a href="https://github.com/akras14/memory-leak-example/tree/plot" target="_blank" rel="external">plot</a>分支，并像往常一样运行程序。一旦你完成运行<code>python plot.py</code>生成情节。您需要在您的机器上安装<a href="http://matplotlib.org/" target="_blank" rel="external">Matplotlib</a>库才能正常工作。</p>
<p>或者可以在Excel中绘制数据。</p>
<h2 id="第2步。至少取3堆堆"><a href="#第2步。至少取3堆堆" class="headerlink" title="第2步。至少取3堆堆"></a>第2步。至少取3堆堆</h2><p>好了，所以我们重现了问题，现在是什么？现在我们需要弄清楚问题在哪里，并解决它</p>
<p>您可能已经注意到我的示例程序中的以下行：</p>
<table>
<thead>
<tr>
<th>12345678</th>
<th>require(‘heapdump’);// —skip— //3. Get Heap dumpprocess.kill(process.pid, ‘SIGUSR2’); // —skip—</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>我使用一个node-heapdump模块，你可以在这里找到：<a href="https://github.com/bnoordhuis/node-heapdump" target="_blank" rel="external">https</a> : <a href="https://github.com/bnoordhuis/node-heapdump" target="_blank" rel="external">//github.com/bnoordhuis/node-heapdump</a></p>
<p>为了使用node-heapdump，你只需要：</p>
<ol>
<li>安装它。</li>
<li>要求它在你的程序的顶部</li>
<li><code>kill -USR2 </code>在Unix上调用像平台</li>
</ol>
<p>如果你从来没有看到该<code>kill</code>部分，它是Unix中的一个命令，它允许你（除了别的以外）发送一个自定义信号（aka User Signal）给任何正在运行的进程。Node-heapdump配置为进行进程的堆转储，任何时候它接收<strong>用户信号两个</strong>因此<code>-USR2</code>，后跟进程id。</p>
<p>在我的示例程序中，我<code>kill -USR2 </code>通过运行自动化命令<code>process.kill(process.pid, &#39;SIGUSR2&#39;);</code>，其中<code>process.kill</code>是一个<code>kill</code>命令的节点包装器，<code>SIGUSR2</code>是Node的说法<code>-USR2</code>，并<code>process.pid</code>获取当前Node进程的ID。我在每个垃圾收集之后运行此命令以获得干净的堆转储。</p>
<p>我不认为<code>process.kill(process.pid, &#39;SIGUSR2&#39;);</code>会在Windows上工作，但你可以运行<code>heapdump.writeSnapshot()</code>。</p>
<p>这个例子可能会更容易一些<code>heapdump.writeSnapshot()</code>，但是我想提一提的是，你可以<code>kill -USR2 </code>在Unix上像平台一样触发堆 信号，这样可以派上用场。</p>
<p>下一节将讨论如何使用生成的堆转储来隔离内存泄漏。</p>
<h2 id="步骤3-查找问题"><a href="#步骤3-查找问题" class="headerlink" title="步骤3.查找问题"></a>步骤3.查找问题</h2><p>在第2步中，我们生成了一堆堆转储，但<strong>我们至少需要3个</strong>，你很快就会明白为什么。</p>
<p>一旦你有你的堆转储。转到Google Chrome浏览器，打开Chrome开发工具（Windows上为F12或Mac上为Command + Options + i）。</p>
<p>一旦进入开发工具导航到“配置文件”选项卡，选择屏幕底部的“加载”按钮，导航到您采取的第一个堆转储，并选择它。堆转储将加载到Chrome视图中，如下所示：</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/1st-Heap-Dump.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/1st-Heap-Dump.png" alt="第一堆"></a></p>
<p>继续加载2个堆转储到视图中。例如，您可以使用您所采取的最后2个堆转储。最重要的是，堆转储必须按照它们被采用的顺序加载。您的“配置文件”选项卡应类似于以下内容。</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/3-Heap-Dumps.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/3-Heap-Dumps.png" alt="3堆堆"></a></p>
<p>从上面的图像可以看出，堆随着时间的推移继续增长。</p>
<h3 id="3堆倾销法"><a href="#3堆倾销法" class="headerlink" title="3堆倾销法"></a>3堆倾销法</h3><p>一旦堆转储被加载，您将在“个人档案”选项卡中看到很多子视图，并且很容易丢失它们。然而，有一种观点，我发现特别有帮助。</p>
<p>点击你已经采取的最后一个堆转储，它会立即将你进入“摘要”视图。在“摘要”下拉列表的左侧，您应该会看到另一个显示“全部”的下拉菜单。点击它并选择“在heapdump-YOUR-FIRST-HEAP-DUMP和heapdump-YOUR-SECOND-TO-LAST-HEAP-DUMP之间分配的对象”，如下图所示。</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/3-Heap-Dump-View.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/3-Heap-Dump-View.png" alt="3堆堆视图"></a></p>
<p>它将显示有时在您的第一个堆转储和第二个到最后一个堆转储之间分配的所有对象。这些事情，这些对象仍然挂在你的最后堆转储是引起关注，应该调查，因为他们应该被拾起由垃圾收集。</p>
<p>相当惊人的东西实际上，但不是很直观，发现和容易忽视。</p>
<h3 id="忽略括号中的任何内容，例如（字符串），至少在开头"><a href="#忽略括号中的任何内容，例如（字符串），至少在开头" class="headerlink" title="忽略括号中的任何内容，例如（字符串），至少在开头"></a>忽略括号中的任何内容，例如（字符串），至少在开头</h3><p>完成示例应用程序的概述步骤后，我结束了以下视图。</p>
<p>注意，<strong>浅尺寸</strong>表示对象本身的大小，而<strong>保留尺寸</strong>表示对象的尺寸和它的所有子。</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/memory-leak.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/memory-leak.png" alt="内存泄漏"></a></p>
<p>似乎有5个条目保留在我上次的快照，应该不存在：（数组），（编译代码），（字符串），（系统）和SimpleClass。</p>
<p>其中只有<strong>SimpleClass</strong>看起来很熟悉，因为它来自示例应用程序中的以下代码。</p>
<table>
<thead>
<tr>
<th>12</th>
<th>var randomObject = new SimpleClass(randomData);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>可能很有可能先通过（数组）或（字符串）条目开始查找。摘要视图中的所有对象按其构造函数名称分组。在数组或字符串的情况下，这些是JavaScript引擎内部的构造函数。虽然你的程序肯定坚持通过这些构造函数创建的一些数据，你也会在那里得到很多噪音，使得更难找到内存泄漏的来源。</p>
<p>这就是为什么最好跳过这些，而是看看你是否可以发现任何更明显的嫌疑犯，如示例应用程序中的<strong>SimpleClass</strong>构造函数。</p>
<p>单击SimpleClass构造函数中的下拉箭头，并从结果列表中选择任何创建的对象，将填充窗口下部的保留路径（参见上图）。从那里，很容易跟踪leakyData数组持有我们的数据。</p>
<p>如果你在你的应用程序没有幸运，像我在我的示例应用程序，你可能需要看看内部构造函数（如字符串），并试图找出是什么导致内存泄漏。在这种情况下，诀窍是尝试识别在一些内部构造器组中经常出现的值组，并尝试使用它作为指向可疑内存泄漏的提示。</p>
<p>例如，在示例应用程序案例中，您可能会观察到很多字符串看起来像转换为字符串的随机数。如果您检查其保留路径，Chrome开发工具将指向leakyData数组。</p>
<h2 id="步骤4-确认问题已解决"><a href="#步骤4-确认问题已解决" class="headerlink" title="步骤4.确认问题已解决"></a>步骤4.确认问题已解决</h2><p>在您确定并修复了可疑的内存泄漏后，您应该会发现堆使用情况有很大的不同。</p>
<p>如果我们在示例应用中取消注释以下行：</p>
<table>
<thead>
<tr>
<th>12</th>
<th>cleanUpData(leakyData, randomObject); //&lt;– Forgot to clean up</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>并按照步骤1中所述重新运行应用程序，请注意以下输出：</p>
<table>
<thead>
<tr>
<th>12345678910111213141516</th>
<th>Program is using 3756664 bytes of Heap.Program is using 3862504 bytes of Heap.Program is using 3763208 bytes of Heap.Program is using 3763400 bytes of Heap.Program is using 3763424 bytes of Heap.Program is using 3763448 bytes of Heap.Program is using 3763472 bytes of Heap.Program is using 3763496 bytes of Heap.Program is using 3763784 bytes of Heap.Program is using 3763808 bytes of Heap.Program is using 3763832 bytes of Heap.Program is using 3758368 bytes of Heap.Program is using 3758368 bytes of Heap.Program is using 3758368 bytes of Heap.Program is using 3758368 bytes of Heap.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>如果我们绘制数据，它将看起来如下：</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/without-memory-leak.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/without-memory-leak.png" alt="无内存泄漏"></a></p>
<p>Hooray，内存泄漏了。</p>
<p><em>注意，内存使用的初始峰值仍然存在，这是正常的，而你等待程序稳定。注意你的分析中的尖峰，以确保你不会将其解释为内存泄漏。</em></p>
<h2 id="链接到一些其他资源"><a href="#链接到一些其他资源" class="headerlink" title="链接到一些其他资源"></a>链接到一些其他资源</h2><h3 id="使用Chrome-DevTools进行内存分析"><a href="#使用Chrome-DevTools进行内存分析" class="headerlink" title="使用Chrome DevTools进行内存分析"></a>使用Chrome DevTools进行内存分析</h3><iframe width="560" height="315" src="https://www.youtube.com/embed/L3ugr9BJqIs" frameborder="0" allowfullscreen></iframe>

<p>您在本文中阅读的大部分内容都来自上面的视频。本文存在的唯一原因是，我必须在两个星期内观看这个视频3次，以发现（我相信是）的关键点，我想让发现过程更容易为其他人。</p>
<p>我强烈建议观看这个视频补充这篇文章。</p>
<h3 id="另一个有用的工具-memwatch-next"><a href="#另一个有用的工具-memwatch-next" class="headerlink" title="另一个有用的工具 - memwatch-next"></a>另一个有用的工具 - memwatch-next</h3><p>这是另一个很酷的工具，我认为值得一提。你可以<a href="https://hacks.mozilla.org/2012/11/tracking-down-memory-leaks-in-node-js-a-node-js-holiday-season/" target="_blank" rel="external">在这里</a>阅读更多的一些推理（短读，值得你的时间）。</p>
<p>或者直接去回购：<a href="https://github.com/marcominetti/node-memwatch" target="_blank" rel="external">https</a>：<a href="https://github.com/marcominetti/node-memwatch" target="_blank" rel="external">//github.com/marcominetti/node-memwatch</a></p>
<p>为了节省您的点击，您可以安装它 <code>npm install memwatch-next</code></p>
<p>然后使用它与两个事件：</p>
<table>
<thead>
<tr>
<th>12345678910</th>
<th>var memwatch = require(‘memwatch-next’);memwatch.on(‘leak’, function(info) { /<em>Log memory leak info, runs when memory leak is detected </em>/ });memwatch.on(‘stats’, function(stats) { /<em>Log memory stats, runs when V8 does Garbage Collection</em>/ }); //It can also do this…var hd = new memwatch.HeapDiff();// Do something that might leak memoryvar diff = hd.end();console.log(diff);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>最后一个控制台日志将输出如下内容，显示内存中已经生成了什么类型的对象。</p>
<table>
<thead>
<tr>
<th>12345678910111213141516171819</th>
<th>{  “before”: { “nodes”: 11625, “size_bytes”: 1869904, “size”: “1.78 mb” },  “after”:  { “nodes”: 21435, “size_bytes”: 2119136, “size”: “2.02 mb” },  “change”: { “size_bytes”: 249232, “size”: “243.39 kb”, “freed_nodes”: 197,    “allocated_nodes”: 10007,    “details”: [      { “what”: “String”,        “size_bytes”: -2120,  “size”: “-2.07 kb”,  “+”: 3,    “-“: 62      },      { “what”: “Array”,        “size_bytes”: 66687,  “size”: “65.13 kb”,  “+”: 4,    “-“: 78      },      { “what”: “LeakingClass”,        “size_bytes”: 239952, “size”: “234.33 kb”, “+”: 9998, “-“: 0      }    ]  }}</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>很酷。</p>
<h3 id="从developer-chrome-com的JavaScript内存分析"><a href="#从developer-chrome-com的JavaScript内存分析" class="headerlink" title="从developer.chrome.com的JavaScript内存分析"></a>从developer.chrome.com的JavaScript内存分析</h3><p><a href="https://developer.chrome.com/devtools/docs/javascript-memory-profiling" target="_blank" rel="external">https://developer.chrome.com/devtools/docs/javascript-memory-profiling</a></p>
<p>绝对是必读。它涵盖了我所涉及的所有主题和更多，更多的细节，更准确的🙂</p>
<p>不要忽略底部的Addy Osmani的演讲，他提到了一堆调试提示和资源。</p>
<p>你可以幻灯片<a href="https://speakerdeck.com/addyosmani/javascript-memory-management-masterclass" target="_blank" rel="external">在这里</a>：和示例代码<a href="https://github.com/addyosmani/memory-mysteries" target="_blank" rel="external">在这里</a>：</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>请考虑<a href="https://www.alexkras.com/recommends/kindle-memory-leak" target="_blank" rel="external">在Amazon上查看本指南</a>，如果您发现它有帮助。</p>
<ol>
<li>尝试重现和识别内存泄漏时手动触发垃圾收集。您可以从程序中运行带有<code>--expose-gc</code>标志和调用的Node <code>global.gc()</code>。</li>
<li>使用<a href="https://github.com/bnoordhuis/node-heapdump" target="_blank" rel="external">https://github.com/bnoordhuis/node-heapdump</a>采取至少3堆堆转储</li>
<li>使用3堆转储方法隔离内存泄漏</li>
<li>确认内存泄漏已消失</li>
<li>利润</li>
</ol>
<ul>
<li><em>原文：<a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/" target="_blank" rel="external">Simple Guide to Finding a JavaScript Memory Leak in Node.js</a></em></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/JavaScript继承与原型链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/JavaScript继承与原型链/" itemprop="url">
                  JavaScript继承与原型链
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T11:22:27+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JavaScript对于有基于类的语言经验的开发人员来说有点令人困惑 (如Java或C ++) ，因为它是动态的，并且本身不提供类实现.。(在ES2015/ES6中引入了class关键字，但是只是语法糖，JavaScript 仍然是基于原型的)。</p>
<p>当谈到继承时，Javascript 只有一种结构：对象。每个对象都有一个内部链接到另一个对象，称为它的<strong>原型 prototype</strong>。该原型对象有自己的原型，等等，直到达到一个以null为原型的对象。根据定义，null没有原型，并且作为这个<strong>原型链 **</strong>prototype chain**中的最终链接。</p>
<p>虽然，原型继承经常被视作 JavaScript 的一个弱点，但事实上，原型继承模型比经典的继承模型更强大。举例来说，在原型继承模型的基础之上建立一个经典的继承模型是相当容易的。</p>
<h2 id="基于原型链的继承"><a href="#基于原型链的继承" class="headerlink" title="基于原型链的继承"></a>基于原型链的继承</h2><h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h3><p>JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>
<p>遵循ECMAScript标准，<code>someObject.[[Prototype]]</code> 符号是用于指派 <code>someObject</code>的原型。这个等同于 JavaScript 的 <code>__proto__</code>  属性。从 ECMAScript 6 开始, <code>[[Prototype]]</code> 可以用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="external"><code>Object.getPrototypeOf()</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="external"><code>Object.setPrototypeOf()</code></a>访问器来访问。</p>
<p>这里演示当尝试访问属性时会发生什么：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 让我们假设我们有一个对象 o, 其有自己的属性 a 和 b：</span></div><div class="line"><span class="comment">// &#123;a: 1, b: 2&#125;</span></div><div class="line"><span class="comment">// o 的原型 o.[[Prototype]]有属性 b 和 c：</span></div><div class="line"><span class="comment">// &#123;b: 3, c: 4&#125;</span></div><div class="line"><span class="comment">// 最后, o.[[Prototype]].[[Prototype]] 是 null.</span></div><div class="line"><span class="comment">// 这就是原型链的末尾，即 null，</span></div><div class="line"><span class="comment">// 根据定义，null 没有[[Prototype]].</span></div><div class="line"><span class="comment">// 综上，整个原型链如下: </span></div><div class="line"><span class="comment">// &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; null</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 1</span></div><div class="line"><span class="comment">// a是o的自身属性吗？是的，该属性的值为1</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.b); <span class="comment">// 2</span></div><div class="line"><span class="comment">// b是o的自身属性吗？是的，该属性的值为2</span></div><div class="line"><span class="comment">// o.[[Prototype]]上还有一个'b'属性,但是它不会被访问到.这种情况称为"属性遮蔽 (property shadowing)".</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.c); <span class="comment">// 4</span></div><div class="line"><span class="comment">// c是o的自身属性吗？不是，那看看o.[[Prototype]]上有没有.</span></div><div class="line"><span class="comment">// c是o.[[Prototype]]的自身属性吗？是的,该属性的值为4</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.d); <span class="comment">// undefined</span></div><div class="line"><span class="comment">// d是o的自身属性吗？不是,那看看o.[[Prototype]]上有没有.</span></div><div class="line"><span class="comment">// d是o.[[Prototype]]的自身属性吗？不是，那看看o.[[Prototype]].[[Prototype]]上有没有.</span></div><div class="line"><span class="comment">// o.[[Prototype]].[[Prototype]]为null，停止搜索，</span></div><div class="line"><span class="comment">// 没有d属性，返回undefined</span></div></pre></td></tr></table></figure>
<p>创建一个对象它自己的属性的方法就是设置这个对象的属性。唯一例外的获取和设置的行为规则就是当有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters" target="_blank" rel="external">一个 getter或者一个setter</a> 被设置成继承的属性的时候。</p>
<h3 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h3><p>JavaScript 并没有其他基于类的语言所定义的“方法”。在 JavaScript 里，任何函数都可以添加到对象上作为对象的属性。函数的继承与其他的属性继承没有差别，包括上面的“属性遮蔽”（这种情况相当于其他语言的方法重写）。</p>
<p>当继承的函数被调用时，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external"><code>this</code></a> 指向的是当前继承的对象，而不是继承的函数所在的原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  a: <span class="number">2</span>,</div><div class="line">  m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.m()); <span class="comment">// 3</span></div><div class="line"><span class="comment">// 当调用 o.m 时,'this'指向了o.</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</div><div class="line"><span class="comment">// p是一个对象, p.[[Prototype]]是o.</span></div><div class="line"></div><div class="line">p.a = <span class="number">12</span>; <span class="comment">// 创建 p 的自身属性a.</span></div><div class="line"><span class="built_in">console</span>.log(p.m()); <span class="comment">// 13</span></div><div class="line"><span class="comment">// 调用 p.m 时, 'this'指向 p. </span></div><div class="line"><span class="comment">// 又因为 p 继承 o 的 m 函数</span></div><div class="line"><span class="comment">// 此时的'this.a' 即 p.a，即 p 的自身属性 'a'</span></div></pre></td></tr></table></figure>
<h2 id="使用不同的方法来创建对象和生成原型链"><a href="#使用不同的方法来创建对象和生成原型链" class="headerlink" title="使用不同的方法来创建对象和生成原型链"></a>使用不同的方法来创建对象和生成原型链</h2><h3 id="使用普通语法创建对象"><a href="#使用普通语法创建对象" class="headerlink" title="使用普通语法创建对象"></a>使用普通语法创建对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;a: <span class="number">1</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// o这个对象继承了Object.prototype上面的所有属性</span></div><div class="line"><span class="comment">// 所以可以这样使用 o.hasOwnProperty('a').</span></div><div class="line"><span class="comment">// hasOwnProperty 是Object.prototype的自身属性。</span></div><div class="line"><span class="comment">// Object.prototype的原型为null。</span></div><div class="line"><span class="comment">// 原型链如下:</span></div><div class="line"><span class="comment">// o ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">"yo"</span>, <span class="string">"whadup"</span>, <span class="string">"?"</span>];</div><div class="line"></div><div class="line"><span class="comment">// 数组都继承于Array.prototype </span></div><div class="line"><span class="comment">// (indexOf, forEach等方法都是从它继承而来).</span></div><div class="line"><span class="comment">// 原型链如下:</span></div><div class="line"><span class="comment">// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数都继承于Function.prototype</span></div><div class="line"><span class="comment">// (call, bind等方法都是从它继承而来):</span></div><div class="line"><span class="comment">// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></div></pre></td></tr></table></figure>
<h3 id="使用构造器创建对象"><a href="#使用构造器创建对象" class="headerlink" title="使用构造器创建对象"></a>使用构造器创建对象</h3><p>在 JavaScript 中，构造器其实就是一个普通的函数。当使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="external">new 操作符</a> 来作用这个函数时，它就可以被称为构造方法（构造函数）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.vertexes = [];</div><div class="line">  <span class="keyword">this</span>.edges = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Graph.prototype = &#123;</div><div class="line">  addVertex: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.vertexes.push(v);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Graph();</div><div class="line"><span class="comment">// g是生成的对象,他的自身属性有'vertices'和'edges'.</span></div><div class="line"><span class="comment">// 在g被实例化时,g.[[Prototype]]指向了Graph.prototype.</span></div></pre></td></tr></table></figure>
<h3 id="使用-Object-create-创建对象"><a href="#使用-Object-create-创建对象" class="headerlink" title="使用 Object.create 创建对象"></a>使用 Object.create 创建对象</h3><p>ECMAScript 5 中引入了一个新方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external"><code>Object.create()</code></a>。可以调用这个方法来创建一个新对象。新对象的原型就是调用 <code>create</code> 方法时传入的第一个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;a: <span class="number">1</span>&#125;; </div><div class="line"><span class="comment">// a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</div><div class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(b.a); <span class="comment">// 1 (继承而来)</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>.create(b);</div><div class="line"><span class="comment">// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> d = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="comment">// d ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(d.hasOwnProperty); <span class="comment">// undefined, 因为d没有继承Object.prototype</span></div></pre></td></tr></table></figure>
<h3 id="使用-class-关键字"><a href="#使用-class-关键字" class="headerlink" title="使用 class 关键字"></a>使用 <code>class</code> 关键字</h3><p>ECMAScript6 引入了一套新的关键字用来实现 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">class</a>。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不一样的。 JavaScript 仍然是基于原型的。这些新的关键字包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class" target="_blank" rel="external"><code>class</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/constructor" target="_blank" rel="external"><code>constructor</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/static" target="_blank" rel="external"><code>static</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/extends" target="_blank" rel="external"><code>extends</code></a>, 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super" target="_blank" rel="external"><code>super</code></a>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(height, width) &#123;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(sideLength) &#123;</div><div class="line">    <span class="keyword">super</span>(sideLength, sideLength);</div><div class="line">  &#125;</div><div class="line">  get area() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</div><div class="line">  &#125;</div><div class="line">  set sideLength(newLength) &#123;</div><div class="line">    <span class="keyword">this</span>.height = newLength;</div><div class="line">    <span class="keyword">this</span>.width = newLength;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。</p>
<p>遍历对象的属性时，原型链上的<strong>每个</strong>可枚举属性都会被枚举出来。</p>
<p>检测对象的属性是定义在自身上还是在原型链上，有必要使用 <a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="external">hasOwnProperty</a> 方法，所有继承自 <code>Object.proptotype 的对象都包含这个方法</code>。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="external">hasOwnProperty</a> 是 JavaScript 中唯一一个只涉及对象自身属性而不会遍历原型链的方法。</p>
<p>注意：仅仅通过判断值是否为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="external">undefined</a> 还<strong>不</strong>足以检测一个属性是否存在，一个属性可能存在而其值恰好为 <code>undefined</code>。</p>
<h3 id="不好的实践：扩展原生对象的原型"><a href="#不好的实践：扩展原生对象的原型" class="headerlink" title="不好的实践：扩展原生对象的原型"></a>不好的实践：扩展原生对象的原型</h3><p>一个经常被用到的错误实践是去扩展 <code>Object.prototype</code> 或者其他内置对象的原型。</p>
<p>该技术被称为 monkey patching，它破坏了原型链的密封性。尽管，一些流行的框架（如 Prototype.js）在使用该技术，但是并没有足够好的理由要用其他<em>非标准</em>的方法将内置的类型系统搞乱。</p>
<p>我们去扩展内置对象原型的<strong>唯一</strong>理由是引入新的 JavaScript 引擎的某些新特性，比如 <code>Array.forEach</code>。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>B</code> 将继承自 <code>A：</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.varA = a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 以上函数 A 的定义中，既然 A.prototype.varA 总是会被 this.varA 遮蔽，</span></div><div class="line"><span class="comment">// 那么将 varA 加入到原型（prototype）中的目的是什么？</span></div><div class="line">A.prototype = &#123;</div><div class="line">  varA : <span class="literal">null</span>,  </div><div class="line"><span class="comment">/*</span></div><div class="line">既然它没有任何作用，干嘛不将 varA 从原型（prototype）去掉 ? </div><div class="line">也许作为一种在隐藏类中优化分配空间的考虑 ?</div><div class="line">https://developers.google.com/speed/articles/optimizing-javascript </div><div class="line">如果varA并不是在每个实例中都被初始化，那这样做将是有效果的。</div><div class="line">*/</div><div class="line">  doSomething : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">a, b</span>)</span>&#123;</div><div class="line">  A.call(<span class="keyword">this</span>, a);</div><div class="line">  <span class="keyword">this</span>.varB = b;</div><div class="line">&#125;</div><div class="line">B.prototype = <span class="built_in">Object</span>.create(A.prototype, &#123;</div><div class="line">  varB : &#123;</div><div class="line">    value: <span class="literal">null</span>, </div><div class="line">    enumerable: <span class="literal">true</span>, </div><div class="line">    configurable: <span class="literal">true</span>, </div><div class="line">    writable: <span class="literal">true</span> </div><div class="line">  &#125;,</div><div class="line">  doSomething : &#123; </div><div class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// override</span></div><div class="line">      A.prototype.doSomething.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); </div><div class="line">      <span class="comment">// call super</span></div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line">    enumerable: <span class="literal">true</span>,</div><div class="line">    configurable: <span class="literal">true</span>, </div><div class="line">    writable: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">B.prototype.constructor = B;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</div><div class="line">b.doSomething();</div></pre></td></tr></table></figure>
<p><code>最重要的部分是：</code></p>
<ul>
<li><code>类型被定义在 .prototype 中</code></li>
<li><code>而你用 Object.create() 来继承</code></li>
</ul>
<h2 id="prototype-和-Object-getPrototypeOf"><a href="#prototype-和-Object-getPrototypeOf" class="headerlink" title="prototype 和 Object.getPrototypeOf"></a><code>prototype 和 Object.getPrototypeOf</code></h2><p><code>对于从 Java 或 C++ 转过来的开发人员来说 JavaScript 会有点让人困惑，因为它全部都是动态的，都是运行时，而且不存在类（classes）。所有的都是实例（对象）。即使我们模拟出的 “类（classes）”，也只是一个函数对象。</code></p>
<p><code>你可能已经注意到，我们的函数 A 有一个特殊的属性叫做原型。这个特殊的属性与 JavaScript 的 new 运算符一起工作。对原型对象的引用会复制到新实例内部的 [[Prototype]] 属性。例如，当你这样： var a1 = new A()， JavaScript 就会设置：a1.[[Prototype]] = A.prototype（在内存中创建对象后，并在运行 this 绑定的函数 A()之前）。然后在你访问实例的属性时，JavaScript 首先检查它们是否直接存在于该对象中（即是否是该对象的自身属性），如果不是，它会在 [[Prototype]] 中查找。也就是说，你在原型中定义的元素将被所有实例共享，甚至可以在稍后对原型进行修改，这种变更将影响到所有现存实例。</code></p>
<p><code>像上面的例子中，如果你执行 var a1 = new A(); var a2 = new A(); 那么 a1.doSomething 事实上会指向Object.getPrototypeOf(a1).doSomething，它就是你在 A.prototype.doSomething 中定义的内容。比如：Object.getPrototypeOf(a1).doSomething == Object.getPrototypeOf(a2).doSomething == A.prototype.doSomething。</code></p>
<p><code>简而言之， prototype 是用于类型的，而 Object.getPrototypeOf() 是用于实例的（instances），两者功能一致。</code></p>
<p><code>[[Prototype]] 看起来就像**递归**引用， 如a1.doSomething，Object.getPrototypeOf(a1).doSomething，Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething 等等等， 直到它找到 doSomething 这个属性或者 Object.getPrototypeOf 返回 null。</code></p>
<p><code>因此，当你执行：</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Foo();</div></pre></td></tr></table></figure>
<p><code>JavaScript 实际上执行的是：</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o.[[Prototype]] = Foo.prototype;</div><div class="line">Foo.call(o);</div></pre></td></tr></table></figure>
<p><code>（或者类似上面这样的），然后当你执行：</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">o.someProp;</div></pre></td></tr></table></figure>
<p><code>它会检查是否存在 someProp 属性。如果没有，它会查找Object.getPrototypeOf(o).someProp ,如果仍旧没有，它会继续查找Object.getPrototypeOf(Object.getPrototypeOf(o)).someProp ，一直查找下去，直到它找到这个属性 或者 Object.getPrototypeOf() 返回 null 。</code></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><code>结论</code></h2><p><code>在用原型继承编写复杂代码前理解原型继承模型十分**重要**。同时，还要清楚代码中原型链的长度，并在必要时结束原型链，以避免可能存在的性能问题。此外，除非为了兼容新 JavaScript 特性，否则，永远**不要**扩展原生的对象原型。</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/JavaScript内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/JavaScript内存管理/" itemprop="url">
                  JavaScript内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T10:33:23+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>诸如 C 语言这般的低级语言一般都有低级的内存管理接口，比如 <code>malloc() 和</code> <code>free()</code>。而另外一些高级语言，比如 JavaScript， 其在变量（对象，字符串等等）创建时分配内存，然后在它们不再使用时“自动”释放。后者被称为<strong>垃圾回收</strong>。“自动”是容易让人混淆，迷惑的，并给 JavaScript（和其他高级语言）开发者一个印象：他们可以不用关心内存管理。然而这是错误的。</p>
<h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>不管什么程序语言，内存生命周期基本是一致的：   </p>
<ol>
<li>分配你所需要的内存</li>
<li>使用分配到的内存（读、写）</li>
<li>不需要时将其释放\归还</li>
</ol>
<p>在所有语言中第一和第二部分都很清晰。最后一步在低级语言中很清晰，但是在像JavaScript 等高级语言中，这一步是隐藏的、透明的。</p>
<h3 id="JavaScript-的内存分配"><a href="#JavaScript-的内存分配" class="headerlink" title="JavaScript 的内存分配"></a>JavaScript 的内存分配</h3><h4 id="值的初始化"><a href="#值的初始化" class="headerlink" title="值的初始化"></a>值的初始化</h4><p>为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// 给数值变量分配内存</span></div><div class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span>; <span class="comment">// 给字符串分配内存</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  a: <span class="number">1</span>,</div><div class="line">  b: <span class="literal">null</span></div><div class="line">&#125;; <span class="comment">// 给对象及其包含的值分配内存</span></div><div class="line"></div><div class="line"><span class="comment">// 给数组及其包含的值分配内存（就像对象一样）</span></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">"abra"</span>]; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a + <span class="number">2</span>;</div><div class="line">&#125; <span class="comment">// 给函数（可调用的对象）分配内存</span></div><div class="line"></div><div class="line"><span class="comment">// 函数表达式也能分配一个对象</span></div><div class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span>;</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h4 id="通过函数调用的内存分配"><a href="#通过函数调用的内存分配" class="headerlink" title="通过函数调用的内存分配"></a>通过函数调用的内存分配</h4><p>有些函数调用结果是分配对象内存：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 分配一个 Date 对象</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); <span class="comment">// 分配一个 DOM 元素</span></div></pre></td></tr></table></figure>
<p>有些方法分配新变量或者新对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span>;</div><div class="line"><span class="keyword">var</span> s2 = s.substr(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2 是一个新的字符串</span></div><div class="line"><span class="comment">// 因为字符串是不变量，</span></div><div class="line"><span class="comment">// JavaScript 可能决定不分配内存，</span></div><div class="line"><span class="comment">// 只是存储了 [0-3] 的范围。</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">"ouais ouais"</span>, <span class="string">"nan nan"</span>];</div><div class="line"><span class="keyword">var</span> a2 = [<span class="string">"generation"</span>, <span class="string">"nan nan"</span>];</div><div class="line"><span class="keyword">var</span> a3 = a.concat(a2); </div><div class="line"><span class="comment">// 新数组有四个元素，是 a 连接 a2 的结果</span></div></pre></td></tr></table></figure>
<h3 id="值的使用"><a href="#值的使用" class="headerlink" title="值的使用"></a>值的使用</h3><p>使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p>
<h3 id="当内存不再需要使用时释放"><a href="#当内存不再需要使用时释放" class="headerlink" title="当内存不再需要使用时释放"></a>当内存不再需要使用时释放</h3><p>大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。</p>
<p>高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是<a href="http://en.wikipedia.org/wiki/Decidability_%28logic%29" target="_blank" rel="external">无法判定的</a> (无法通过某种算法解决).</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。本节将解释必要的概念，了解主要的垃圾回收算法和它们的局限性。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>垃圾回收算法主要依赖于<strong>引用</strong>（<em>reference</em>）的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它<a href="https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain" target="_blank" rel="external">原型</a>的引用（隐式引用）和对它属性的引用（显式引用）。</p>
<p>在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。</p>
<h3 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h3><p>这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123; </div><div class="line">  a: &#123;</div><div class="line">    b:<span class="number">2</span></div><div class="line">  &#125;</div><div class="line">&#125;; </div><div class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></div><div class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// o2变量是第二个对“这个对象”的引用</span></div><div class="line"></div><div class="line">o = <span class="number">1</span>;      <span class="comment">// 现在，“这个对象”的原始引用o被o2替换了</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> oa = o2.a; <span class="comment">// 引用“这个对象”的a属性</span></div><div class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></div><div class="line"></div><div class="line">o2 = <span class="string">"yo"</span>; <span class="comment">// 最初的对象现在已经是零引用了</span></div><div class="line">           <span class="comment">// 他可以被垃圾回收了</span></div><div class="line">           <span class="comment">// 然而它的属性a的对象还在被oa引用，所以还不能回收</span></div><div class="line"></div><div class="line">oa = <span class="literal">null</span>; <span class="comment">// a属性的那个对象现在也是零引用了</span></div><div class="line">           <span class="comment">// 它可以被垃圾回收了</span></div></pre></td></tr></table></figure>
<h4 id="限制：循环引用"><a href="#限制：循环引用" class="headerlink" title="限制：循环引用"></a>限制：循环引用</h4><p>该算法有个限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</div><div class="line">  o.a = o2; <span class="comment">// o 引用 o2</span></div><div class="line">  o2.a = o; <span class="comment">// o2 引用 o</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">"azerty"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<h4 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h4><p>IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄露：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div;</div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  div = <span class="built_in">document</span>.getElementById(<span class="string">"myDivElement"</span>);</div><div class="line">  div.circularReference = div;</div><div class="line">  div.lotsOfData = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).join(<span class="string">"*"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在上面的例子里，<code>myDivElement</code> 这个 DOM 元素里的 <code>circularReference 属性</code>引用了 <code>myDivElement</code>，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 <code>lotsOfData</code> 属性)，而这个数据占用的内存将永远不会被释放。</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p>
<p>这个算法假定设置一个叫做<strong>根</strong>（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p>
<p>这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。</p>
<p>从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。</p>
<h4 id="循环引用不再是问题了"><a href="#循环引用不再是问题了" class="headerlink" title="循环引用不再是问题了"></a>循环引用不再是问题了</h4><p>在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。</p>
<p>第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收<br>。</p>
<h4 id="限制-那些无法从根对象查询到的对象都将被清除"><a href="#限制-那些无法从根对象查询到的对象都将被清除" class="headerlink" title="限制: 那些无法从根对象查询到的对象都将被清除"></a>限制: 那些无法从根对象查询到的对象都将被清除</h4><p>尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/JavaScript模块系统对决(PK)：CommonJS-vs-AMD-vs-ES2015/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/JavaScript模块系统对决(PK)：CommonJS-vs-AMD-vs-ES2015/" itemprop="url">
                  JavaScript模块系统对决(PK)：CommonJS vs AMD vs ES2015
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T17:09:52+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>了解目前使用的不同JavaScript模块系统，并找出哪些是您的项目的最佳选择。</p>
</blockquote>
<p>随着JavaScript开发越来越普遍，命名空间和depedencies更难以处理。开发了不同的解决方案以模块系统的形式来处理这个问题。在这篇文章中，我们将探讨开发人员目前使用的不同解决方案以及他们尝试解决的问题。阅读！</p>
<hr>
<h2 id="简介：为什么需要JavaScript模块？"><a href="#简介：为什么需要JavaScript模块？" class="headerlink" title="简介：为什么需要JavaScript模块？"></a>简介：为什么需要JavaScript模块？</h2><p>如果你熟悉其他开发平台，你可能有一些概念的<em>封装</em>和<em>依赖</em>的概念。通常孤立地开发不同的软件，直到先前存在的软件需要满足某些需求。在将其他软件带入项目的时刻，在它和新的代码之间创建依赖关系。由于这些软件需要一起工作，因此它们之间不会出现冲突是很重要的。这可能听起来很小，但是没有某种<em>封装，</em>这是两个<em>模块</em>相互冲突之前的时间问题。这是C库中的元素之一通常带有前缀的原因之一：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYLIB_INIT_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLIB_INIT_H</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> mylib_init_code &#123;</div><div class="line">    mylib_init_code_success,</div><div class="line">    mylib_init_code_error</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">enum</span> mylib_init_code <span class="title">mylib_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// (...)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//MYLIB_INIT_H</span></span></div></pre></td></tr></table></figure>
<p>封装对于防止冲突和缓解发展至关重要。</p>
<p>当涉及到依赖关系时，在传统的客户端JavaScript开发中，它们是隐式的。换句话说，开发者的任务是确保在执行任何代码块时都满足依赖关系。开发人员还需要确保依赖关系以正确的顺序满足（某些库的要求）。</p>
<p>以下示例是<a href="https://github.com/jashkenas/backbone/blob/master/examples/todos/index.html" target="_blank" rel="external">Backbone.js的</a>示例的一部分。脚本以正确的顺序手动加载：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Backbone.js Todos<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"todos.css"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../test/vendor/json2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../test/vendor/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../test/vendor/underscore.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../backbone.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../backbone.localStorage.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"todos.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- (...) --&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>随着JavaScript开发变得越来越复杂，依赖管理可能变得麻烦。重构也受损：在哪里应该更新的依赖关系来维持负载链的正确顺序？</p>
<p>JavaScript模块系统试图处理这些问题和其他问题。他们出生的必要性，以适应不断增长的JavaScript景观。让我们看看不同的解决方案带来的表。</p>
<h2 id="一个Ad-Hoc解决方案：显露模块模式"><a href="#一个Ad-Hoc解决方案：显露模块模式" class="headerlink" title="一个Ad-Hoc解决方案：显露模块模式"></a>一个Ad-Hoc解决方案：显露模块模式</h2><p>大多数模块系统相对较新。在它们可用之前，特定的编程模式开始越来越多地被使用在越来越多的JavaScript代码：揭示模块模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myRevealingModule = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> privateVar = <span class="string">"Ben Cherry"</span>,</div><div class="line">        publicVar = <span class="string">"Hey there!"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Name:"</span> + privateVar );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">publicSetName</span>(<span class="params"> strName </span>) </span>&#123;</div><div class="line">        privateVar = strName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">publicGetName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        privateFunction();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Reveal public pointers to</span></div><div class="line">    <span class="comment">// private functions and properties</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        setName: publicSetName,</div><div class="line">        greeting: publicVar,</div><div class="line">        getName: publicGetName</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">myRevealingModule.setName( <span class="string">"Paul Kinlan"</span> );</div></pre></td></tr></table></figure>
<blockquote>
<p>这个例子取自<a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/" target="_blank" rel="external">Addy Osmani的JavaScript设计模式</a>书。</p>
</blockquote>
<p>JavaScript范围（至少达到ES2015中<code>let</code>的外观）在函数级别工作。换句话说，在函数中声明的任何绑定都不能逃避它的作用域。正是由于这个原因，揭示模块模式依赖于封装私有内容的函数（像许多其他JavaScript模式一样）。</p>
<p>在上面的示例中，<em>公共</em>符号在返回的字典中显示。所有其他声明由包围它们的函数作用域保护。不必使用<code>var</code>和立即调用包含私有作用域的函数; 一个命名函数也可以用于模块。</p>
<p>这种模式已经在JavaScript项目中使用了相当长的时间，并且与封装事物相当好。它不做太多关于依赖性问题。正确的模块系统也尝试处理这个问题。另一个限制在于，包括其他模块不能在同一源（除非使用<code>eval</code>）。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>足够简单，可以在任何地方实现（没有库，不需要语言支持）。</li>
<li>可以在单个文件中定义多个模块。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>没有办法以编程方式导入模块（除了使用<code>eval</code>）。</li>
<li>依赖需要手动处理。</li>
<li>模块的异步加载是不可能的。</li>
<li>循环依赖可能很麻烦。</li>
<li>很难分析静态代码分析器。</li>
</ul>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>CommonJS是一个旨在定义一系列规范以帮助开发服务器端JavaScript应用程序的项目。CommonJS团队尝试解决的一个领域是模块。Node.js开发人员原本打算遵循CommonJS规范，但后来决定反对它。当涉及到模块时，Node.js的实现非常受它的影响：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In circle.js</span></div><div class="line"><span class="keyword">const</span> PI = <span class="built_in">Math</span>.PI;</div><div class="line"></div><div class="line">exports.area = (r) =&gt; PI * r * r;</div><div class="line"></div><div class="line">exports.circumference = (r) =&gt; <span class="number">2</span> * PI * r;</div><div class="line"></div><div class="line"><span class="comment">// In some file</span></div><div class="line"><span class="keyword">const</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>);</div><div class="line"><span class="built_in">console</span>.log( <span class="string">`The area of a circle of radius 4 is <span class="subst">$&#123;circle.area(4)&#125;</span>`</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>在一个晚上，当我提到一个令人沮丧的请求一个功能，我认为是一个可怕的想法，Joyent对我说，“忘记CommonJS。它已经死了，我们是服务器端的JavaScript。- <a href="https://github.com/nodejs/node-v0.x-archive/issues/5132#issuecomment-15432598" target="_blank" rel="external">NPM创建者Isaac Z. Schlueter引用Node.js创建者Ryan Dahl</a></p>
</blockquote>
<p>在Node.js的模块系统的顶部有以库的形式的抽象，以桥接Node.js的模块和CommonJS之间的差距。为了这篇文章的目的，我们将只显示大致相同的基本功能。</p>
<p>在Node和CommonJS的模块中，基本上有两个元素与模块系统交互：<code>require</code>和<code>exports</code>。<code>require</code>是一个可用于将符号从另一个模块导入到当前作用域的函数。传递给<code>require</code>的<em>参数</em>是模块的<em>id</em>。在Node的实现中，它是目录中模块的名称<code>node_modules</code>（或者，如果它不在该目录中，则是它的路径）。<code>exports</code>是一个特殊的对象：放在其中的任何东西将被导出为一个公共元素。字段的名称保留。Node和CommonJS之间的特殊区别是以<code>module.exports</code>对象的形式出现。在Node中，<code>module.exports</code>是被导出的真正的特殊对象，而<code>exports</code>只是一个默认绑定的变量<code>module.exports</code>。<code>module.exports</code>另一方面，CommonJS没有对象。实际的含义是，在节点中，不可能导出完全预构造的对象，而不通过<code>module.exports</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This won't work, replacing exports entirely breaks the binding to</span></div><div class="line"><span class="comment">// modules.exports.</span></div><div class="line">exports =  (width) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    area: () =&gt; width * width</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// This works as expected.</span></div><div class="line"><span class="built_in">module</span>.exports = (width) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    area: () =&gt; width * width</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CommonJS模块的设计考虑了服务器开发。当然，API是同步的。换句话说，模块在源文件中的时刻和它们所需的顺序被加载。</p>
<blockquote>
<p><a href="https://twitter.com/intent/tweet?text=%22CommonJS%20modules%20were%20designed%20with%20server%20development%20in%20mind.%22%20via%20@auth0%20http://auth0.com/blog/javascript-module-systems-showdown/" target="_blank" rel="external">“CommonJS模块的设计考虑了服务器开发。TWEET这个 <img src="https://cdn.auth0.com/blog/resources/twitter.svg" alt="img"></a></p>
</blockquote>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>简单：开发人员可以抓住这个概念，而不用看文档。</li>
<li>集成了依赖性管理：模块需要其他模块，并按需要加载。</li>
<li><code>require</code> 可以在任何地方调用：模块可以以编程方式加载。</li>
<li>支持循环依赖性。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>同步API使其不适合某些用途（客户端）。</li>
<li>每个模块一个文件。</li>
<li>浏览器需要加载器库或翻译。</li>
<li>没有模块的构造函数（Node支持这个功能）。</li>
<li>很难分析静态代码分析器。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们已经谈到了一个实现（部分形式）：Node.js.</p>
<p><img src="https://cdn.auth0.com/blog/jsmodules/Node.js_logo.svg" alt="Node.js JavaScript模块"></p>
<p>对于客户端，目前有两个受欢迎的选项：<a href="https://webpack.github.io/docs/commonjs.html" target="_blank" rel="external">webpack</a>和<a href="http://browserify.org/index.html" target="_blank" rel="external">browserify</a>。Browserify被明确发展解析节点般的模块定义（多节点程序包工作外的开箱即用的吧！），并捆绑你的代码加上这些模块中携带的所有依赖一个单一的文件中的代码。在另一方面Webpack中被开发用于处理发布之前创建源转换的复杂管道。这包括将CommonJS模块捆绑在一起。</p>
<h2 id="异步模块定义（AMD）"><a href="#异步模块定义（AMD）" class="headerlink" title="异步模块定义（AMD）"></a>异步模块定义（AMD）</h2><p>AMD是由一群不喜欢CommonJS所采用的方向的开发者组成的。事实上，AMD在开发初期就从CommonJS中分离出来。AMD和CommonJS的主要区别在于它支持异步模块加载。</p>
<blockquote>
<p><a href="https://twitter.com/intent/tweet?text=%22The%20main%20difference%20between%20AMD%20and%20CommonJS%20lies%20in%20its%20support%20for%20asynchronous%20module%20loading.%22%20via%20@auth0%20http://auth0.com/blog/javascript-module-systems-showdown/" target="_blank" rel="external">“AMD和CommonJS的主要区别在于它支持异步模块加载。TWEET这个 <img src="https://cdn.auth0.com/blog/resources/twitter.svg" alt="img"></a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Calling define with a dependency array and a factory function</span></div><div class="line">define([<span class="string">'dep1'</span>, <span class="string">'dep2'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">dep1, dep2</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//Define the module value by returning a value.</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Or:</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dep1 = <span class="built_in">require</span>(<span class="string">'dep1'</span>),</div><div class="line">        dep2 = <span class="built_in">require</span>(<span class="string">'dep2'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>异步加载是通过使用JavaScript的传统闭包成语实现的：当所请求的模块完成加载时调用一个函数。模块定义和导入模块由相同的函数承载：当模块被定义时，其依赖性被显式化。因此，AMD加载器可以在运行时对给定项目的依赖图的完整图片。因此，可以同时加载彼此不依赖于加载的库。这对于浏览器尤其重要，因为启动时间对于良好的用户体验至关重要。</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>异步加载（更好的启动时间）。</li>
<li>支持循环依赖性。</li>
<li>兼容性<code>require</code>和<code>exports</code>。</li>
<li>依赖管理完全集成。</li>
<li>如果需要，模块可以分割成多个文件。</li>
<li>支持构造函数。</li>
<li>插件支持（自定义加载步骤）。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>句法稍微复杂一些。</li>
<li>加载器库是必需的，除非传递。</li>
<li>很难分析静态代码分析器。</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>目前最流行的AMD实现是<a href="http://requirejs.org/" target="_blank" rel="external">require.js</a>和<a href="https://dojotoolkit.org/" target="_blank" rel="external">Dojo</a>。</p>
<p><img src="https://cdn.auth0.com/blog/jsmodules/requirejs-logo.svg" alt="Require.js for JavaScript模块"></p>
<p>使用require.js非常简单：在HTML文件中包含库，并使用<code>data-main</code>属性告诉require.js应该首先加载哪个模块。Dojo有<a href="http://dojotoolkit.org/documentation/tutorials/1.10/hello_dojo/index.html" target="_blank" rel="external">类似的设置</a>。</p>
<h2 id="ES2015模块"><a href="#ES2015模块" class="headerlink" title="ES2015模块"></a>ES2015模块</h2><p>幸运的是，ECMA团队背后的标准化JavaScript决定解决模块的问题。结果可以在最新版本的JavaScript标准中看到：ECMAScript 2015（以前称为ECMAScript 6）。结果是语法上愉快的，并且与同步和异步操作模式兼容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//------ lib.js ------</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.sqrt;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diag</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> sqrt(square(x) + square(y));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//------ main.js ------</span></div><div class="line"><span class="keyword">import</span> &#123; square, diag &#125; <span class="keyword">from</span> <span class="string">'lib'</span>;</div><div class="line"><span class="built_in">console</span>.log(square(<span class="number">11</span>)); <span class="comment">// 121</span></div><div class="line"><span class="built_in">console</span>.log(diag(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<blockquote>
<p>示例取自<a href="http://www.2ality.com/2014/09/es6-modules-final.html" target="_blank" rel="external">Axel Rauschmayer博客</a></p>
</blockquote>
<p>该<code>import</code>伪指令可以用于将模块带入命名空间。这个指令，与<code>require</code>和<code>define</code>不是动态的（即它不能在任何地方被调用）。<code>export</code>另一方面，该指令可以用于将元素显式地公开。</p>
<p>静态特性<code>import</code>和<code>export</code>静态指令允许静态分析器构建一个完整的依赖关系树，而不需要运行代码。ES2015不支持动态加载模块，但草案规范：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">System.import(<span class="string">'some_module'</span>)</div><div class="line">      .then(some_module =&gt; &#123;</div><div class="line">          <span class="comment">// Use some_module</span></div><div class="line">      &#125;)</div><div class="line">      .catch(error =&gt; &#123;</div><div class="line">          <span class="comment">// ...</span></div><div class="line">      &#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>实际上，ES2015 <a href="https://github.com/lukehoban/es6features/issues/75" target="_blank" rel="external">只指定</a>静态模块装载器<a href="https://github.com/lukehoban/es6features/issues/75" target="_blank" rel="external">的语法</a>。实际上，在解析这些指令之后，ES2015实现不需要做任何事情。仍然需要模块加载器，如System.js。提供了浏览器模块加载的草案<a href="https://github.com/whatwg/loader" target="_blank" rel="external">规范</a>。</p>
</blockquote>
<p>这个解决方案通过集成在语言中，使运行时选择模块的最佳加载策略。换句话说，当异步加载产生好处时，它可以被运行时使用。</p>
<blockquote>
<p><strong>更新（2017年2月）：</strong>现在有一个<a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="external">动态加载模块</a>的<a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="external">规范</a>。这是对ECMAScript标准的未来版本的提议。</p>
</blockquote>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li>支持同步和异步加载。</li>
<li>语法简单。</li>
<li>支持静态分析工具。</li>
<li>集成在语言（最终支持到处，不需要图书馆）。</li>
<li>支持循环依赖。</li>
</ul>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>仍然不支持全部。</li>
</ul>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>遗憾的是，没有一个主要的JavaScript运行时在其当前稳定的分支中支持ES2015模块。这意味着在Firefox，Chrome或Node.js中不支持。幸运的是，许多转换器支持模块，并且<a href="https://github.com/ModuleLoader/es6-module-loader" target="_blank" rel="external">polyfill</a>也可用。目前，为<a href="https://babeljs.io/" target="_blank" rel="external">Babel</a>预设的ES2015 可以毫无问题地处理模块。</p>
<p><img src="https://cdn.auth0.com/blog/jsmodules/babel.png" alt="Babel for JavaScript模块"></p>
<h2 id="一体化解决方案：System-js"><a href="#一体化解决方案：System-js" class="headerlink" title="一体化解决方案：System.js"></a>一体化解决方案：System.js</h2><p>你可能会发现自己试图使用一个模块系统远离遗留代码。或者你可能想确保发生了什么，你选择的解决方案仍然可以工作。输入<a href="https://github.com/systemjs/systemjs" target="_blank" rel="external">System.js</a>：支持CommonJS，AMD和ES2015模块的通用模块加载程序。它可以与转换器一起工作，如Babel或Traceur，并且可以支持Node和IE8 +环境。使用它是在代码中加载System.js，然后将其指向您的基本URL：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"system.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="comment">// set our baseURL reference path</span></div><div class="line">  System.config(&#123;</div><div class="line">    baseURL: <span class="string">'/app'</span>,</div><div class="line">    <span class="comment">// or 'traceur' or 'typescript'</span></div><div class="line">    transpiler: <span class="string">'babel'</span>,</div><div class="line">    <span class="comment">// or traceurOptions or typescriptOptions</span></div><div class="line">    babelOptions: &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="comment">// loads /app/main.js</span></div><div class="line">  System.import(<span class="string">'main.js'</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>由于System.js可以即时完成所有工作，因此使用ES2015模块通常应该在生产模式下的构建步骤中保留给转换器。当不处于生产模式时，System.js可以为您调用转换程序，提供生产和调试环境之间的无缝转换。</p>
<h2 id="Aside：我们在Auth0使用什么"><a href="#Aside：我们在Auth0使用什么" class="headerlink" title="Aside：我们在Auth0使用什么"></a>Aside：我们在Auth0使用什么</h2><p>在Auth0，我们大量使用JavaScript。对于我们的服务器端代码，我们使用CommonJS风格的Node.js模块。对于某些客户端代码，我们更喜欢AMD。对于我们基于React的<a href="https://github.com/auth0/lock-passwordless" target="_blank" rel="external">无密码锁库，</a>我们选择了ES2015模块。</p>
<p>喜欢你看到的？<a href="javascript:signup(" target="_blank" rel="external">注册</a>)并开始在您的项目中使用Auth0。</p>
<p>你是一个开发人员，喜欢我们的代码？如果是，<a href="https://auth0.com/jobs" target="_blank" rel="external">请</a>立即<a href="https://auth0.com/jobs" target="_blank" rel="external">申请</a>工程学位置。我们有一个真棒团队！</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>构建模块和处理依赖性在过去是麻烦的。较新的解决方案，以图书馆或ES2015模块的形式，已经消耗了大部分的痛苦。如果你正在寻找一个新的模块或项目，ES2015是正确的方法去。它将始终被支持，并且使用transpiler和polyfills的当前支持是优秀的。另一方面，如果你更喜欢使用纯ES5代码，那么客户端的AMD和服务器的CommonJS / Node之间的通常分割仍然是通常的选择。不要忘记在下面的评论部分留下你的想法。Hack on！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/Javascript中4种类型的内存泄漏和如何摆脱它们/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/Javascript中4种类型的内存泄漏和如何摆脱它们/" itemprop="url">
                  Javascript中4种类型的内存泄漏和如何摆脱它们
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T14:22:06+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/" target="_blank" rel="external">4 Types of Memory Leaks in JavaScript and How to Get Rid Of Them</a></p>
<p>了解JavaScript中的内存泄漏，以及可以做什么来解决它！</p>
</blockquote>
<p>在本文中，我们将探讨客户端JavaScript代码中的常见类型的内存泄漏。我们还将学习如何使用Chrome开发工具找到它们！</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>内存泄漏是每个开发人员最终面临的问题。即使使用内存管理的语言，也有可能泄漏内存的情况。泄漏是整类问题的原因：减速，崩溃，高延迟，甚至与其他应用程序的问题。</p>
<blockquote>
<p>诸如 C 语言这般的低级语言一般都有低级的内存管理接口，比如 <code>malloc() 和</code> <code>free()</code>。而另外一些高级语言，比如 JavaScript， 其在变量（对象，字符串等等）创建时分配内存，然后在它们不再使用时“自动”释放。后者被称为<strong>垃圾回收</strong>。“自动”是容易让人混淆，迷惑的，并给 JavaScript（和其他高级语言）开发者一个印象：他们可以不用关心内存管理。然而这是错误的。</p>
</blockquote>
<h3 id="什么是内存泄露？"><a href="#什么是内存泄露？" class="headerlink" title="什么是内存泄露？"></a>什么是内存泄露？</h3><p>实质上，内存泄漏可以定义为应用程序不再需要的内存，因为某种原因，该内存不会返回到操作系统或可用内存池。编程语言有利于不同的管理内存的方式。这些方式可以减少泄漏内存的机会。然而，某一块内存是否未被使用实际上是一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management#Release_when_the_memory_is_not_needed_anymore" target="_blank" rel="external">不可判定的问题</a>。换句话说，只有开发人员才能明确是否可以将一块内存返回到操作系统。某些编程语言提供了帮助开发人员做这些的功能。其他人期望开发人员完全明确一段内存未使用。维基百科有关于<a href="https://en.wikipedia.org/wiki/Manual_memory_management" target="_blank" rel="external">手动</a>和<a href="https://en.wikipedia.org/wiki/Manual_memory_management" target="_blank" rel="external">自动</a>内存管理的好文章。</p>
<h3 id="JavaScript中的内存管理"><a href="#JavaScript中的内存管理" class="headerlink" title="JavaScript中的内存管理"></a>JavaScript中的内存管理</h3><p>JavaScript是所谓的<em>垃圾收集语言</em>之一。垃圾收集语言通过定期检查哪些先前分配的内存仍然可以从应用程序的其他部分“达到”来帮助开发人员管理内存。换句话说，垃圾收集语言将管理内存的问题从“还需要什么内存？降低到“应用程序的其他部分仍然可以重新分配内存？”。差别是微妙的，但重要的是：虽然只有开发人员知道将来是否需要一块分配的内存，取不到的内存可以通过算法确定并标记为返回到操作系统。</p>
<blockquote>
<p>非垃圾收集语言通常使用其他技术来管理内存：显式管理，开发人员明确告诉编译器何时不需要一块内存; 和引用计数，其中使用计数与存储器的每个块相关联（当计数达到零时，其被返回到OS）。这些技术有自己的权衡（和潜在的泄漏原因）。</p>
</blockquote>
<h2 id="JavaScript中的内存溢出"><a href="#JavaScript中的内存溢出" class="headerlink" title="JavaScript中的内存溢出"></a>JavaScript中的内存溢出</h2><p>垃圾收集语言内存泄漏的主要原因是<em>不需要的引用</em>。要理解什么是不需要的引用，首先我们需要了解垃圾回收器如何确定是否可以到达一块内存。</p>
<blockquote>
<p><a href="https://twitter.com/intent/tweet?text=%22The%20main%20cause%20for%20leaks%20in%20garbage%20collected%20languages%20are%20unwanted%20references.%22%20via%20@auth0%20http://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/" target="_blank" rel="external">“垃圾收集语言泄漏的主要原因是不需要的引用。TWEET这个 <img src="https://cdn.auth0.com/blog/resources/twitter.svg" alt="img"></a></p>
</blockquote>
<h3 id="标记和扫描"><a href="#标记和扫描" class="headerlink" title="标记和扫描"></a>标记和扫描</h3><p>大多数垃圾收集器使用称为<em>标记和扫描</em>的算法。该算法由以下步骤组成：</p>
<ol>
<li>垃圾回收器构建“根”的列表。根通常是在代码中保存引用的全局变量。在JavaScript中，“window”对象是可以充当根的全局变量的示例。窗口对象总是存在，所以垃圾收集器可以考虑它和它的所有子对象总是存在（即不是垃圾）。</li>
<li>所有根被检查并标记为活动（即不是垃圾）。所有孩子也被递归检查。从根可以到达的一切都不被认为是垃圾。</li>
<li>所有未标记为活动的内存块现在可以被认为是垃圾。收集器现在可以释放该内存并将其返回到操作系统。</li>
</ol>
<p>现代垃圾收集器以不同的方式改进了该算法，但本质是相同的：可访问的内存段被标记为这样，其余被认为是垃圾。</p>
<p>不需要的引用是对开发者知道他或她将不再需要，但由于某种原因保存在活动根的树内部的存储器的引用。在JavaScript的上下文中，不需要的引用是保存在代码中某处的变量，它不再被使用，并指向可以被释放的一块内存。有些人会认为这些都是开发者的错误。</p>
<p>所以要了解哪些是JavaScript中最常见的内存泄漏，我们需要知道在哪些方式引用通常被遗忘。</p>
<h2 id="JavaScript内存泄漏的三种类型"><a href="#JavaScript内存泄漏的三种类型" class="headerlink" title="JavaScript内存泄漏的三种类型"></a>JavaScript内存泄漏的三种类型</h2><h3 id="1：意外全局变量"><a href="#1：意外全局变量" class="headerlink" title="1：意外全局变量"></a>1：意外全局变量</h3><p>JavaScript背后的目标之一是开发一种看起来像Java的语言，但是它允许足以被初学者使用。JavaScript允许的方式之一是处理未声明的变量：对未声明的变量的引用在<em>全局</em>对象内创建一个新的变量。在浏览器的情况下，全局对象是<code>window</code>。换一种说法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">    bar = <span class="string">"this is a hidden global variable"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">    <span class="built_in">window</span>.bar = <span class="string">"this is an explicit global variable"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>bar</code>应该在<code>foo</code>函数的范围内保存对变量的引用，并且您忘记使用<code>var</code>它来声明它，那么会创建一个意外的全局变量。在这个例子中，泄漏一个简单的字符串不会做很多伤害，但它肯定可能更糟。</p>
<p>可以创建偶然的全局变量的另一种方式是<code>this</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.variable = <span class="string">"potential accidental global"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Foo called on its own, this points to the global object (window)</span></div><div class="line"><span class="comment">// rather than being undefined.</span></div><div class="line">foo();</div></pre></td></tr></table></figure>
<blockquote>
<p>为了防止发生这些错误，请<code>&#39;use strict&#39;;</code>在JavaScript文件的开头添加。这使得可以更严格地解析JavaScript以防止意外全局变量。</p>
</blockquote>
<h4 id="关于全局变量的注释"><a href="#关于全局变量的注释" class="headerlink" title="关于全局变量的注释"></a>关于全局变量的注释</h4><p>即使我们谈论不可预测的全局变量，仍然是这样的情况，许多代码是与显式的全局变量。这些是根据定义不可收集的（除非被取消或重新分配）。特别地，用于临时存储和处理大量信息的全局变量是令人关注的。如果必须使用全局变量来存储大量数据，请确保将其置空或在完成后重新分配它。与全局变量有关的增加的内存消耗的一个常见原因是<a href="https://en.wikipedia.org/wiki/Cache_(computing" target="_blank" rel="external">高速缓存</a>）。缓存存储重复使用的数据。为了有效率，高速缓存必须具有其大小的上限。无限增长的缓存可能导致高内存消耗，因为无法收集其内容。</p>
<h3 id="2：被遗忘的计时器或回调"><a href="#2：被遗忘的计时器或回调" class="headerlink" title="2：被遗忘的计时器或回调"></a>2：被遗忘的计时器或回调</h3><p><code>setInterval</code>在JavaScript中使用是相当常见的。其他图书馆提供观察员和其他设施来接受回调。大多数这些库在自己的实例变得不可访问之后，负责使任何对回调的引用不可达。在setInterval的情况下，然而，像这样的代码是很常见的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> someResource = getData();</div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'Node'</span>);</div><div class="line">    <span class="keyword">if</span>(node) &#123;</div><div class="line">        <span class="comment">// Do stuff with node and someResource.</span></div><div class="line">        node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>此示例说明了可能发生的悬挂计时器：计时器，引用不再需要的节点或数据。由<code>node</code>未来表示的对象可能会被删除，使得区间处理程序内部的整个块不必要。但是，处理程序（因为时间间隔仍处于活动状态）无法收集（需要停止时间间隔才能发生这种情况）。如果无法收集间隔处理程序，则也无法收集其依赖项。这意味着，<code>someResource</code>不可能收集大概存储大小的数据。</p>
<p>对于观察者的情况，重要的是进行显式调用，以便在不再需要它们时删除它们（或者相关对象即将无法访问）。在过去，以前特别重要，因为某些浏览器（Internet Explorer 6）无法管理循环引用（参见下面的更多信息）。现在，大多数浏览器可以并将收集观察者处理程序，一旦观察到的对象变得不可达，即使没有明确删除侦听器。但是，在处理对象之前显式删除这些观察者仍然是良好的做法。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    element.innerHtml = <span class="string">'text'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">element.addEventListener(<span class="string">'click'</span>, onClick);</div><div class="line"><span class="comment">// Do stuff</span></div><div class="line">element.removeEventListener(<span class="string">'click'</span>, onClick);</div><div class="line">element.parentNode.removeChild(element);</div><div class="line"><span class="comment">// Now when element goes out of scope,</span></div><div class="line"><span class="comment">// both element and onClick will be collected even in old browsers that don't</span></div><div class="line"><span class="comment">// handle cycles well.</span></div></pre></td></tr></table></figure>
<h4 id="关于对象观察者和循环引用的注释"><a href="#关于对象观察者和循环引用的注释" class="headerlink" title="关于对象观察者和循环引用的注释"></a>关于对象观察者和循环引用的注释</h4><p>观察者和循环引用曾经是JavaScript开发者的祸根。这是由于Internet Explorer的垃圾回收器中的错误（或设计决策）。旧版本的Internet Explorer无法检测DOM节点和JavaScript代码之间的循环引用。这是典型的观察者，通常保持对可观察者的引用（如上例所示）。换句话说，每当观察者被添加到Internet Explorer中的一个节点时，它就会导致泄漏。这是开发人员在节点或在观察者内引用null引用之前显式删除处理程序的原因。现在，现代浏览器（包括Internet Explorer和Microsoft Edge）使用现代垃圾收集算法，可以检测这些周期并正确处理它们。换一种说法，<code>removeEventListener</code></p>
<p>框架和库（例如<em>jQuery）</em>在处理节点之前删除侦听器（当为其使用特定的API时）。这是由库内部处理，并确保不产生泄漏，即使在有问题的浏览器（如旧的Internet Explorer）下运行。</p>
<h3 id="3：超出DOM引用"><a href="#3：超出DOM引用" class="headerlink" title="3：超出DOM引用"></a>3：超出DOM引用</h3><p>有时，将DOM节点存储在数据结构中可能很有用。假设要快速更新表中多个行的内容。在字典或数组中存储对每个DOM行的引用可能是有意义的。当发生这种情况时，将保留对同一DOM元素的两个引用：一个在DOM树中，另一个在字典中。如果在将来的某个时候决定删除这些行，则需要使这两个引用不可访问。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elements = &#123;</div><div class="line">    button: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</div><div class="line">    image: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>),</div><div class="line">    text: <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    image.src = <span class="string">'http://some.url/image'</span>;</div><div class="line">    button.click();</div><div class="line">    <span class="built_in">console</span>.log(text.innerHTML);</div><div class="line">    <span class="comment">// Much more logic</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeButton</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// The button is a direct child of body.</span></div><div class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>));</div><div class="line"></div><div class="line">    <span class="comment">// At this point, we still have a reference to #button in the global</span></div><div class="line">    <span class="comment">// elements dictionary. In other words, the button element is still in</span></div><div class="line">    <span class="comment">// memory and cannot be collected by the GC.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对此的另外考虑与对DOM树内的内部或叶节点的引用有关。假设您<code>&lt;td&gt;</code>在JavaScript代码中保留对表（标签）的特定单元格的引用。在将来的某个时候，您决定从DOM中删除表，但保留对该单元格的引用。直观地，可以假定GC将收集除了该单元之外的所有东西。在实践中，这不会发生：单元格是该表的子节点，并且子级保持对其父级的引用。换句话说，从JavaScript代码对表单元格的引用导致整个表保留在内存中。在保持对DOM元素的引用时仔细考虑这一点。</p>
<h3 id="4：关闭"><a href="#4：关闭" class="headerlink" title="4：关闭"></a>4：关闭</h3><p>JavaScript开发的一个关键方面是闭包：从父作用域捕获变量的匿名函数。Meteor开发人员<a href="http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak" target="_blank" rel="external">发现了一种特殊情况</a>，由于JavaScript运行时的实现细节，可能以微妙的方式泄漏内存：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> originalThing = theThing;</div><div class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (originalThing)</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</div><div class="line">  &#125;;</div><div class="line">  theThing = &#123;</div><div class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</div><div class="line">    someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(someMessage);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line">setInterval(replaceThing, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>这个片段做了一件事：每次<code>replaceThing</code>调用，<code>theThing</code>获取一个包含大数组和一个新的闭包（<code>someMethod</code>）的新对象。同时，变量<code>unused</code>保存有一个引用<code>originalThing</code>（<code>theThing</code>从上一次调用<code>replaceThing</code>）的闭包。已经有点混乱了，是吗？重要的是，一旦为同一父作用域中的闭包创建了作用域，则该作用域是共享的。在这种情况下，为闭包创建的作用域由<code>someMethod</code>共享<code>unused</code>。<code>unused</code>有引用<code>originalThing</code>。即使<code>unused</code>从未使用，<code>someMethod</code>可以通过使用<code>theThing</code>。并且<code>someMethod</code>与封闭范围共享<code>unused</code>，即使<code>unused</code>从未使用，<code>originalThing</code>其引用强制其保持活动（防止其收集）。当此代码段重复运行时，可以观察到内存使用量的稳定增加。这在GC运行时不会变小。实质上，创建了闭包的链接列表（其根以<code>theThing</code>变量的形式），并且这些闭包的范围中的每一个都对大数组进行间接引用，导致相当大的泄漏。</p>
<blockquote>
<p>这是一个实现工件。可以处理这种情况的闭包的不同实现是可能的，如<a href="http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak" target="_blank" rel="external">Meteor博客文章中所解释的</a>。</p>
</blockquote>
<h2 id="垃圾收集者的不直观行为"><a href="#垃圾收集者的不直观行为" class="headerlink" title="垃圾收集者的不直观行为"></a>垃圾收集者的不直观行为</h2><p>虽然垃圾收集器很方便，他们有自己的一套权衡。这些权衡之一<em>是非确定性</em>。换句话说，GC是不可预测的。通常不可能确定何时执行收集。这意味着在某些情况下，正在使用比程序实际需要的更多的内存。在其他情况下，短暂停顿在特别敏感的应用中可能是明显的。虽然非确定性意味着无法确定何时执行集合，但大多数GC实现都在分配期间共享执行集合传递的常见模式。如果没有执行分配，则大多数GC保持静止。考虑以下情况：</p>
<ol>
<li>执行相当大的一组分配。</li>
<li>大多数这些元素（或所有这些元素）被标记为不可达（假设我们将指向我们不再需要的缓存的引用置空）。</li>
<li>不执行进一步的分配。</li>
</ol>
<p>在这种情况下，大多数GC将不会运行任何进一步的集合过程。换句话说，即使有不可达的引用可用于收集，收集器也不要求这些引用。这些不是严格的泄漏，但仍然导致高于通常的内存使用。</p>
<p>Google在他们的<a href="https://developer.chrome.com/devtools/docs/demos/memory/example2" target="_blank" rel="external">JavaScript内存分析文档中</a>提供了这种行为的一个很好的例子<a href="https://developer.chrome.com/devtools/docs/demos/memory/example2" target="_blank" rel="external">，示例＃2</a>。</p>
<h2 id="Chrome内存分析工具概述"><a href="#Chrome内存分析工具概述" class="headerlink" title="Chrome内存分析工具概述"></a>Chrome内存分析工具概述</h2><p>Chrome提供了一组很好的工具来分析JavaScript代码的内存使用情况。有两个与内存相关的基本视图：<em>时间轴</em>视图和<em>配置文件</em>视图。</p>
<h3 id="时间轴视图"><a href="#时间轴视图" class="headerlink" title="时间轴视图"></a>时间轴视图</h3><p><img src="https://cdn.auth0.com/blog/jsleaks/timeline.png" alt="Google开发工具时间表行动">时间轴视图对于在代码中发现异常内存模式至关重要。如果我们正在寻找大的泄漏，周期性的跳跃，不收缩，因为收集后他们长大了是一个红旗。在这个截图中，我们可以看到泄漏对象的稳定增长可能是什么样子。即使在大收集结束后，使用的内存总量高于开始时。节点计数也较高。这些都是代码中某处泄漏的DOM节点的迹象。</p>
<h3 id="配置文件视图"><a href="#配置文件视图" class="headerlink" title="配置文件视图"></a>配置文件视图</h3><p><img src="https://cdn.auth0.com/blog/jsleaks/profiles.png" alt="Google开发工具配置文件">这是你将花费大部分时间看的视图。配置文件视图允许您获取快照并比较JavaScript代码的内存使用快照。它还允许您记录分配的时间。在每个结果视图中，可以使用不同类型的列表，但对于我们的任务最相关的是摘要列表和比较列表。</p>
<p>摘要视图为我们概述了分配的不同类型的对象及其聚合大小：浅大小（特定类型的所有对象的总和）和保留大小（浅大小加上由于此对象保留的其他对象的大小）。它也给了我们一个对象相对于它的GC根（距离）有多远的概念。</p>
<p>比较列表给了我们相同的信息，但允许我们比较不同的快照。这是特别有用的找到泄漏。</p>
<h2 id="示例：使用Chrome查找泄漏"><a href="#示例：使用Chrome查找泄漏" class="headerlink" title="示例：使用Chrome查找泄漏"></a>示例：使用Chrome查找泄漏</h2><p>基本上有两种类型的泄漏：泄漏导致内存使用的周期性增加，以及一次发生的泄漏，并且不会进一步增加内存。由于显而易见的原因，当它们是周期性的时更容易发现泄漏。这些也是最麻烦的：如果内存在时间上增加，这种类型的泄漏将最终导致浏览器变慢或停止脚本的执行。非周期性泄漏可以很容易地发现，当它们足够大，在所有其他分配中显着。这通常不是这样，所以他们通常保持不被注意。在某种程度上，发生一次的小泄漏可以被认为是优化问题。然而，周期性的泄漏是错误并且必须是固定的。</p>
<p>对于我们的示例，我们将使用<a href="https://developer.chrome.com/devtools/docs/demos/memory/example1" target="_blank" rel="external">Chrome的文档中的</a>一个<a href="https://developer.chrome.com/devtools/docs/demos/memory/example1" target="_blank" rel="external">示例</a>。完整代码粘贴如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = [];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSomeNodes</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> div,</div><div class="line">        i = <span class="number">100</span>,</div><div class="line">        frag = <span class="built_in">document</span>.createDocumentFragment();</div><div class="line">    <span class="keyword">for</span> (;i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">        div.appendChild(<span class="built_in">document</span>.createTextNode(i + <span class="string">" - "</span>+ <span class="keyword">new</span> <span class="built_in">Date</span>().toTimeString()));</div><div class="line">        frag.appendChild(div);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"nodes"</span>).appendChild(frag);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">grow</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    x.push(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'x'</span>));</div><div class="line">    createSomeNodes();</div><div class="line">    setTimeout(grow,<span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当<code>grow</code>被调用时，它将开始创建div节点并将它们附加到DOM。它还将分配一个大数组，并将其附加到全局变量引用的数组。这将导致使用上述工具可以找到的内存的稳定增加。</p>
<blockquote>
<p>垃圾收集的语言通常显示振荡存储器使用的模式。如果代码在执行分配的循环中运行，这是预期的，这是通常的情况。我们将寻找在收集后不会回退到之前级别的内存的定期增加。</p>
</blockquote>
<h3 id="了解内存是否周期性增加"><a href="#了解内存是否周期性增加" class="headerlink" title="了解内存是否周期性增加"></a>了解内存是否周期性增加</h3><p>时间表视图是伟大的。在Chrome中打开<a href="https://developer.chrome.com/devtools/docs/demos/memory/example1" target="_blank" rel="external">示例</a>，打开开发工具，转到<em>时间轴</em>，选择<em>内存</em>并单击记录按钮。然后转到该页面并单击<code>The Button</code>以开始泄漏内存。过一会儿停止录音，看看结果：</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-timeline.png" alt="时间轴视图中的内存泄漏"></p>
<blockquote>
<p>此示例将继续每秒泄漏内存。停止录制后，请在<code>grow</code>函数中设置断点，以停止脚本强制Chrome关闭页面。</p>
</blockquote>
<p>在这个图像有两个大的迹象，显示我们正在泄漏的记忆。<em>节点</em>（绿线）和<em>JS堆</em>（蓝线）的图形。节点正在稳步增加，从不减少。这是一个大的警告标志。</p>
<p>JS堆还显示内存使用的稳定增长。这是很难看到由于垃圾回收器的影响。您可以看到初始内存增长的模式，随后是大幅下降，随后是增加，然后是峰值，继续记忆的下降。在这种情况下的关键在于事实，在每次内存使用后，堆的大小保持大于在上一次下降。换句话说，尽管垃圾收集器正在成功地收集大量的存储器，但是它的一些被周期性地泄漏。</p>
<p>我们现在确定我们有一个泄漏。让我们找到它。</p>
<h3 id="获取两个快照"><a href="#获取两个快照" class="headerlink" title="获取两个快照"></a>获取两个快照</h3><p>要查找泄漏，我们现在将转到Chrome的开发工具的<em>profiles</em>部分。要将内存使用限制在可管理的级别，请在执行此步骤之前重新加载页面。我们将使用<em>Take Heap Snapshot</em>函数。</p>
<p>重新加载页面，并在完成加载后立即获取堆快照。我们将使用此快照作为我们的基线。之后，<code>The Button</code>再次点击，等待几秒钟，并拍摄第二个快照。捕获快照后，建议在脚本中设置断点，以防止泄漏使用更多内存。</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-snapshots-1.png" alt="堆快照"></p>
<p>有两种方法可以查看两个快照之间的分配。选择<em>摘要</em>，然后选择右侧选择<em>在快照1和快照2之间分配的对象</em>，或选择<em>比较</em>而不是<em>摘要</em>。在这两种情况下，我们将看到在两个快照之间分配的对象的列表。</p>
<p>在这种情况下，很容易找到泄漏：他们很大。看看的<code>Size Delta</code>的的<code>(string)</code>构造函数。8MBs有58个新对象。这看起来很可疑：新对象被分配但是不被释放，并且8MB被消耗。</p>
<p>如果我们打开构造函数的<code>(string)</code>分配列表，我们会注意到在许多小的分配中有一些大的分配。大者立即引起我们的注意。如果我们选择其中的任何一个，我们在下面的<em>retainers</em>部分得到一些有趣的<em>东西</em>。</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-snapshots-2.png" alt="所选对象的保留位置"></p>
<p>我们看到我们选择的分配是数组的一部分。反过来，数组由<code>x</code>全局<code>window</code>对象内的变量引用。这给了我们从我们的大对象到其不可收回的根（<code>window</code>）的完整路径。我们发现我们的潜在泄漏和被引用的地方。</p>
<p>到现在为止还挺好。但我们的例子很容易：大分配，例如在这个例子中的分配不是常态。幸运的是，我们的例子也泄漏了DOM节点，它们更小。使用上面的快照很容易找到这些节点，但是在更大的网站中，事情变得更麻烦。最新版本的Chrome提供了一个最适合我们工作的附加工具：<em>记录堆分配</em>功能。</p>
<h3 id="记录堆分配以查找泄漏"><a href="#记录堆分配以查找泄漏" class="headerlink" title="记录堆分配以查找泄漏"></a>记录堆分配以查找泄漏</h3><p>禁用之前设置的断点，让脚本继续运行，然后返回Chrome的开发工具的“ <em>个人档案”</em>部分。现在点击<em>Record Heap Allocations</em>。当工具运行时，您会注意到在顶部的图中的蓝色尖峰。这些表示分配。每秒大的分配由我们的代码执行。让它运行几秒钟，然后停止它（不要忘记再次设置断点，以防止Chrome吃更多的内存）。</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-recordedallocs-overview.png" alt="记录的堆分配"></p>
<p>在此图像中，您可以看到此工具的杀手级功能：选择一段时间线以查看在该时间段内执行的分配。我们将选择设置为尽可能接近一个大峰值。列表中只显示了三个构造函数：其中一个是与我们的大泄漏（<code>(string)</code>）相关的，另一个是与DOM分配相关的，最后一个是<code>Text</code>构造函数（包含文本的叶DOM节点的构造函数）。</p>
<p><code>HTMLDivElement</code>从列表中选择一个构造函数，然后选择<code>Allocation stack</code>。</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-recordedallocs-selected.png" alt="堆分配结果中选择的元素"></p>
<p>BAM！我们现在知道该元素的分配位置（<code>grow</code>- &gt; <code>createSomeNodes</code>）。如果我们密切关注图中每个秒杀，我们会发现，<code>HTMLDivElement</code>构造函数被调用了很多。如果我们回到我们快照比较认为我们会发现，这个构造显示有多少拨款，但没有删除。换句话说，它是稳定，而不允许在GC收回一些它分配内存。这有泄漏的种种迹象加上我们确切地知道被分配这些对象（<code>createSomeNodes</code>函数）。现在它的时间回到代码，研究它，并修复内存泄漏。</p>
<h3 id="另一个有用的功能"><a href="#另一个有用的功能" class="headerlink" title="另一个有用的功能"></a>另一个有用的功能</h3><p>在堆分配结果视图中，我们可以选择<em>Allocation</em>视图而不是<em>Summary</em>。</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-recordedallocs-list.png" alt="结果是堆分配中的分配"></p>
<p>这个视图给了我们一个与它们相关的函数和内存分配的列表。我们可以立即看到<code>grow</code>和<code>createSomeNodes</code>站出来。当选择时，<code>grow</code>我们看看它所调用的关联对象构造函数。我们注意到<code>(string)</code>，<code>HTMLDivElement</code>和<code>Text</code>它现在我们已经知道是被泄露的对象的构造函数。</p>
<p>这些工具的组合可以大大有助于发现泄漏。玩他们。在生产站点中进行不同的分析运行（理想情况下使用非最小化或混淆代码）。看看你能找到的泄漏或对象被保留超过他们应该（提示：这些更难找到）。</p>
<blockquote>
<p>要使用此功能，请转到Dev Tools - &gt;设置并启用“记录堆分配堆栈跟踪”。在拍摄之前必须这样做。</p>
</blockquote>
<h2 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management" target="_blank" rel="external">内存管理 - Mozilla开发人员网络</a></li>
<li><a href="http://javascript.crockford.com/memory/leak.html" target="_blank" rel="external">JScript内存泄漏 - Douglas Crockford（旧的，关于Internet Explorer 6泄漏）</a></li>
<li><a href="https://developer.chrome.com/devtools/docs/javascript-memory-profiling" target="_blank" rel="external">JavaScript内存分析 - Chrome开发者文档</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/memory-diagnosis" target="_blank" rel="external">内存诊断 - Google Developers</a></li>
<li><a href="http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak" target="_blank" rel="external">有趣的JavaScript内存泄漏 - 流星博客</a></li>
<li><a href="http://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html" target="_blank" rel="external">Grokking V8关闭</a></li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>内存泄漏可以并且确实发生在垃圾收集语言中，如JavaScript。这些可以被忽视一段时间，最终他们将肆虐。因此，内存分析工具对于查找内存泄漏至关重要。分析运行应该是开发周期的一部分，特别是对于中型或大型应用程序。开始这样做，为您的用户提供最好的体验。Hack on！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/Node.js权限控制管理模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/Node.js权限控制管理模块/" itemprop="url">
                  Node.js权限控制管理模块
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T11:15:54+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <script src="https://gist.github.com/facultymatt/6370903.js"></script>

<p><a href="https://github.com/tenodi/permission" target="_blank" rel="external">https://github.com/tenodi/permission</a> Npm package for hangling user permissions for routes based on roles. </p>
<p><a href="https://github.com/kieronwiltshire/letu" target="_blank" rel="external">https://github.com/kieronwiltshire/letu</a>  Simple permission evaluation. </p>
<blockquote>
<p>current popularity rank (based on npmjs.com dowloads count)</p>
<ol>
<li>acl</li>
<li>connect-roles</li>
<li>authorized</li>
<li>virgen-acl</li>
<li>permission</li>
<li>ability</li>
<li>ability</li>
<li>simplepermissions</li>
<li>entitlement</li>
</ol>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/项目中用到的用户权限管理系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/项目中用到的用户权限管理系统/" itemprop="url">
                  项目中用到的用户权限管理系统
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T10:41:27+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>权限管理是每个系统中用户管理必需的管理组件，通常需要通过判断用户所具有的权限来控制用户对系统的操作内容，并把资源调配给用户，限制用户的增删改查等操作。</p>
<p>通常权限管理的访问控制模型有以下两种方式：</p>
<p><a href="https://en.wikipedia.org/wiki/Access_control_list" target="_blank" rel="external">ACL</a>：Access Control List，访问控制列表（节点控制），是比较流行的设计方式。通过把用户和权限挂钩来实现。</p>
<p> <a href="https://en.wikipedia.org/wiki/Role-based_access_control" target="_blank" rel="external">RBAC</a>：Role Based Access Control，基于的角色访问控制系统，是另一个实现思路。、就是把用户和角色关联，角色来对应权限，用户和权限没有直接关联，对复杂的系统来说，更加容易管理。</p>
<h3 id="RBAC物理模型"><a href="#RBAC物理模型" class="headerlink" title="RBAC物理模型"></a>RBAC物理模型</h3><p><a href="http://dl.iteye.com/upload/attachment/425543/d2573c4d-dca7-380f-b2fc-6cda19d6eaf5.jpg" target="_blank" rel="external"><img src="http://dl.iteye.com/upload/attachment/425543/d2573c4d-dca7-380f-b2fc-6cda19d6eaf5.jpg" alt="img"></a></p>
<p>当用户的数量非常大时，要给系统每个用户逐一授权（授角色），是件非常烦琐的事情。这时，就需要给用户分组，每个用户组内有多个用户。除了可给用户授权外，还可以给用户组授权。这样一来，用户拥有的所有权限，就是用户个人拥有的权限与该用户所在用户组拥有的权限之和。（下图为用户组、用户与角色三者的关联关系）</p>
<p><img src="http://dl.iteye.com/upload/attachment/425558/90bf9805-c29d-3199-a905-c6ddc7fd4e81.jpg" alt="img"></p>
<p>​                                    “用户-角色-权限-资源” 授权模型</p>
<p><img src="http://dl.iteye.com/upload/attachment/425567/53bc63c4-52e6-3c6f-91d8-7e23a9aefe4a.jpg" alt="img"></p>
<p><img src="http://dl.iteye.com/upload/attachment/425569/c07d99bc-e19d-302d-8dea-dc98309bf919.jpg" alt="点击查看原始大小图片"></p>
<p><img src="http://img.blog.csdn.net/20140118135544281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNoOTE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="http://img.blog.csdn.net/20140118135551234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNoOTE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="http://img.blog.csdn.net/20140118135834234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNoOTE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h3 id="ACL实体模型"><a href="#ACL实体模型" class="headerlink" title="ACL实体模型"></a>ACL实体模型</h3><p><img src="http://img.blog.csdn.net/20140118135348656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNoOTE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>通过ACL（访问控制列表）把Role、User、Module、Permission、status（允许/禁止）关联起来。用于记录用户或者角色对资源拥有的权限</p>
<p><img src="http://img.blog.csdn.net/20140118135356750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNoOTE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<blockquote>
<p><em>内容来源网络整理而成</em> </p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/JavaScript中的内存释放/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/JavaScript中的内存释放/" itemprop="url">
                  JavaScript中的内存释放
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-10T22:29:12+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><em>内容来自网络 <a href="http://www.jianshu.com/p/3b7946c4b118" target="_blank" rel="external">http://www.jianshu.com/p/3b7946c4b118</a></em></p>
</blockquote>
<h2 id="一、如何查找当前作用域的上级作用域"><a href="#一、如何查找当前作用域的上级作用域" class="headerlink" title="一、如何查找当前作用域的上级作用域"></a>一、如何查找当前作用域的上级作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> num = <span class="number">20</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> num = <span class="number">200</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(num);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> f = fn();</div><div class="line">f(); <span class="comment">// 输出 200</span></div></pre></td></tr></table></figure>
<p>以上代码fn中返回了一个函数，用f去接收这个返回的函数，然后再执行f()，最后输出的是200，刚接触的同学可能会有疑问，为什么在全局作用域下执行的f()输出的num不是全局作用域中的20，而是fn函数的私有作用域中的200！</p>
<p><strong>上级作用域查找规则：看当前函数是在哪个作用域下定义的，那么它的上级作用域就是谁，和函数哪里执行没有任何的关系。</strong></p>
<p>以上的代码在全局的变量和函数进行预解析之后，执行fn函数，fn函数又进行预解析形成自己的私有作用域，然后执行fn函数中的代码，最后返回一个函数，该函数被f接收。当f执行的时候，有一行代码输出num：<code>console.log(num)</code>，根据作用域搜索规则，首先在自己的作用域中找，没有找到，然后再到上级的作用域中查找，根据作用域查找的规则，<strong>只看当前函数在哪个作用域下定义的</strong>，所以f函数的上级作用域是fn。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2555024-a0df1d45fa0feb95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>​                                    如何查找上级作用域.png</p>
<p>有了以上的基础之后，再看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> num = <span class="number">20</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> num = <span class="number">200</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(num);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> f = fn();</div><div class="line">f(); <span class="comment">// 输出 200</span></div><div class="line"></div><div class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">2000</span>;</div><div class="line">    f(); <span class="comment">// 输出什么呢？</span></div><div class="line">&#125;();</div><div class="line"><span class="comment">// 等价于</span></div><div class="line">~(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> num = <span class="number">2000</span></div><div class="line">  f()</div><div class="line">&#125;())</div></pre></td></tr></table></figure>
<p>加上了一个自执行函数，我们知道自执行函数是有自己的作用域的，但是此时f函数执行，依然输出200。 要时刻记住上级作用域的查找规则：<strong>只看当前函数在哪个作用域下定义的</strong>。</p>
<p>这时候很多同学可能会疑惑了，我们不是讲解JavaScript的内存释放的嘛？怎么还讲起了作用域的内容，稍安勿躁…在JavaScript的内存释放中要用到这些知识呢！</p>
<h2 id="二、堆内存的释放"><a href="#二、堆内存的释放" class="headerlink" title="二、堆内存的释放"></a>二、堆内存的释放</h2><p>对象数据类型或者函数类型在定义的时候，首先都会开辟一个堆内存，堆内存有一个引用地址，如果外面有引用这个地址，我们就说这个内存被占用了，就不能销毁了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;name:<span class="string">"iceamn"</span>&#125;;</div><div class="line"><span class="keyword">var</span> obj2 = obj1;</div></pre></td></tr></table></figure>
<p>​    <img src="http://upload-images.jianshu.io/upload_images/2555024-5de991df187d2654.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img">        </p>
<p>​                                        堆内存.png</p>
<p>如果想要让堆内存释放（销毁），只需要把所有引用它的变量赋值为null即可，如果当前的堆内存没有任何东西被占用了，那么浏览器会在空闲的时候把它销毁。也就是说，在上面的那种感觉情况下，只有把obj1和同obj2都置为null之后，0xff11这块对堆内存才会被释放，只要还有变量引用0xff11这块内存，它就不会释放。</p>
<h2 id="三、栈内存的释放"><a href="#三、栈内存的释放" class="headerlink" title="三、栈内存的释放"></a>三、栈内存的释放</h2><h4 id="3-1、全局作用域"><a href="#3-1、全局作用域" class="headerlink" title="3.1、全局作用域"></a>3.1、全局作用域</h4><p>在全局作用域下，只有当页面关闭的时候，全局作用域才会被销毁。</p>
<h4 id="3-2、私有作用域"><a href="#3-2、私有作用域" class="headerlink" title="3.2、私有作用域"></a>3.2、私有作用域</h4><p>一般情况下，函数执行会形成一个新的私有作用域（在ES6之前只有函数执行才会产生私有作用域），当私有作用域中的代码执行完成后，当前作用域都会主动的进行释放和销毁。</p>
<p>不过依然有特殊的情况存在：当前私有作用域中的部分内容被作用域以外的东西占用了，那么当前作用域就不能销毁了。</p>
<h5 id="3-2-1、-函数返回了一个引用数据类型的值（数组、函数…），并且该引用类型的值在函数的外面被一个其他变量接收了，这种情况下形成的私有作用域都不会销毁。"><a href="#3-2-1、-函数返回了一个引用数据类型的值（数组、函数…），并且该引用类型的值在函数的外面被一个其他变量接收了，这种情况下形成的私有作用域都不会销毁。" class="headerlink" title="3.2.1、 函数返回了一个引用数据类型的值（数组、函数…），并且该引用类型的值在函数的外面被一个其他变量接收了，这种情况下形成的私有作用域都不会销毁。"></a>3.2.1、 函数返回了一个<strong>引用数据类型的值（数组、函数…）</strong>，并且<strong>该引用类型的值在函数的外面被一个其他变量接收了</strong>，这种情况下形成的私有作用域都不会销毁。</h5><p>注意两个条件：<br>（1）函数返回引用数据类型的值；<br>（2）该引用类型的值在函数外面被一个其他变量接收了；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">100</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        num ++;</div><div class="line">        <span class="built_in">console</span>.log(num);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f = fn(); <span class="comment">// fn执行形成的作用域就不能再销毁了</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong>：即使fn返回的函数中什么代码都没有，没有使用到fn私有作用域中的任何变量和函数，在以上情况下，fn的私有作用域也不会被销毁，即：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">100</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f = fn();</div></pre></td></tr></table></figure>
<h5 id="3-2-2、-在一个私有作用域中，给DOM元素绑定方法，私有作用域不能被销毁"><a href="#3-2-2、-在一个私有作用域中，给DOM元素绑定方法，私有作用域不能被销毁" class="headerlink" title="3.2.2、 在一个私有作用域中，给DOM元素绑定方法，私有作用域不能被销毁"></a>3.2.2、 在一个私有作用域中，给DOM元素绑定方法，私有作用域不能被销毁</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn1'</span>);</div><div class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>在自执行函数中形成了一个私有的作用域，在这个私有作用域中为页面上的一个button元素绑定了点击事件，所以这个私有作用域也不能被销毁。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2555024-20fce3c4fbf5aac0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>​                                    自执行函数的情况.png</p>
<h5 id="3-2-3、-“不立即销毁”"><a href="#3-2-3、-“不立即销毁”" class="headerlink" title="3.2.3、 “不立即销毁”"></a>3.2.3、 “不立即销毁”</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">100</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">fn()(); <span class="comment">// 首先执行fn，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再执行</span></div></pre></td></tr></table></figure>
<p>以上代码就是“不立即销毁”的情况，fn返回的函数没有被其他的任何变量占用，但是还需要执行一次，所以暂时不能销毁，但返回的值执行完成后，浏览器会在空闲的时候把它销毁了。</p>
<p>还记得一开始介绍的上级作用域吗，我们再对那张图进行分析：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2555024-040545d454116ba1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>​                                    上级作用域的情况.png</p>
<p>只要某作用域还有被引用，那么该作用域就不能被销毁，一旦没有任何变量引用了，该私有作用域就会被销毁了。</p>
<h2 id="四、练习题"><a href="#四、练习题" class="headerlink" title="四、练习题"></a>四、练习题</h2><hr>
<ul>
<li><p>第一题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> i = <span class="number">10</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(n + (++i));</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f = fn();</div><div class="line">f(<span class="number">10</span>); <span class="comment">// 21</span></div><div class="line">f(<span class="number">20</span>); <span class="comment">// 32</span></div><div class="line">fn()(<span class="number">10</span>); <span class="comment">// 21</span></div><div class="line">fn()(<span class="number">20</span>); <span class="comment">// 31</span></div></pre></td></tr></table></figure>
</li>
<li><p>第二题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">          <span class="built_in">console</span>.log(n + i++);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> f = fn(<span class="number">13</span>);</div><div class="line">  f(<span class="number">12</span>);<span class="comment">//-&gt;25</span></div><div class="line">  f(<span class="number">14</span>);<span class="comment">//-&gt;28</span></div><div class="line">  fn(<span class="number">15</span>)(<span class="number">12</span>);<span class="comment">//-&gt;27</span></div><div class="line">  fn(<span class="number">16</span>)(<span class="number">13</span>);<span class="comment">//-&gt;29</span></div></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/75道程序员面试逻辑思维题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/75道程序员面试逻辑思维题/" itemprop="url">
                  75道程序员面试逻辑思维题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-09T22:11:53+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>【1】假设有一个池塘，里面有无穷多的水。现有2个空水壶，容积分别为5升和6升。问题是如何只用这2个水壶从池塘里取得3升的水。<br>【2】周雯的妈妈是豫林水泥厂的化验员。 一天，周雯来到化验室做作业。做完后想出去玩。 “等等，妈妈还要考你一个题目，”她接着说，”你看这6只做化验用的玻璃杯，前面3只盛满了水，后面3只是空的。你能只移动1只玻璃杯，就便盛满水的杯子和空杯子间隔起来 吗?” 爱动脑筋的周雯，是学校里有名的”小机灵”，她只想了一会儿就做到了。请你想想看，”小机灵”是怎样做的?<br>【3】三个小伙子同时爱上了一个姑娘，为了决定他们谁能娶这个姑娘，他们决定用手枪进行一次决斗。小李的命中率是30％，小黄比他好些，命中率是50％，最出色的枪手是小林，他从不失误，命中率是100％。由于这个显而易见的事实，为公平起见，他们决定按这样的顺序：小李先开枪，小黄第二，小林最后。然后这样循环，直到他们只剩下一个人。那么这三个人中谁活下来的机会最大呢？他们都应该采取什么样的策略？</p>
<p>【4】一间囚房里关押着两个犯人。每天监狱都会为这间囚房提供一罐汤，让这两个犯人自己来分。起初，这两个人经常会发生争执，因为他们总是有人认为对方的汤比自己的多。后来他们找到了一个两全其美的办法：一个人分汤，让另一个人先选。于是争端就这么解决了。可是，现在这间囚房里又加进来一个新犯人，现在是三个人来分汤。必须寻找一个新的方法来维持他们之间的和平。该怎么办呢？<br>按：心理问题，不是逻辑问题<br>【5】在一张长方形的桌面上放了n个一样大小的圆形硬币。这些硬币中可能有一些不完全在桌面内，也可能有一些彼此重叠；当再多放一个硬币而它的圆心在桌面内时，新放的硬币便必定与原先某些硬币重叠。请证明整个桌面可以用4n个硬币完全覆盖<br>【6】一个球、一把长度大约是球的直径2/3长度的直尺.你怎样测出球的半径？方法很多，看看谁的比较巧妙<br>【7】五个大小相同的一元人民币硬币。要求两两相接触，应该怎么摆？</p>
<p>【8】猜牌问题<br>S 先生、P先生、Q先生他们知道桌子的抽屉里有16张扑克牌：红桃A、Q、4 黑桃J、8、4、2、7、3 草花K、Q、5、4、6 方块A、5。约翰教授从这16张牌中挑出一张牌来，并把这张牌的点数告诉 P先生，把这张牌的花色告诉Q先生。这时，约翰教授问P先生和Q 先生：你们能从已知的点数或花色中推知这张牌是什么牌吗？ 于是，S先生听到如下的对话：P先生：我不知道这张牌。<br>Q先生：我知道你不知道这张牌。<br>P先生：现在我知道这张牌了。<br>Q先生：我也知道了。<br>听罢以上的对话，S先生想了一想之后，就正确地推出这张牌是什么牌。<br>请问：这张牌是什么牌？<br>【9】一个教授逻辑学的教授，有三个学生，而且三个学生均非常聪明！<br>一天教授给他们出了一个题，教授在每个人脑门上贴了一张纸条并告诉他们，每个人的纸条上都写了一个正整数，且某两个数的和等于第三个！（每个人可以看见另两个数，但看不见自己的）<br>教授问第一个学生：你能猜出自己的数吗？回答：不能，问第二个，不能，第三个，不能，再问第一个，不能，第二个，不能，第三个：我猜出来了，是144！教授很满意的笑了。请问您能猜出另外两个人的数吗？<br>【10】某城市发生了一起汽车撞人逃跑事件<br>该城市只有两种颜色的车,蓝色15% 绿色85%<br>事发时有一个人在现场看见了<br>他指证是蓝车<br>但是根据专家在现场分析,当时那种条件能看正确的可能性是80%<br>那么,肇事的车是蓝车的概率到底是多少?<br>【11】有一人有240公斤水，他想运往干旱地区赚钱。他每次最多携带60公斤，并且每前进一公里须耗水1公斤（均匀耗水）。假设水的价格在出发地为0，以后，与运输路程成正比，（即在10公里处为10元/公斤，在20公里处为20元/公斤……），又假设他必须安全返回，请问，他最多可赚多少钱？<br>【12】现在共有100匹马跟100块石头，马分3种，大型马；中型马跟小型马。其中一匹大马一次可以驮3块石头，中型马可以驮2块，而小型马2头可以驮一块石头。问需要多少匹大马，中型马跟小型马？（问题的关键是刚好必须是用完100匹马）<br>【13】1=5 2=15 3=215 4=2145 那么5=?<br>【14】有2n个人排队进电影院，票价是50美分。在这2n个人当中，其中n个人只有50美分，另外n个人有1美元（纸票子）。愚蠢的电影院开始卖票时1分钱也没有。<br>问： 有多少种排队方法 使得 每当一个拥有1美元买票时，电影院都有50美分找钱<br>注：<br>1美元=100美分<br>拥有1美元的人，拥有的是纸币，没法破成2个50美分<br>【15】一个人花8块钱买了一只鸡，9块钱卖掉了，然后他觉得不划算，花10块钱又买回来了，11块卖给另外一个人。问他赚了多少?<br>【16】有一种体育竞赛共含M个项目，有运动员A，B，C参加，在每一项目中，第一,第二,第三名分别的X，Y，Z分，其中X,Y,Z为正整数且X&gt;Y&gt;Z。最后A得22分，B与C均得9分，B在百米赛中取得第一。求M的值，并问在跳高中谁得第二名。</p>
<p>【17】前提：<br>1 有五栋五种颜色的房子<br>2 每一位房子的主人国籍都不同<br>3 这五个人每人只喝一种饮料，只抽一种牌子的香烟，只养一种宠物<br>4 没有人有相同的宠物，抽相同牌子的香烟，喝相同的饮料<br>提示：<br>１ 英国人住在红房子里<br>２ 瑞典人养了一条狗<br>３ 丹麦人喝茶<br>４ 绿房子在白房子左边<br>５ 绿房子主人喝咖啡<br>６ 抽ＰＡＬＬＭＡＬＬ烟的人养了一只鸟<br>７ 黄房子主人抽ＤＵＮＨＩＬＬ烟<br>８ 住在中间那间房子的人喝牛奶<br>９ 挪威人住第一间房子<br>１０抽混合烟的人住在养猫人的旁边<br>１１养马人住在抽ＤＵＮＨＩＬＬ烟的人旁边<br>１２抽ＢＬＵＥＭＡＳＴＥＲ烟的人喝啤酒<br>１３德国人抽ＰＲＩＮＣＥ烟<br>１４挪威人住在蓝房子旁边<br>１５抽混合烟的人的邻居喝矿泉水<br>问题是：谁养鱼？？？<br>【18】5个人来自不同地方，住不同房子，养不同动物，吸不同牌子香烟，喝不同饮料，喜欢不同食物。根据以下线索确定谁是养猫的人。<br>1． 红房子在蓝房子的右边，白房子的左边（不一定紧邻）<br>2． 黄房子的主人来自香港，而且他的房子不在最左边。<br>3． 爱吃比萨的人住在爱喝矿泉水的人的隔壁。<br>4． 来自北京的人爱喝茅台，住在来自上海的人的隔壁。<br>5． 吸希尔顿香烟的人住在养马人的右边隔壁。<br>6． 爱喝啤酒的人也爱吃鸡。<br>7． 绿房子的人养狗。<br>8． 爱吃面条的人住在养蛇人的隔壁。<br>9． 来自天津的人的邻居（紧邻）一个爱吃牛肉，另一个来自成都。<br>10．养鱼的人住在最右边的房子里。<br>11．吸万宝路香烟的人住在吸希尔顿香烟的人和吸“555”香烟的人的中间（紧邻）<br>12．红房子的人爱喝茶。<br>13．爱喝葡萄酒的人住在爱吃豆腐的人的右边隔壁。<br>14．吸红塔山香烟的人既不住在吸健牌香烟的人的隔壁，也不与来自上海的人相邻。<br>15．来自上海的人住在左数第二间房子里。<br>16．爱喝矿泉水的人住在最中间的房子里。<br>17．爱吃面条的人也爱喝葡萄酒。<br>18．吸“555”香烟的人比吸希尔顿香烟的人住的靠右<br>【19】斗地主附残局<br>地主手中牌2、K、Q、J、10、9、8、8、6、6、5、5、3、3、3、3、7、7、7、7<br>长工甲手中牌大王、小王、2、A、K、Q、J、10、Q、J、10、9、8、5、5、4、4<br>长工乙手中牌2、2、A、A、A、K、K、Q、J、10、9、9、8、6、6、4、4<br>三家都是明手，互知底牌。要求是：在三家都不打错牌的情况下，地主必须要么输要么赢。<br>问：哪方会赢？<br>【20】一楼到十楼的每层电梯门口都放着一颗钻石，钻石大小不一。你乘坐电梯从一楼到十楼，每层楼电梯门都会打开一次，只能拿一次钻石，问怎样才能拿到最大的一颗？<br>【21】 U2合唱团在17分钟内得赶到演唱会场，途中必需跨过一座桥，四个人从桥的同一端出发，你得帮助他们到达另一端，天色很暗，而他们只有一只手电筒。一次同时最多可以有两人一起过桥，而过桥的时候必须持有手电筒，所以就得有人把手电筒带来带去，来回桥两端。手电筒是不能用丢的方式来传递的。四个人的步行速度各不同，若两人同行则以较慢者的速度为准。Bono需花1分钟过桥，Edge需花2分钟过桥，Adam需花5分钟过桥，Larry需花10分钟过桥。他们要如何在17分钟内过桥呢？<br>【22】一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率<br>（假定生男生女的概率一样）<br>【23】为什么下水道的盖子是圆的？<br>【24】有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？<br>【25】芯片<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="external">测试</a>：有2k块芯片，已知好芯片比坏芯片多．请设计<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="external">算法</a>从其中找出一片<br>好芯片，说明你所用的比较次数上限．<br>其中：好芯片和其它芯片比较时，能正确给出另一块芯片是好还是坏．<br>坏芯片和其它芯片比较时，会随机的给出好或是坏。<br>【26】话说有十二个鸡蛋，有一个是坏的（重量与其余鸡蛋不同），现要求用天平称三次，称出哪个鸡蛋是坏的！<br>【27】100个人回答五道试题，有81人答对第一题，91人答对第二题，85人答对第三题，79人答对第四题，74人答对第五题，答对三道题或三道题以上的人算及格， 那么，在这100人中，至少有（ ）人及格。<br>【28】陈奕迅有首歌叫十年<br>吕珊有首歌叫3650夜<br>那现在问,十年可能有多少天?<br>【29】<br>1<br>1 1<br>2 1<br>1 2 1 1<br>1 1 1 2 2 1<br>下一行是什么？<br>【30】烧一根不均匀的绳要用一个小时，如何用它来判断半个小时？<br>烧一根不均匀的绳,从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子,问如何用烧绳的方法来计时一个小时十五分钟呢? （微软的笔试题）<br>【31】共有三类药，分别重1g,2g,3g，放到若干个瓶子中，现在能确定每个瓶子中只有其中一种药，且每瓶中的药片足够多，能只称一次就知道各个瓶子中都是盛的哪类药吗？<br>如果有4类药呢？5类呢？N类呢(N可数)？<br>如果是共有m个瓶子盛着n类药呢(m，n为正整数，药的质量各不相同但各种药的质量已知)？你能只称一次就知道每瓶的药是什么吗？<br>注：当然是有代价的，称过的药我们就不用了<br>【32】假设在桌上有三个密封的盒，一个盒中有2枚银币(1银币=10便士)，一个盒中有2枚镍币(1镍币=5便士)，还有一个盒中有1枚银币和1枚镍币。这些盒子被标上10便士、 15便士和20便士，但每个标签都是错误的。允许你从一个盒中拿出1枚硬币放在盒前，看到这枚硬币，你能否说出每个盒内装的东西呢？<br>【33】有一个大西瓜,用水果刀平整地切,总共切9刀,最多能切成多少份,最少能切成多少份?<br>主要是过程，结果并不是最重要的<br>【34】一个巨大的圆形水池，周围布满了老鼠洞。猫追老鼠到水池边，老鼠未来得及进洞就掉入水池里。猫继续沿水池边缘企图捉住老鼠（猫不入水）。已知V猫=4V鼠。问老鼠是否有办法摆脱猫的追逐？<br>【35】有三个桶，两个大的可装8斤的水，一个小的可装3斤的水，现在有16斤水装满了两大桶就是8斤的桶，小桶空着，如何把这16斤水分给4个人，每人4斤。没有其他任何工具，4人自备容器，分出去的水不可再要回来。<br>【36】从前有一位老钟表匠，为一个教堂装一只大钟。他年老眼花，把长短针装配错了，短针走的速度反而是长针的12倍。装配的时候是上午6点，他把短针指在“6 ”上，长针指在“12”上。老钟表匠装好就回家去了。人们看这钟一会儿7点，过了不一会儿就8点了，都很奇怪，立刻去找老钟表匠。等老钟表匠赶到，已经是下午7点多钟。他掏出怀表来一对，钟准确无误，疑心人们有意捉弄他，一生气就回去了。这钟还是8点、9点地跑，人们再去找钟表匠。老钟表匠第二天早晨8点多赶来用表一对，仍旧准确无误。 请你想一想，老钟表匠第一次对表的时候是7点几分？第二次对表又是8点几分？<br>【37】今有2匹马、3头牛和4只羊，它们各自的总价都不满10000文钱（古时的货币单位）。如果2匹马加上1头牛，或者3 头牛加上1只羊，或者4只羊加上1匹马，那么它们各自的总价都正好是10000文钱了。问：马、牛、羊的单价各是多少文钱？<br>【38】一天，harlan的店里来了一位顾客，挑了25元的货，顾客拿出100元，harlan没零钱找不开，就到隔壁飞白的店里把这100元换成零钱，回来给顾客找了75元零钱。过一会，飞白来找harlan，说刚才的是假钱，harlan马上给飞白换了张真钱，问harlan赔了多少钱？<br>【39】猴子爬绳<br>这道力学怪题乍看非常简单，可是据说它却使刘易斯．卡罗尔感到困惑。至于这道<br>怪题是否由这位因《爱丽丝漫游奇境记》而闻名的牛津大学数学专家提出来的，那就不<br>清楚了。总之，在一个不走运的时刻，他就下述问题征询人们的意见:<br>一根绳子穿过无摩擦力的滑轮，在其一端悬挂着一只10磅重的砝码，绳子的另一端<br>有只猴子，同砝码正好取得平衡。当猴子开始向上爬时，砝码将如何动作呢?<br>“真奇怪，”卡罗尔写道，”许多优秀的数学家给出了截然不同的答案。普赖斯认为砝<br>码将向上升，而且速度越来越快。克利夫顿(还有哈考特)则认为，砝码将以与猴子一样<br>的速度向上升起，然而桑普森却说，砝码将会向下降!”<br>一位杰出的机械工程师说”这不会比苍蝇在绳子上爬更起作用”，而一位科学家却认<br>为”砝码的上升或下降将取决于猴子 吃苹果速度的倒数”，然而还得从中求出猴子尾巴的<br>平方根。严肃地说，这道题目非常有趣，值得认真推敲。它很能说明趣题与力学问题之<br>间的紧密联系。<br>【40】两个空心球，大小及重量相同，但材料不同。一个是金，一个是铅。空心球表面图有相同颜色的油漆。现在要求在不破坏表面油漆的条件下用简易方法指出哪个是金的，哪个是铅的。<br>【41】有23枚硬币在桌上，10枚正面朝上。假设别人蒙住你的眼睛，而你的手又摸不出硬币的<br>反正面。让你用最好的方法把这些硬币分成两堆，每堆正面朝上的硬币个数相同。<br>【42】三个村庄A、B、C和三个城镇A、B、C坐落在如图所示的环形山内。<br>由于历史原因，只有同名的村与镇之间才有来往。为方便交通，他们<br>准备修铁路。问题是：如何在这个环形山内修三条铁路连通A村与A镇，<br>B村与B镇，C村与C镇。而这些铁路相互不能相交。（挖山洞、修立交<br>桥都不算，绝对是平面问题）。想出答案再想想这个题说明什么问题。<br>●●●●●●●●●Ｃ●●●●●●●●●●<br>●                                    ●<br>●                                    ●<br>●                                    ●<br>●                                    ●<br>●                                    ●<br>●                                    ●<br>Ａ Ｃ Ｂ<br>●                ●                  ●<br>●                ●                  ●<br>●                ●                  ●<br>●                ●                  ●<br>●                ●                  ●<br>●                ●                  ●<br>●                ●                  ●<br>●●●●●●●●●●●●●●●●●●●● 43】屋里三盏灯,屋外三个开关,一个开关仅控制一盏灯,屋外看不到屋里<br>怎样只进屋一次,就知道哪个开关控制哪盏灯?<br>四盏呢~<br>【44】2+7-2+7全部有火柴根组成，移动其中任何一根，答案要求为30<br>说明：因为书写问题作如下解释，2是由横折横三根组成，7是由横折两根组成<br>【45】5名海盗抢得了窖藏的100块金子，并打算瓜分这些战利品。这是一些讲民主的海盗（当然是他们自己特有的民主），他们的习惯<br>是按下面的方式进行分配：最厉害的一名海盗提出分配方案，然后所有的海盗（包<br>括提出方案者本人）就此方案进行表决。如果50%或更多的海盗赞同此方案，此方<br>案就获得通过并据此分配战利品。否则提出方案的海盗将被扔到海里，然后下一名<br>最厉害的海盗又重复上述过程。<br>所有的海盗都乐于看到他们的一位同伙被扔进海里，不过，如果让他们选择的<br>话，他们还是宁可得一笔现金。他们当然也不愿意自己被扔到海里。所有的海盗都<br>是有理性的，而且知道其他的海盗也是有理性的。此外，没有两名海盗是同等厉害<br>的——这些海盗按照完全由上到下的等级排好了座次，并且每个人都清楚自己和其<br>他所有人的等级。这些金块不能再分，也不允许几名海盗共有金块，因为任何海盗<br>都不相信他的同伙会遵守关于共享金块的安排。这是一伙每人都只为自己打算的海<br>盗。<br>最凶的一名海盗应当提出什么样的分配方案才能使他获得最多的金子呢？<br>【46】他们中谁的存活机率最大？<br>5个囚犯，分别按1-5号在装有100颗绿豆的麻袋抓绿豆，规定每人至少抓一颗，而抓得最多和最少的人将被处死，而且，他们之间不能交流，但在抓的时候，可以摸出剩下的豆子数。问他们中谁的存活几率最大？提示：<br>1，他们都是很聪明的人<br>2，他们的原则是先求保命，再去多杀人<br>3，100颗不必都分完<br>4，若有重复的情况，则也算最大或最小，一并处死<br>【47】有5只猴子在海边发现一堆桃子,决定第二天来平分.第二天清晨,第一只猴子最早来到,它左分右分分不开,就朝海里扔了一只,恰好可以分成5份,它拿上自己的一份走了.第 2,3,4,5只猴子也遇到同样的问题,采用了同样的方法,都是扔掉一只后,恰好可以分成5份.问这堆桃子至少有多少只？<br>【48】话说某天一艘海盗船被天下砸下来的一头牛给击中了,5个倒霉的家伙只好逃难到一个孤岛,发现岛上孤零零的,幸好有有棵椰子树,还有一只猴子!<br>大家把椰子全部采摘下来放在一起,但是天已经很晚了,所以就睡觉先.<br>晚上某个家伙悄悄的起床,悄悄的将椰子分成5份,结果发现多一个椰子,顺手就给了幸运的猴子,然后又悄悄的藏了一份,然后把剩下的椰子混在一起放回原处,最后还是悄悄滴回去睡觉了.<br>过了会儿,另一个家伙也悄悄的起床,悄悄的将剩下的椰子分成5份,结果发现多一个椰子,顺手就又给了幸运的猴子,然后又悄悄滴藏了一份,把剩下的椰子混在一起放回原处,最后还是悄悄滴回去睡觉了.<br>又过了一会 …<br>…<br>又过了一会 …<br>总之5个家伙都起床过,都做了一样的事情<br>早上大家都起床,各自心怀鬼胎的分椰子了,这个猴子还真不是一般的幸运,因为这次把椰子分成5分后居然还是多一个椰子,只好又给它了.<br>问题来了,这堆椰子最少有多少个?<br>【49】小明和小强都是张老师的学生，张老师的生日是M月N日，<br>2人都知道张老师的生日是下列10组中的一天，<br>张老师把M值告诉了小明，把N值告诉了小强，<br>张老师问他们知道他的生日是那一天吗？<br>3月4日 3月5日 3月8日<br>6月4日 6月7日<br>9月1日 9月5日<br>12月1日 12月2日 12月8日<br>小明说：如果我不知道的话，小强肯定也不知道<br>小强说：本来我也不知道，但是现在我知道了<br>小明说：哦，那我也知道了<br>请根据以上对话推断出张老师的生日是哪一天<br>【50】一逻辑学家误入某部落，被囚于牢狱，酋长欲意放行，他对逻辑学家说：“今有两门，一为自由，一为死亡，你可任意开启一门。现从两个战士中选择一人负责解答你所提的任何一个问题（Y/N），其中一个天性诚实，一人说谎成性，今后生死任你选择。”逻辑学家沉思片刻，即向一战士发问，然后开门从容离去。逻辑学家应如何发问？<br>【51】说从前啊,有一个富人,他有30个孩子,其中15个是已故的前妻所生,其余15个是继室所生,这后一个妇人很想让她自己所生的最年长的儿子继承财产,于是,有一天,他就向他说:”亲爱的丈夫啊,你就要老了,我们应该定下来谁将是你的继承人,让我们把我们的30个孩子排成一个圆圈,从他们中的一个数起,每逢到10就让那个孩子站出去,直到最后剩下哪个孩子,哪个孩子就继承你的财产吧!”富人一想,我靠,这个题意相当有内涵了,不错,仿佛很公平,就这么办吧~不过,当剔选过程不断进行下去的时候,这个富人傻眼了,他发现前14个被剔除的孩子都是前妻生的,而且下一个要被剔除的还是前妻生的,富人马上大手一挥,停,现在从这个孩子倒回去数, 继室,就是这个歹毒的后妈一想,倒数就倒数,我15个儿子还斗不过你一个啊~她立即同意了富人的动议,你猜,到底谁做了继承人呢~<br>【52】“有一牧场，已知养牛27头，6天把草吃尽；养牛23头，9天把草吃尽。如果养牛21头，那么几天能把牧场上的草吃尽呢？并且牧场上的草是不断生长的。”<br>【53】一个商人骑一头驴要穿越1000公里长的沙漠，去卖3000根胡萝卜。已知驴一次性可驮1000根胡萝卜，但每走一公里又要吃掉一根胡萝卜。问：商人共可卖出多少胡萝卜？<br>【54】10箱黄金，每箱100块，每块一两<br>有贪官，把某一箱的每块都磨去一钱<br>请称一次找到不足量的那个箱子<br>【55】你让工人为你工作７天，给工人的回报是一根金条。金条平分成相连的７段，你必须在每天结束时都付费，如果只许你两次把金条弄断，你如何给你的工人付费？<br>【56】有十瓶药，每瓶里都装有100片药（仿佛现在装一百片的少了，都是十片二十片的，不管，咱们就这么来了），其中有八瓶里的药每片重10克，另有两瓶里的药每片重9克。用一个蛮精确的小秤，只称一次，如何找出份量较轻的那两个药瓶？<br>【57】一个经理有三个女儿，三个女儿的年龄加起来等于13，三个女儿的年龄乘起来等于经理自己的年龄，有一个下属已知道经理的年龄，但仍不能确定经理三个女儿的年龄，这时经理说只有一个女儿的头发是黑的，然后这个下属就知道了经理三个女儿的年龄。请问三个女儿的年龄分别是多少？为什么？<br>【58】有三个人去住旅馆，住三间房，每一间房$10元，于是他们一共付给老板$30，第二天，老板觉得三间房只需要$25元就够了于是叫小弟退回$5给三位客人，谁知小弟贪心,只退回每人$1，自己偷偷拿了$2，这样一来便等于那三位客人每人各花了九元，于是三个人一共花了$27，再加上小弟独吞了不$2，总共是$29。可是当初他们三个人一共付出$30那么还有$1呢？<br>【59】有两位盲人，他们都各自买了两对黑袜和两对白袜，八对袜了的布质、大小完全相同，而每对袜了都有一张商标纸连着。两位盲人不小心将八对袜了混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？<br>【60】有一辆火车以每小时 15公里的速度离开洛杉矶直奔纽约，另一辆火车以每小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以30公里每小时的速度和两辆火车同时启动，从洛杉矶出发，碰到另一辆车后返回，依次在两辆火车来回飞行，直到两辆火车相遇，请问，这只小鸟飞行了多长距离？<br>【61】你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？<br>【62】你有四个装药丸的罐子，每个药丸都有一定的重量，被污染的药丸是没被污染的重量＋1.只称量一次，如何判断哪个罐子的药被污染了？<br>【63】对一批编号为1～100，全部开关朝上(开)的灯进行以下*作：凡是1的倍数反方向拨一次开关；2的倍数反方向又拨一次开关；3的倍数反方向又拨一次开关……问：最后为关熄状态的灯的编号。<br>【64】想象你在镜子前，请问，为什么镜子中的影像可以颠倒左右，却不能颠倒上下？<br>【65】一群人开舞会，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少有一顶。每个人都能看到其它人帽子的颜色，却看不到自己的。主持人先让大家看看别人头上戴的是什幺帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦雀无声。一直到第三次关灯，才有劈劈啪啪打耳光的声音响起。问有多少人戴着黑帽子？<br>【66】两个圆环，半径分别是1和2，小圆在大圆内部绕大圆圆周一周，问小圆自身转了几周？如果在大圆的外部，小圆自身转几周呢？<br>【67】 1元钱一瓶汽水，喝完后两个空瓶换一瓶汽水，问：你有20元钱，最多可以喝到几瓶汽水？<br>【68】有3顶红帽子，4顶黑帽子，5顶白帽子。让10个人从矮到高站成一队，给他们每个人头上戴一顶帽子。每个人都看不见自己戴的帽子的颜色，却只能看见站在前面那些人的帽子颜色。（所以最后一个人可以看见前面9个人头上帽子的颜色，而最前面那个人谁的帽子都看不见。现在从最后那个人开始，问他是不是知道自己戴的帽子颜色，如果他回答说不知道，就继续问他前面那个人。假设最前面那个人一定会知道自己戴的是黑帽子。为什么？<br>【69】假设排列着100个乒乓球，由两个人轮流拿球装入口袋，能拿到第100个乒乓球的人为胜利者。条件是：每次拿球者至少要拿1个，但最多不能超过5个，问：如果你是最先拿球的人，你该拿几个？以后怎么拿就能保证你能得到第100个乒乓球？<br>【70】卢姆教授说：“有一次我目击了两只山羊的一场殊死决斗，结果引出了一个有趣的数学问题。我的一位邻居有一只山羊，重54磅，它已有好几个季度在附近山区称王称霸。后来某个好事之徒引进了一只新的山羊，比它还要重出3磅。开始时，它们相安无事，彼此和谐相处。可是有一天，较轻的那只山羊站在陡峭的山路顶上，向它的竞争对手猛扑过去，那对手站在土丘上迎接挑战，而挑战者显然拥有居高临下的优势。不幸的是，由于猛烈碰撞，两只山羊都一命呜呼了。<br>现在要讲一讲本题的奇妙之处。对饲养山羊颇有研究，还写过书的乔治．阿伯克龙比说道：“通过反复实验，我发现，动量相当于一个自20英尺高处坠落下来的30磅重物的一次撞击，正好可以打碎山羊的脑壳，致它死命。”如果他说得不错，那么这两只山羊至少要有多大的逼近速度，才能相互撞破脑壳？你能算出来吗？<br>【71】据说有人给酒肆的老板娘出了一个难题：此人明明知道店里只有两个舀酒的勺子，分别能舀7两和11两酒，却硬要老板娘卖给他2两酒。聪明的老板娘毫不含糊，用这两个勺子在酒缸里舀酒，并倒来倒去，居然量出了2两酒，聪明的你能做到吗？<br>【72】已知： 每个飞机只有一个油箱， 飞机之间可以相互加油（注意是相互，没有加油机）一箱油可供一架飞机绕地球飞半圈，问题：为使至少一架飞机绕地球一圈回到起飞时的飞机场，至少需要出动几架飞机？（所有飞机从同一机场起飞，而且必须安全返回机场，不允许中途降落，中间没有飞机场）</p>
<p>【73】在9个点上画10条直线，要求每条直线上至少有三个点？</p>
<p>【74】一个岔路口分别通向诚实国和说谎国。来了两个人，已知一个是诚实国的，另一个是说谎国的。诚实国永远说实话，说谎国永远说谎话。现在你要去说谎国，但不知道应该走哪条路，需要问这两个人。请问应该怎么问？<br>【75】在一天的24小时之中，时钟的时针、分针和秒针完全重合在一起的时候有几次？都分别是什么时间？你怎样算出来的？ </p>
<p>答案：</p>
<p>【1】</p>
<p>1、先把5升的灌满，倒在6升里，这时6升的壶里有5升水</p>
<p>2.再把5升的灌满，用5升的壶把6升的灌满，这时5升的壶里剩4升水</p>
<p>3.把6升的水倒掉，再把5升壶里剩余的水倒入6升的壶里，这时6升的壶里有4升水</p>
<p>4.把5升壶灌满，倒入6升的壶，5-2=3</p>
<p>【2】</p>
<p>把第二个满着的杯子里的水倒到第五个空着的杯子里</p>
<p>【3】</p>
<p>小黄。因为小李是第一个出手的，他要解决的第一个人就会是</p>
<p>小林，这样就会保证自己的安全，因为如果小黄被解决，自己理所当然地会成为小林的目标，他也必定会被打死。而小黄如果第一枪不打小林而去打小李，自己肯定会死（他命中较高，会成为接下来的神枪手小林的目标）。他必定去尝试先打死小林。那么30% 50%的几率是80%（第一回合小林的死亡率，但会有一点点偏差，毕竟相加了）。那么第一回合小黄的死亡率是20%多一点点（小林的命中减去自己的死亡率）。假设小林第一回合死了，就轮到小李打小黄了，那么小李的命中就变成了50%多一点点(自己的命中加上小黄的死亡率）。这样就变成了小李小黄对决，</p>
<p>第二回合的小李的第一枪命中是50%，小黄也是。可是如果拖下去的话占上风的自然就是小黄了，可能赢得也自然是小黄了。至于策略我看大家都领悟了吧。</p>
<p>【4】</p>
<p>甲分三碗汤，乙选认为最多和最少的倒回灌里再平分到剩余的两个碗里，让丁先选，其次是甲，最后是乙</p>
<p>【5】</p>
<p>假如先前N个中没有重叠且边上的都超出桌子的边上且全都是紧靠着的.那么根据题意就可以有:</p>
<p>空隙个数Y=3N/2 3(自己推算)</p>
<p>每一个空都要一个圆来盖</p>
<p>桌面就一共有圆的数为:</p>
<p>Y N=3N/2 3</p>
<p>=5N/2 3 &lt;=4N(除N=1外)</p>
<p>所以可以用4N个硬币完全覆盖.</p>
<p>【6】</p>
<p>用绳子围球一周后测绳长来计算半径（用纸筒套住球来测更准）</p>
<p>借助排水法测体积后计算半径</p>
<p>【7】</p>
<p>要两人才能做到，</p>
<p>先在平面上摆放一枚，再在这枚硬币的正面立着放两枚（这两枚是侧面接触的），这样，这三枚硬币之间形成一个三角形空隙。剩下的两枚在空隙处交叉就行了，注意这两枚同样是平躺着，但可能需要翘起一定的角度。</p>
<p>【8】</p>
<p>方块5</p>
<p>从第一句话可以排除掉 黑桃J,8,2,7,3 草花K,6因为这种点数只出现一次.</p>
<p>从第二句话可以知道Q所知道的花色中所有的点数都出现过两次或以上才肯定P不知道是哪一张牌.这样我们可以看出只有红桃和方块存在这种现象,所以必然是这两种花色之一.</p>
<p>从第三句话P肯定自己知道是什么牌可以知道这个点数在红桃和方块里肯定是唯一性,所以可以排除红桃和方块A还剩下红桃Q ,4和方块5不能肯定了.但是Q知道花色啊.所以</p>
<p>从第四句话可以肯定就是方块5了,因为是红桃中的其中一个的话,Q是不能判断他知道的.</p>
<p>所以结论就是方块5</p>
<p>【9】</p>
<p>经过第一轮，说明任何两个数都是不同的。第二轮，前两个人没有猜出，说明任何一个数都不是其它数的两倍。现在有了以下几个条件：1.每个数大于02.两两不等3.任意一个数不是其他数的两倍。每个数字可能是另两个之和或之差，第三个人能猜出144，必然根据前面三个条件排除了其中的一种可能。假设：是两个数之差，即x－y＝144。这时1（x，y&gt;0）和2（x！＝y）都满足，所以要否定x＋y必然要使3不满足，即x＋y＝2y，解得x＝y，不成立（不然第一轮就可猜出），所以不是两数之差。因此是两数之和，即x＋y＝144。同理，这时1，2都满足，必然要使3不满足，即x－y＝2y，两方程联立，可得x＝108，y＝36。</p>
<p>这两轮猜的顺序其实分别为这样：第一轮（一号，二号），第二轮（三号，一号，二号）。这样分大家在每轮结束时获得的信息是相同的（即前面的三个条件）。</p>
<p>那么就假设我们是C，来看看C是怎么做出来的：C看到的是A的36和B的108，因为条件，两个数的和是第三个，那么自己要么是72要么是144（猜到这个是因为72的话，108就是36和72的和，144的话就是108和36的和。这样子这句话看不懂的举手）:</p>
<p>假设自己（C）是72的话，那么B在第二回合的时候就可以看出来，下面是如果C是72，B的思路：这种情况下，B看到的就是A的36和C的72，那么他就可以猜自己，是36或者是108（猜到这个是因为36的话，36加36等于72，108的话就是36和108的和）：</p>
<p>如果假设自己（B）头上是36，那么，C在第一回合的时候就可以看出来，下面是如果B是36，C的思路：这种情况下，C看到的就是A的36和B的36，那么他就可以猜自己，是72或者是0（这个不再解释了）：</p>
<p>如果假设自己（C）头上是0，那么，A在第一回合的时候就可以看出来，下面是如果C是0，A的思路：这种情况下，A看到的就是B的36和C的0，那么他就可以猜自己，是36或者是36（这个不再解释了），那他可以一口报出自己头上的36。（然后是逆推逆推逆推），现在A在第一回合没报出自己的36，C（在B的想象中）就可以知道自己头上不是0，如果其他和B的想法一样（指B头上是36），那么C在第一回合就可以报出自己的72。现在C在第一回合没报出自己的36，B（在C的想象中）就可以知道自己头上不是36，如果其他和C的想法一样（指C头上是72），那么B在第二回合就可以报出自己的108。现在B在第二回合没报出自己的108，C就可以知道自己头上不是72，那么C头上的唯一可能就是144了。</p>
<p>【10】</p>
<p>15%<em>80%/(85％×20％＋15%</em>80%)</p>
<p>【11】</p>
<p>f(x)=(60-2x)*x,当x=15时，有最大值450。</p>
<p>1820元设是X公里处赚最多钱。问题就成是求一个一元二次方程的最大值，求得是在15公里处赚钱最多，450元。一共240公斤……</p>
<p>【12】</p>
<p>6种结果</p>
<p>大、中、小：(2\30\68)(5\25\70)(8\20\72)(11\15\74)(14\10\76)(17\5\78)</p>
<p>【13】</p>
<p>因为1=5，所以5=1</p>
<p>【14】</p>
<p>本题可用递归算法，但时间复杂度为2的n次方，也可以用动态规划法，时间复杂度为n的平方，实现起来相对要简单得多，但最方便的就是直接运用公式：排队的种数=(2n)!/[n!(n 1)!]。</p>
<p>如果不考虑电影院能否找钱，那么一共有(2n)!/[n!n!]种排队方法（即从2n个人中取出n个人的组合数），对于每一种排队方法，如果他会导致电影院无法找钱，则称为不合格的，这种的排队方法有(2n)!/[(n-1)!(n 1)!]（从2n个人中取出n-1个人的组合数）种，所以合格的排队种数就是(2n)!/[n!n!]- (2n)!/[(n-1)!(n 1)!] =(2n)!/[n!(n 1)!]。至于为什么不合格数是(2n)!/[(n-1)!(n 1)!]，说起来太复杂，这里就不讲了。</p>
<p>【15】</p>
<p>2元</p>
<p>【16】</p>
<p>M=5 C得第二名</p>
<p>因为ABC三人得分共40分,三名得分都为正整数且不等,所以前三名得分最少为6分,40=5<em>8=4</em>10=2<em>20=1</em>20,不难得出项目数只能是5.即M=5.</p>
<p>A得分为22分,共5项,所以每项第一名得分只能是5,故A应得4个第一名一个第二名.22=5*4 2,第二名得2分,又B百米得第一,9=5 1 1 1 1 所以跳高中只有C得第二名</p>
<p>B的5项共9分,其中百米第一5分,其它4项全是1分,9=5 1=1 1 1.即B除百米第一外全是第三,跳高第二必定是C所得</p>
<p>【17】</p>
<p>房子 黄 蓝 红 绿 白</p>
<p>国籍 挪威 丹麦 英国 德国 瑞士</p>
<p>饮料 矿泉水 茶 牛奶 咖啡 啤酒</p>
<p>宠物 猫 马 鸟 鱼 狗</p>
<p>香烟 DUNHILL 混合烟 PALLMALL PRINCE BLUE MASTER</p>
<p>【18】</p>
<p>1 2 3 4 5</p>
<p>蓝房子 绿 黄 红 白</p>
<p>北京人 上海 香港 天津 成都</p>
<p>茅台酒 葡萄 矿泉水 茶 啤酒</p>
<p>豆腐 面条 牛肉 比萨 鸡</p>
<p>健牌 希尔顿 万宝路 555 红塔山</p>
<p>马 狗 蛇 猫 鱼</p>
<p>【19】</p>
<p>A家先打：55</p>
<p>B家如果打：TT的话．</p>
<p>C家随便他吃不吃．．</p>
<p>A家都不跟．（反正B家跟C家哪家有吃55的话，都不跟．除非A家88可以出就跟）</p>
<p>如果刚才是B家吃的话，就B家出牌：你看．B家最多也出44然后C家吃他66．如果他是出两个99那地主也不跟！；如果B家出单的话．地主还有一个2可以压！（反正B家跟C家肯定是会打对子的！）</p>
<p>照刚才那样．A家牌下面应该剩：2 K Q J T 9 7777 66 3333</p>
<p>B家：大王 小王 2 A K QQ JJ 9 8 55</p>
<p>C家：22 AAA K Q J T 99 8 44</p>
<p>A家吃完88后．B家吃JJ（反正无论如何．都会打单的．）要是打单的话．A家就用2压．B家双王不可能会压吧．（即使压了也没事．）</p>
<p>A家用2压完后就打：K Q J T 9</p>
<p>B家如果用双王吃的话．那等他出牌的时候．马上用3333吃他．如果B家没吃的话．C家会吃：A K Q J T</p>
<p>然后A家可以用3333压下A K Q J T 如果B家用双王吃的话．那正合我意了哈．！A家反正只剩下7777 66了等他打什么．．都用7777吃他．最后打66</p>
<p>【20】</p>
<p>先拿下第一楼的钻石，然后在每一楼把手中的钻石与那一楼的钻石相比较，如果那一楼的钻石比手中的钻石大的话那就把手中的钻石换成那一层的钻石。</p>
<p>（因为“只能拿一次”是在外文翻译过来的，所以是总共只能拿一次，还是每层只能拿一次?无法知道。但如果这个和“在稻田一直走，不能回头，请你捡出最大的一个稻穗”这样的题目一样的话，那么上面的就是正确答案！）</p>
<p>【21】</p>
<p>假设这四个人分别为甲（1分钟）乙（2分钟）丙（5分钟）丁（10分钟）</p>
<p>第一次去：甲和乙 （2分钟）</p>
<p>第一次回：甲（1分钟）</p>
<p>第二次去：丙和丁（10分钟）</p>
<p>第二次回：乙（2分钟）</p>
<p>第三次去：甲和乙（2分钟）</p>
<p>总计 ：17分钟</p>
<p>【22】</p>
<p>1/3</p>
<p>(因为你知道一共有两个小孩 其中一个是女孩 而你已知的那个女孩并不知道是她第一个孩子还是第二个孩子所以它的概率是1/3</p>
<p>如果题目换成 已知第一个是女孩 那么第二个是女孩的概率就是1/2了)</p>
<p>【23】</p>
<p>主要是因为如果是方的、长方的或椭圆的，盖子很容易掉进地下道！但圆形的盖子嘛，就可以避免这种情况了。另外、圆形的盖子可以节省材料，增大洞口面积，井盖及井座的强度增加不易轧坏。</p>
<p>【24】</p>
<p>\1. 天平一边放7 2=9克砝码，另一边放9克盐。</p>
<p>\2. 天平一边放7克砝码和刚才得到的9克盐，另一边放16克盐。</p>
<p>\3. 天平一边放刚才得到的16克盐和再刚才得到的9克盐，另一边放25克盐。</p>
<p>【25】</p>
<p>把第一块芯片与其它逐一对比，看看其它芯片对第一块芯片给出的是好是坏，如果给出是好的过半，那么说明这是好芯片，完毕。如果给出的是坏的过半，说明第一块芯片是坏的，那么就要在那些在给出第一块芯片是坏的芯片中，重复上述步骤，直到找到好的芯片为止。</p>
<p>【26】</p>
<p>12个时可以找出那个是重还是轻，13个时只能找出是哪个球，轻重不知。</p>
<p>把球编为①②③④⑤⑥⑦⑧⑨⑩⑾⑿。（13个时编号为⒀）</p>
<p>第一次称：先把①②③④与⑤⑥⑦⑧放天平两边，</p>
<p>㈠如相等，说明特别球在剩下4个球中。</p>
<p>把①⑨与⑩⑾作第二次称量，</p>
<p>⒈如相等，说明⑿特别，把①与⑿作第三次称量即可判断是⑿是重还是轻</p>
<p>⒉如①⑨＜⑩⑾说明要么是⑩⑾中有一个重的，要么⑨是轻的。</p>
<p>把⑩与⑾作第三次称量，如相等说明⑨轻，不等可找出谁是重球。</p>
<p>⒊如①⑨＞⑩⑾说明要么是⑩⑾中有一个轻的，要么⑨是重的。</p>
<p>把⑩与⑾作第三次称量，如相等说明⑨重，不等可找出谁是轻球。</p>
<p>㈡如左边＜右边，说明左边有轻的或右边有重的</p>
<p>把①②⑤与③④⑥做第二次称量</p>
<p>⒈如相等，说明⑦⑧中有一个重，把①与⑦作第三次称量即可判断是⑦与⑧中谁是重球</p>
<p>⒉如①②⑤＜③④⑥说明要么是①②中有一个轻的，要么⑥是重的。</p>
<p>把①与②作第三次称量，如相等说明⑥重，不等可找出谁是轻球。</p>
<p>⒊如①②⑤＞③④⑥说明要么是⑤是重的，要么③④中有一个是轻的。</p>
<p>把③与④作第三次称量，如相等说明⑤重，不等可找出谁是轻球。</p>
<p>㈢如左边＞右边，参照㈡相反进行。</p>
<p>当13个球时，第㈠步以后如下进行。</p>
<p>把①⑨与⑩⑾作第二次称量，</p>
<p>⒈如相等，说明⑿⒀特别，把①与⑿作第三次称量即可判断是⑿还是⒀特别，但判断不了轻重了。</p>
<p>⒉不等的情况参见第㈠步的⒉⒊</p>
<p>【27】</p>
<p>首先求解原题。每道题的答错人数为（次序不重要）：26，21，19，15，9</p>
<p>第3分布层：答错3道题的最多人数为：（26 21 19 15 9）/3=30</p>
<p>第2分布层：答错2道题的最多人数为：（21 19 15 9）/2=32</p>
<p>第1分布层：答错1道题的最多人数为：（19 15 9）/1=43</p>
<p>Max_3=Min(30, 32, 43)=30。因此答案为：100-30=70。</p>
<p>其实，因为26小于30，所以在求出第一分布层后，就可以判断答案为70了。</p>
<p>要让及格的人数最少，就要做到两点：</p>
<p>\1. 不及格的人答对的题目尽量多，这样就减少了及格的人需要答对的题目的数量，也就只需要更少的及格的人</p>
<p>\2. 每个及格的人答对的题目数尽量多，这样也能减少及格的人数</p>
<p>由1得每个人都至少做对两道题目</p>
<p>由2得要把剩余的210道题目分给其中的70人： 210/3 = 70，让这70人全部题目都做对，而其它30人只做对了两道题</p>
<p>也很容易给出一个具体的实现方案：</p>
<p>让70人答对全部五道题，11人仅答对第一、二道题，10人仅答对第二、三道题，5人答对第三、四道题，4人仅答对第四、五道题</p>
<p>显然稍有变动都会使及格的人数上升。所以最少及格人数就是70人！</p>
<p>【28】</p>
<p>十年可能包含2-3个闰年，3652或3653天。</p>
<p>1900年这个闰年就是28天，1898~1907这10年就是3651天，闰年如果是整百的倍数，如1800，1900，那么这个数必须是400的倍数才有29天，比如1900年2月有28天，2000年2月有29天。</p>
<p>【29】</p>
<p>下行是对上一行的解释 所以新的应该是3个1 2个2 1个1 ：312211</p>
<p>【30】</p>
<p>一，一根绳子从两头烧，烧完就是半个小时。</p>
<p>二，一根要一头烧，一根从两头烧，两头烧完的时候（30分），将剩下的一根另一端点着，烧尽就是45分钟。再从两头点燃第三根，烧尽就是1时15分。</p>
<p>【31】</p>
<p>第一个瓶子拿出一片，第二个瓶子拿出四片，第三个拿出十六片，……第m个拿出n 1的m-1次方片。把所有这些药片放在一起称重量。</p>
<p>【32】</p>
<p>取出标着15便士的盒中的一个硬币，如果是银的说明这个盒是20便士的，如果是镍的说明这个盒是10便士的，再由每个盒的标签都是错误的可以推出其它两个盒里的东西。</p>
<p>【33】</p>
<p>最少10，最多130</p>
<p>见下表，表中蓝色部分服从2为底的指数函数规律，红色部分的数值均为其左边与左上角的两个数之和。</p>
<p>x</p>
<p>0 1 2 3 4 5 6 7 8 9</p>
<p>x个点最多能把直线分成多少部分</p>
<p>1 2 3 4 5 6 7 8 9 10</p>
<p>x条直线最多能把平面分成多少部分</p>
<p>1 2 4 7 11 16 22 29 37 46</p>
<p>x个平面最多能把空间分成多少</p>
<p>【34】</p>
<p>第一步：游到水池中心。</p>
<p>第二步：从水池中心游到距中心R/4处，并始终保持鼠、水池中心、猫在一直线上。</p>
<p>第三步：沿与中心相反方向的直线游3R/4就可以到达水池边，而猫沿圆周到达那里需要3.14R，所以捉不到老鼠。</p>
<p>【35】</p>
<p>表示为880，接下来，将一个大桶的水倒入小桶中，倒满，表示为853，（第2个大桶减3，小桶加3）则过程如下：</p>
<p>880——853：将3斤给第1个人，变为850（此时4人分别有水3-0-0-0）</p>
<p>850——823：将2斤给第2个人，变为803（此时4人分别有水3-2-0-0）</p>
<p>803——830——533——560——263——281：将1斤给第1个人，变为280（此时4人分别有水4-2-0-0）</p>
<p>280——253——703——730——433——460——163：将1斤给第3个人，变为063（此时4人分别有水4-2-1-0）</p>
<p>063——081：将1斤给第4个人，变为080（此时4人分别有水4-2-1-1）</p>
<p>080——053——350——323：将2斤给第2个人，将2个3斤分别给第3、4个人，（此时4人分别有水4-4-4-4）</p>
<p>【36】</p>
<p>7点x分：(7 x/60)/12=x/60 x=7*60=420/11=38.2</p>
<p>第一次是7点38分，第二次是8点44分</p>
<p>【37】</p>
<p>马3600 牛2800 羊1600</p>
<p>【38】</p>
<p>100</p>
<p>【39】</p>
<p>砝码将以与猴子相同的速度上升，因为它们质量相同，受力也相同</p>
<p>【40】</p>
<p>旋转看速度，金的密度大，质量相同，所以金球的实际体积较小，因为外半径相同，所以金球的内半径较大，所以金球的转动惯量大，在相同的外加力矩之下，金球的角加速度较小，所以转得慢。</p>
<p>【41】</p>
<p>分成10＋13两堆， 然后翻转10的那堆</p>
<p>【42】</p>
<p>作图如下:</p>
<p>●●●●●●●●●Ｃ●●●●●●●●●●</p>
<p>● ●</p>
<p>● ●</p>
<p>● ●</p>
<p>Ａ Ｃ Ｂ</p>
<p>● ● ●</p>
<p>● ● ●</p>
<p>● ● ●</p>
<p>● Ｂ ● Ａ ●</p>
<p>● ● ●</p>
<p>●●●●●●●●●●●●●●●●●●●●</p>
<p>答题完毕.</p>
<p>【43】</p>
<p>温度，先开一盏，足够长时间后关了，开另一盏，进屋看，亮的为后来开的，摸起来热的为先开的，剩下的一盏也就确定了。</p>
<p>四盏的情况：设四个开关为ABCD，先开AB，足够长时间后关B开C，然后进屋，又热又亮为A，只热不亮为B，只亮不热为C，不亮不热为D。</p>
<p>【44】</p>
<p>1, 改变赋值号.比如 ,-,=</p>
<p>2, 注意质数.</p>
<p>3, 可能把画面颠倒过来.</p>
<p>4, 然后就可以去考虑更改其他数字更改了</p>
<p>247-217＝30</p>
<p>【45】</p>
<p>如果轮到第四个海盗分配：100，0</p>
<p>轮到第三个：99，0，1</p>
<p>轮到第二个：98，0，1，0</p>
<p>轮到第一个：97，0，1，0，2，这就是第一个海盗的最佳方案。</p>
<p>【46】</p>
<p>第一个人选择17时最优的。它有先动优势。他确实有可能被逼死，后面的2、3、4号也想把1号逼死，但做不到（起码确定性逼死做不到）</p>
<p>可以看一下，如果第1个人选择21，他的信息时暴露给第2个人的，那么，1号就将自己暴露在一个非常不利的环境下，2-4号就会选择20，五号就会被迫在1-19中选择，则1、5号处死。所以1号不会这样做，会选择一个更小的数。</p>
<p>1号选择一个&lt;20的数后，2号没有动力选择一个偏离很大的数（因为这个游戏偏离大会死），只会选择 1或-1，取决于那个死的概率小一些，再考虑这些的时候，又必须逆向考虑，1号必须考虑2-4号的选择，2号必须考虑3、4号的选择，… …只有5号没得选择，因为前面是只有连着的两个数（且表示为N，N 1），所以5号必死，他也非常明白这一点，会随机选择一个数，来决定整个游戏的命运，但决定不了他自己的命运。</p>
<p>下面决定的就是1号会选择一个什么数，他仍然不会选择一个太大或太小的数，因为那样仍然是自己处于不利的地位（2-4号肯定不会留情面的），100/6=16.7（为什么除以6？因为5号会随机选择一个数，对1号来说要尽可能的靠近中央，2-4好也是如此，而且正因为2-4号如此，1号才如此… …），最终必然是在16、17种选择的问题。</p>
<p>对16、17进行概率的计算之后，就得出了3个人选择17，第四个人选择16时，为均衡的状态，第4号虽然选择16不及前三个人选择17生存的机会大，但是若选择17则整个游戏的人必死（包括他自己）！第3号没有动力选择16，因为计算概率可知生存机会不如17。</p>
<p>所以选择为17、17、17、16、X（1-33随机），1-3号生存机会最大。</p>
<p>【47】</p>
<p>这堆桃子至少有3121只。</p>
<p>第一只猴子扔掉1个，拿走624个，余2496个；</p>
<p>第二只猴子扔掉1个，拿走499个，余1996个；</p>
<p>第三只猴子扔掉1个，拿走399个，余1596个；</p>
<p>第四只猴子扔掉1个，拿走319个，余1276个；</p>
<p>第五只猴子扔掉1个，拿走255个，余4堆，每堆255个。</p>
<p>如果不考虑正负，-4为一解</p>
<p>考虑到要5个猴子分，假设分n次。</p>
<p>则题目的解: 5^n-4</p>
<p>本题为5^5-4=3121.</p>
<p>设共a个桃，剩下b个桃，则b=(4/5)((4/5)((4/5)((4/5)((4/5)(a-1)-1)-1)-1)-1)-1)，即b=（1024a-8404）/3125 ; a=3b 8 53*(b 4)/1024，而53跟1024不可约，则令b=1020可有最小解，得a=3121 ,设桃数x,得方程</p>
<p>4/5{4/5{4/5[4/5(x-1)-1]-1}-1}=5n</p>
<p>展开得</p>
<p>256x=3125n 2101</p>
<p>故x=(3125n 2101)/256=12n 8 53*(n 1)/256</p>
<p>因为53与256不可约,所以判断n=255有一解.x为整数,等于3121</p>
<p>【48】</p>
<p>这堆椰子最少有15621</p>
<p>第一个人给了猴子1个，藏了3124个，还剩12496个；</p>
<p>第二个人给了猴子1个，藏了2499个，还剩9996个；</p>
<p>第三个人给了猴子1个，藏了1999个，还剩7996个；</p>
<p>第四个人给了猴子1个，藏了1599个，还剩6396个；</p>
<p>第五个人给了猴子1个，藏了1279个，还剩5116个；</p>
<p>最后大家一起分成5份，每份1023个，多1个，给了猴子。</p>
<p>【49】</p>
<p>答案应该是9月1日。</p>
<p>1）首先分析这10组日期，经观察不难发现，只有6月7日和12月2日这两组日期的</p>
<p>日数是唯一的。由此可知，如果小强得知的N是7或者2，那么他必定知道了老师的</p>
<p>生日。</p>
<p>2）再分析“小明说：如果我不知道的话，小强肯定也不知道”，而该10组日期的</p>
<p>月数分别为3，6，9，12，而且都相应月的日期都有两组以上，所以小明得知M后</p>
<p>是不可能知道老师生日的。</p>
<p>3）进一步分析“小明说：如果我不知道的话，小强肯定也不知道”，结合第2步</p>
<p>结论，可知小强得知N后也绝不可能知道。</p>
<p>4）结合第3和第1步，可以推断：所有6月和12月的日期都不是老师的生日，因为</p>
<p>如果小明得知的M是6，而若小强的N==7，则小强就知道了老师的生日。（由第</p>
<p>1步已经推出），同理，如果小明的M==12，若小强的N==2，则小强同样可以知道老师的生日。即：M不等于6和9。现在只剩下“3月4日 3月5日 3月8日 9月1日</p>
<p>9月5日”五组日期。而小强知道了，所以N不等于5（有3月5日和9月5日），此时，</p>
<p>小强的N∈（1，4，8）注：此时N虽然有三种可能，但对于小强只要知道其中的</p>
<p>一种，就得出结论。所以有“小强说：本来我也不知道，但是现在我知道了”，</p>
<p>对于我们则还需要继续推理</p>
<p>至此，剩下的可能是“3月4日 3月8日 9月1日”</p>
<p>5）分析“小明说：哦，那我也知道了”，说明M==9，N==1，（N==5已经被排除，3月份的有两组）</p>
<p>【50】</p>
<p>如果我问另一个人死亡之门在哪里，他会怎么回答？</p>
<p>最终得到的回答肯定是指向自由之门的。</p>
<p>【51】</p>
<p>10 11 12 13 14 15 16 17 18 19 20 21 22 23= 198</p>
<p>198/ 30= 6余18.</p>
<p>小孩子站在18号位置即可.</p>
<p>【52】</p>
<p>1）27头牛6天所吃的牧草为：27×6=162</p>
<p>（这162包括牧场原有的草和6天新长的草。）</p>
<p>（2）23头牛9天所吃的牧草为：23×9=207</p>
<p>（这207包括牧场原有的草和9天新长的草。）</p>
<p>（3）1天新长的草为：（207－162）÷（9－6）=15</p>
<p>（4）牧场上原有的草为：27×6－15×6=72</p>
<p>（5）每天新长的草足够15头牛吃，21头牛减去15头，剩下6头吃原牧场的草：</p>
<p>72÷（21－15）=72÷6=12（天）</p>
<p>【53】</p>
<p>假设出沙漠时有1000根萝卜，那么在出沙漠之前一定不只1000根，那么至少要驮两次才会出沙漠，那样从出发地到沙漠边缘都会有往返的里程，那所走的路程将大于3000公里，故最后能卖出萝卜的数量一定是小于1000根的。</p>
<p>那么在走到某一个位置的时候萝卜的总数会恰好是1000根。</p>
<p>因为驴每次最多驮1000，那么为了最大的利用驴，第一次卸下的地点应该是使萝卜的数量为2000的地点。</p>
<p>因为一开始有3000萝卜，驴必须要驮三次，设驴走X公里第一次卸下萝卜</p>
<p>则：5X=1000（吃萝卜的数量，也等于所行走的公里数）</p>
<p>X=200，也就是说第一次只走200公里</p>
<p>验算：驴驮1000根走200公里时剩800根，卸下600根，返回出发地</p>
<p>前两次就囤积了1200根，第三次不用返回则剩800根，则总共是2000根萝卜了。</p>
<p>第二次驴只需要驮两次，设驴走Y公里第二次卸下萝卜</p>
<p>则：3Y=1000， Y=333.3</p>
<p>验算：驴驮1000根走333.3公里时剩667根，卸下334根，返回第一次卸萝卜地点</p>
<p>第二次在途中会吃掉334根萝卜，到第二次卸萝卜地点是加上卸下的334根，刚好是1000根。</p>
<p>而此时总共走了：200 333.3=533.3公里，而剩下的466.7公里只需要吃466根萝卜</p>
<p>所以可以卖萝卜的数量就是1000-466=534.</p>
<p>【54】</p>
<p>编号为1到100箱, 每箱取跟编号相同数目的黄金, 称量. 少多少钱,就是多少编号的箱子不足.</p>
<p>【55】</p>
<p>分为, 1,2,4 三段.</p>
<p>第一天, 1个环给工人</p>
<p>第二天, 2个环给工人, 拿回一个环</p>
<p>第三天, 1个环给工人</p>
<p>第四天, 4个环给工人, 拿回1个环,2个环</p>
<p>第五天, 一个环给工人</p>
<p>第六天, 2个环给工人,拿回1个环</p>
<p>第七天, 1个环给工人.</p>
<p>【56】</p>
<p>编号1至10, 1号取10片, 2号取20片,以此类推.</p>
<p>称量所有取出药片, 缺少多少, 就是哪两个瓶子分量较轻.</p>
<p>【57】</p>
<p>显然3个女儿的年龄都不为0，要不爸爸就为0岁了，因此女儿的年龄都大于等于1岁。这样可以得下面的情况：1<em>1</em>11=11，1<em>2**10=20，1</em>3<em>9=27，1</em>4<em>8=32，1</em>5<em>7=35，{1</em>6<em>6=36}，{2</em>2<em>9=36}，2</em>3<em>8=48，2</em>4<em>7=56，2</em>5<em>6=60，3</em>3<em>7=63，3</em>4<em>6=72，3</em>5<em>5=75，4</em>4<em>5=80因为下属已知道经理的年龄，但仍不能确定经理三个女儿的年龄，说明经理是36岁（因为{1</em>6<em>6=36}，{2</em>2*9=36}），所以3个女儿的年龄只有2种情况，经理又说只有一个女儿的头发是黑的，说明只有一个女儿是比较大的，其他的都比较小，头发还没有长成黑色的，所以3个女儿的年龄分别为2，2，9！</p>
<p>【58】</p>
<p>应该是三个人付了9*3=27，其中2付给了小弟，25付给了老板</p>
<p>【59】</p>
<p>把每双袜子的商标撕开，然后每人拿每双的一只</p>
<p>【60】</p>
<p>S1= (15 20)t</p>
<p>S2= 30t</p>
<p>得到S2= 6/7 S1. 小鸟飞行两地距离的6/7.</p>
<p>【61】</p>
<p>一个罐子放一个红球，另一个罐子放49个红球和50个蓝球，概率接近75%</p>
<p>【62】</p>
<p>1号罐取一个药片, 2号罐取两个药片,3号罐取3个药片, 4号罐取4个药片.</p>
<p>称量总重量, 比正常重量重几, 就是几号罐子被污染了.</p>
<p>【63】</p>
<p>1 4 9</p>
<p>【64】</p>
<p>因为镜子和你平行.</p>
<p>如果镜子与人不平行, 就可以颠倒上下.</p>
<p>实际上镜子并没有颠倒左右，而是颠倒前后</p>
<p>【65】</p>
<p>1，若是两个人，设A、B是黑帽子,第二次关灯就会有人打耳光。原因是A看到B第一次没打耳光，就知道B也一定看到了有带黑帽子的人，可A除了知道B带黑帽子外，其他人都是白帽子，就可推出他自己是带黑帽子的人！同理B也是这么想的，这样第二次熄灯会有两个耳光的声音。</p>
<p>2，如果是三个人，A,B,C. A第一次没打耳光，因为他看到B,C都是带黑帽子的；而且假设自己带的是白帽子，这样只有BC戴的是黑帽子；按照只有两个人带黑帽子的推论，第二次应该有人打耳光；可第二次却没有。。。于是他知道B和C一定看到了除BC之外的其他人带了黑帽子，于是他知道BC看到的那个人一定是他，所以第三次有三个人打了自己一个耳光！</p>
<p>【66】</p>
<p>把大圆剪断拉直。小圆绕大圆圆周一周，就变成从直线的一头滚至另一头。因为直线长就是大圆的周长，是小圆周长的2倍，所以小圆要滚动2圈。</p>
<p>但是现在小圆不是沿直线而是沿大圆滚动，小圆因此还同时作自转，当小圆沿大圆滚动1周回到原出发点时，小圆同时自转1周。当小圆在大圆内部滚动时自转的方向与滚动的转向相反，所以小圆自身转了1周。当小圆在大圆外部滚动时自转的方向与滚动的转向相同，所以小圆自身转了3周。</p>
<p>这一题非常有迷惑性，小圆在外部时其实是3圈，你可以拿个硬币试试可以把圆看成一根绳子，长绳是短绳的2倍长，假设长绳开始接口在最底下，短绳接口在长绳接口处，然后短绳开始顺时针绕，当短绳接口对着正左时，这时其实才绕了长绳的1/4，转了180 90度，所以绕一圈是270<em>4=360</em>3 。同理小圆在内部时是1圈。也可以套用下列公式： 两圆圆心距/转动者半径=转动者切另一圆时的自转数!!</p>
<p>【67】</p>
<p>40瓶，20 10 5 2 1 1=39， 这时还有一个空瓶子，先向店主借一个空瓶，换来一瓶汽水喝完后把空瓶还给店主。</p>
<p>【68】</p>
<p>一共3红4黑5白,第十个人不知道的话,可推出前9个人的所有可能情况:</p>
<p>红 黑 白</p>
<p>3 3 3</p>
<p>3 2 4</p>
<p>3 1 5</p>
<p>2 3 4</p>
<p>2 2 5</p>
<p>1 3 5</p>
<p>如果第九个人不知道的话，可推出前8个人的所有可能情况：</p>
<p>红 黑 白</p>
<p>1 2 5</p>
<p>1 3 4</p>
<p>2 1 5</p>
<p>2 2 4</p>
<p>2 3 3</p>
<p>3 1 4</p>
<p>3 2 3</p>
<p>由此类推可知，当推倒第六个人时，会发现他已经肯定知道他自己戴的是什么颜色的帽子了．</p>
<p>“有3顶黑帽子，2顶白帽子。让三个人从前到后站成一排，给他们每个人头上戴一顶帽子。每个人都看不见自己戴的帽子的颜色，却只能看见站在前面那些人的帽子颜色。（所以最后一个人可以看见前面两个人头上帽子的颜色，中间那个人看得见前面那个人的帽子颜色但看不见在他后面那个人的帽子颜色，而最前面那个人谁的帽子都看不见。现在从最后那个人开始，问他是不是知道自己戴的帽子颜色，如果他回答说不知道，就继续问他前面那个人。事实上他们三个戴的都是黑帽子，那么最前面那个人一定会知道自己戴的是黑帽子。为什么？”</p>
<p>答案是，最前面的那个人听见后面两个人都说了“不知道”，他假设自己戴的是白帽子，于是中间那个人就看见他戴的白帽子。那么中间那个人会作如下推理：“假设我戴了白帽子，那么最后那个人就会看见前面两顶白帽子，但总共只有两顶白帽子，他就应该明白他自己戴的是黑帽子，现在他说不知道，就说明我戴了白帽子这个假定是错的，所以我戴了黑帽子。”问题是中间那人也说不知道，所以最前面那个人知道自己戴白帽子的假定是错的，所以他推断出自己戴了黑帽子。</p>
<p>我们把这个问题推广成如下的形式：</p>
<p>“有若干种颜色的帽子，每种若干顶。假设有若干个人从前到后站成一排，给他们每个人头上戴一顶帽子。每个人都看不见自己戴的帽子的颜色，而且每个人都看得见在他前面所有人头上帽子的颜色，却看不见在他后面任何人头上帽子的颜色。现在从最后那个人开始，</p>
<p>问他是不是知道自己戴的帽子颜色，如果他回答说不知道，就继续问他前面那个人。一直往前问，那么一定有一个人知道自己所戴的帽子颜色。”</p>
<p>当然要假设一些条件：</p>
<p>1)首先，帽子的总数一定要大于人数，否则帽子都不够戴。</p>
<p>2)“有若干种颜色的帽子，每种若干顶，有若干人”这个信息是队列中所有人都事先知道的，而且所有人都知道所有人都知道此事，所有人都知道所有人都知道所有人都知道此事，等等等等。但在这个条件中的“若干”不一定非要具体一一给出数字来。</p>
<p>这个信息具体地可以是象上面经典的形式，列举出每种颜色帽子的数目“有3顶黑帽子，2顶白帽子，3个人”，也可以是“有红黄绿三种颜色的帽子各1顶2顶3顶，但具体不知道哪种颜色是几顶，有6个人”，甚至连具体人数也可以不知道，“有不知多少人排成一排，有黑白两种帽子，每种帽子的数目都比人数少1”，这时候那个排在最后的人并不知道自己排在最后——直到开始问他时发现在他回答前没有别人被问到，他才知道他在最后。在这个帖子接下去的部分当我出题的时候我将只写出“有若干种颜色的帽子，每种若干顶，有若干人”这个预设条件，因为这部分确定了，题目也就确定了。</p>
<p>3)剩下的没有戴在大家头上的帽子当然都被藏起来了，队伍里的人谁都不知道都剩下些什么帽子。</p>
<p>4)所有人都不是色盲，不但不是，而且只要两种颜色不同，他们就能分别出来。当然他们的视力也很好，能看到前方任意远的地方。他们极其聪明，逻辑推理是极好的。总而言之，只要理论上根据逻辑推导得出来，他们就一定推导得出来。相反地如果他们推不出自己头上帽子的颜色，任何人都不会试图去猜或者作弊偷看——不知为不知。</p>
<p>5)后面的人不能和前面的人说悄悄话或者打暗号。</p>
<p>当然，不是所有的预设条件都能给出一个合理的题目。比如有99顶黑帽子，99顶白帽子，2个人，无论怎么戴，都不可能有人知道自己头上帽子的颜色。另外，只要不是只有一种颜色的帽子，在只由一个人组成的队伍里，这个人也是不可能说出自己帽子的颜色的。</p>
<p>但是下面这几题是合理的题目：</p>
<p>1)3顶红帽子，4顶黑帽子，5顶白帽子，10个人。</p>
<p>2)3顶红帽子，4顶黑帽子，5顶白帽子，8个人。</p>
<p>3)n顶黑帽子，n-1顶白帽子，n个人（n&gt;0）。</p>
<p>4)1顶颜色1的帽子，2顶颜色2的帽子，……，99顶颜色99的帽子，100顶颜色100的帽子，共5000个人。</p>
<p>5)有红黄绿三种颜色的帽子各1顶2顶3顶，但具体不知道哪种颜色是几顶，有6个人。</p>
<p>6)有不知多少人（至少两人）排成一排，有黑白两种帽子，每种帽子的数目都比人数少1。</p>
<p>大家可以先不看我下面的分析，试着做做这几题。</p>
<p>如果按照上面3顶黑帽2顶白帽时的推理方法去做，那么10个人就可以把我们累死，别说5000个人了。但是3)中的n是个抽象的数，考虑一下怎么解决这个问题，对解决一般的问题大有好处。</p>
<p>假设现在n个人都已经戴好了帽子，问排在最后的那一个人他头上的帽子是什么颜色，什么时候他会回答“知道”？很显然，只有在他看见前面n-1个人都戴着白帽时才可能，因为这时所有的n-1顶白帽都已用光，在他自己的脑袋上只能顶着黑帽子，只要前面有一顶黑帽子，那么他就无法排除自己头上是黑帽子的可能——即使他看见前面所有人都是黑帽，他还是有可能戴着第n顶黑帽。</p>
<p>现在假设最后那个人的回答是“不知道”，那么轮到问倒数第二人。根据最后面那位的回答，他能推断出什么呢？如果他看见的都是白帽，那么他立刻可以推断出自己戴的是黑帽——要是他也戴着白帽，那么最后那人应该看见一片白帽，问到他时他就该回答“知道”了。但是如果倒数第二人看见前面至少有一顶黑帽，他就无法作出判断——他有可能戴着白帽，但是他前面的那些黑帽使得最后那人无法回答“知道”；他自然也有可能戴着黑帽。</p>
<p>这样的推理可以继续下去，但是我们已经看出了苗头。最后那个人可以回答“知道”当且仅当他看见的全是白帽，所以他回答“不知道”当且仅当他至少看见了一顶黑帽。这就是所有帽子颜色问题的关键！</p>
<p>如果最后一个人回答“不知道”，那么他至少看见了一顶黑帽，所以如果倒数第二人看见的都是白帽，那么最后那个人看见的至少一顶黑帽在哪里呢？不会在别处，只能在倒数第二人自己的头上。这样的推理继续下去，对于队列中的每一个人来说就成了：</p>
<p>“在我后面的所有人都看见了至少一顶黑帽，否则的话他们就会按照相同的判断断定自己戴的是黑帽，所以如果我看见前面的人戴的全是白帽的话，我头上一定戴着我身后那个人看见的那顶黑帽。”</p>
<p>我们知道最前面的那个人什么帽子都看不见，就不用说看见黑帽了，所以如果他身后的所有人都回答说“不知道”，那么按照上面的推理，他可以确定自己戴的是黑帽，因为他身后的人必定看见了一顶黑帽——只能是第一个人他自己头上的那顶。事实上很明显，第一个说出自己头上是什么颜色帽子的那个人，就是从队首数起的第一个戴黑帽子的人，也就是那个从队尾数起第一个看见前面所有人都戴白帽子的人。</p>
<p>这样的推理也许让人觉得有点循环论证的味道，因为上面那段推理中包含了“如果别人也使用相同的推理”这样的意思，在逻辑上这样的自指式命题有点危险。但是其实这里没有循环论证，这是类似数学归纳法的推理，每个人的推理都建立在他后面那些人的推理上，而对于最后一个人来说，他的身后没有人，所以他的推理不依赖于其他人的推理就可以成立，是归纳中的第一个推理。稍微思考一下，我们就可以把上面的论证改得适合于任何多种颜色的推论：</p>
<p>“如果我们可以从假设断定某种颜色的帽子一定会在队列中出现，从队尾数起第一个看不见这种颜色的帽子的人就立刻可以根据和此论证相同的论证来作出判断，他戴的是这种颜色的帽子。现在所有我身后的人都回答不知道，所以我身后的人也看见了此种颜色的帽子。如果在我前面我见不到此颜色的帽子，那么一定是我戴着这种颜色的帽子。”</p>
<p>当然第一个人的初始推理相当简单：“队列中一定有人戴这种颜色的帽子，现在我看不见前面有人戴这颜色的帽子，那它只能是戴在我的头上了。”</p>
<p>对于题1)事情就变得很明显，3顶红帽子，4顶黑帽子，5顶白帽子给10个人戴，队列中每种颜色至少都该有一顶，于是从队尾数起第一个看不见某种颜色的帽子的人就能够断定他自己戴着这种颜色的帽子，通过这点我们也可以看到，最多问到从队首数起的第三人时，就应该有人回答“知道”了，因为从队首数起的第三人最多只能看见两顶帽子，所以最多看见两种颜色，如果他后面的人都回答“不知道”，那么他前面一定有两种颜色的帽子，而他头上戴的一定是他看不见的那种颜色的帽子。</p>
<p>题2)也一样，3顶红帽子，4顶黑帽子，5顶白帽子给8个人戴，那么队列中一定至少有一顶白帽子，因为其它颜色加起来一共才7顶，所以队列中一定会有人回答“知道”。</p>
<p>题4)的规模大了一点，但是道理和2)完全一样。100种颜色的5050顶帽子给5000人戴，前面99种颜色的帽子数量是1 …… 99=4950，所以队列中一定有第100种颜色的帽子（至少有50顶），所以如果自己身后的人都回答“不知道”，那么那个看不见颜色100帽子的人就可以断定自己戴着这种颜色的帽子。</p>
<p>至于5)、6)“有红黄绿三种颜色的帽子各1顶2顶3顶，但具体不知道哪种颜色是几顶，有6个人”以及“有不知多少人排成一排，有黑白两种帽子，每种帽子的数目都比人数少1”，原理完全相同，我就不具体分析了。</p>
<p>最后要指出的一点是，上面我们只是论证了，如果我们可以根据各种颜色帽子的数量和队列中的人数判断出在队列中至少有一顶某种颜色的帽子，那么一定有一人可以判断出自己头上的帽子的颜色。因为如果所有身后的人都回答“不知道”的话，那个从队尾数起第一个看不见这种颜色的帽子的人就可以判断自己戴了此颜色的帽子。但是这并不是说在询问中一定是由他来回答“知道”的，因为还可能有其他的方法来判断自己头上帽子的颜色。比如说在题2)中，如果队列如下：（箭头表示队列中人脸朝的方向）</p>
<p>白白黑黑黑黑红红红白→</p>
<p>那么在队尾第一人就立刻可以回答他头上的是白帽，因为他看见了所有的3顶红帽子和4顶黑帽子，能留给他自己戴的只能是白帽子了</p>
<p>【69】</p>
<p>拿出4个, 然后按照6的倍数和另外一人分别拿球. 即</p>
<p>另外一人拿1个, 我拿5个</p>
<p>另外一人拿2个, 我拿4个</p>
<p>另外一人拿3个, 我拿3个</p>
<p>另外一人拿4个, 我拿2个</p>
<p>另外一人拿5个, 我拿1个.</p>
<p>最终100个在我手上.</p>
<p>首先拿4个 别人拿n个你就拿6－n个</p>
<p>【70】</p>
<p>1英尺（ft）=0.3048米（m）</p>
<p>1磅（lb）=0.454千克（kg）</p>
<p>通过实验得到撞破脑壳所需要的机械能是mgh=（30<em>0.454）</em>9.8<em>（20</em>0.3048）=813.669（J）对于两只山羊撞击瞬间来说，比较重的那只仅仅是站在原地，只有较轻的山羊具有速度，而题目中暗示我们，两只羊仅一次碰撞致死。现在我们只需要求得碰撞瞬间轻山羊的瞬时速度就可以了，根据机械能守恒定律:mgh=1/2(m1v^2)可以得出速度。m1是轻山羊的重量。</p>
<p>【71】</p>
<p>7两倒入11两, 再用7两倒入11两装满, 7两中剩余3两, 倒出11两, 将3两倒入11两, 用7两两次倒入11两装满, 7两中剩余6两, 将11两倒出, 将6两倒入, 然后用7两倒入11两, 剩余2两. 于是得到.</p>
<p>11,0–&gt;4,7–&gt;4,0–&gt;0,4–&gt;11,4–&gt;8,7–&gt;8,0–&gt;1,7–&gt;1,0–&gt;0,1–&gt;11,1–&gt;5,7–&gt;5,0–&gt;0,5–&gt;11,5–&gt;9,7–&gt;9,0–&gt;2,7</p>
<p>【72】</p>
<p>需要4飞机.</p>
<p>假设需要三架飞机,编号为1,2,3.</p>
<p>三架同时起飞, 飞到1/8 圈处, 1号飞机,给2号,3号,飞机各加上1/8 圈的油, 刚好飞回基地,此时1号,2号满油,继续前飞;</p>
<p>飞到2/8 圈时候,2号飞机给1号飞机加油1/8圈油量,刚好飞回基地, 3号飞机满油,继续向前飞行, 到达6/8处无油;</p>
<p>此时重复2号和三号飞机的送油.3号飞机反方向飞行到1/6圈时, 加油1/6圈给给2号飞机, 2号飞机向前飞行X圈, 则3号飞机可向前继续送油, 1/6 –2X 圈. 此时3号刚好飞回, 2号满油.当X= 1/6-2X时候获得最大. X =1/18.</p>
<p>1/6 1/18= 2/ 9. 少于1/4. 所以不能完成.</p>
<p>类比推,当为4架时, 恰好满足条件.</p>
<p>【73】</p>
<p>排列如下所示.X代表点, O代表空格.</p>
<p>X O X</p>
<p>O X O</p>
<p>X X X</p>
<p>O X O</p>
<p>X O X</p>
<p>得到10条.</p>
<p>【74】</p>
<p>我要到你的国家去,请问怎么走?然后走向路人所指方向的相反方向.</p>
<p>【75】</p>
<p>只有两次</p>
<p>假设时针的角速度是ω（ω=π/6每小时），则分针的角速度为12ω，秒针的角速度为72ω。分针与时针再次重合的时间为t，则有12ωt-ωt=2π，t=12/11小时，换算成时分秒为1小时5分27.3秒，显然秒针不与时针分针重合，同样可以算出其它10次分针与时针重合时秒针都不能与它们重合。只有在正12点和0点时才会重。</p>
<p>证明：将时针视为静止，考察分针，秒针对它的相对速度：</p>
<p>12个小时作为时间单位“1”，“圈/12小时”作为速度单位，</p>
<p>则分针速度为11，秒针速度为719。</p>
<p>由于11与719互质，记12小时/（11*719）为时间单位Δ，</p>
<p>则分针与时针重合当且仅当 t=719kΔ k∈Z</p>
<p>秒针与时针重合当且仅当 t=11jΔ j∈Z</p>
<p>而719与11的最小公倍数为11*719，所以若t=0时三针重合，则下一次三针重合</p>
<p>必然在t=11<em>719</em>Δ时，即t=12点。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/blog/images/avatar.gif"
               alt="tomoat" />
          <p class="site-author-name" itemprop="name">tomoat</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/blog/archives">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tomoat</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
