<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/blog/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="tomoat的笔记">
<meta property="og:url" content="https://tomoat.github.io/index.html">
<meta property="og:site_name" content="tomoat的笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tomoat的笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tomoat.github.io/"/>





  <title> tomoat的笔记 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">tomoat的笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/04/使用Electron构建桌面应用程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/04/使用Electron构建桌面应用程序/" itemprop="url">
                  使用Electron构建桌面应用程序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-08T23:18:21+08:00">
                2017-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>使用JavaScript，Node.js和Electron 构建您自己的声音机器的详细指南</p>
</blockquote>
<h3 id="JavaScript桌面应用程序的用途和用途"><a href="#JavaScript桌面应用程序的用途和用途" class="headerlink" title="JavaScript桌面应用程序的用途和用途"></a>JavaScript桌面应用程序的用途和用途</h3><p>桌面应用程序总是在我心中有一个特别的地方。自从浏览器和移动设备功能强大以来，桌面应用程序的稳步下降，这些应用程序正在被移动和Web应用程序所取代。尽管如此，编写桌面应用程序仍然有很多优势 - 一旦他们在开始菜单或停靠栏中，它们总是存在，它们是<em>alt（cmd）-tabbable</em>（我希望这是一个字），并且大多数与底层操作系统（其快捷方式，通知等）比Web应用程序。</p>
<p>在本文中，我将尝试引导您完成构建简单桌面应用程序的过程，并了解如何使用JavaScript构建桌面应用程序的重要概念。</p>
<p><img src="https://cdn-images-1.medium.com/max/400/1*GS-t3eNz9Jy7YWKIxxmJPg.png" alt="img"></p>
<p>​                                        GitHub Electron</p>
<p>使用JavaScript开发桌面应用程序的主要思想是您构建一个代码库，并分别为每个操作系统打包。这样可以消除构建本机桌面应用程序所需的知识，并使维护变得更简单。如今，发展与JavaScript的一个桌面应用程序依赖于任何<a href="http://electron.atom.io/" target="_blank" rel="external">电子</a>或<a href="http://nwjs.io/" target="_blank" rel="external">NW.js</a>。虽然这两种工具提供的功能或多或少相同，但我已经和Electron进行<a href="https://github.com/atom/electron/blob/master/docs/development/atom-shell-vs-node-webkit.md" target="_blank" rel="external">了交流</a>，因为它具有<a href="https://github.com/atom/electron/blob/master/docs/development/atom-shell-vs-node-webkit.md" target="_blank" rel="external">一些重要的优势</a>。在一天结束的时候，你也不会出错。</p>
<h4 id="基本假设"><a href="#基本假设" class="headerlink" title="基本假设"></a>基本假设</h4><p>我假设你已经安装了基本的文本编辑器（或IDE）和<a href="https://nodejs.org/download/" target="_blank" rel="external">Node.js / npm</a>。我也假设你有HTML / CSS / JavaScript的知识（Node.js的CommonJS模块的知识将是巨大的，但并不重要），所以我们可以专注于学习电子概念，而不用担心构建用户界面（其中，事实证明，只是普通的网页）。如果没有，你可能会感到有些失落，我建议您访问<a href="https://medium.com/@bojzi/overview-of-the-javascript-ecosystem-8ec4a0b7a7be" target="_blank" rel="external">我以前的博客帖子</a>来刷新您的基础知识。</p>
<h4 id="电子的10-000英尺视图"><a href="#电子的10-000英尺视图" class="headerlink" title="电子的10,000英尺视图"></a>电子的10,000英尺视图</h4><p>简而言之，Electron提供了使用纯JavaScript构建桌面应用程序的运行时。它的工作原理是 - Electron采用您的<em>package.json</em>文件中定义的<em>主</em>文件并执行它。这个主文件（通常命名为<em>main.js</em>）然后创建包含渲染网页的应用程序窗口，其中增加了与操作系统的本地GUI（图形用户界面）进行交互的功能。<em>**</em></p>
<p>详细来说，一旦您使用Electron启动应用<em>程序，</em>就会创建一个<em>主要的过程</em>。这个<em>主要过程</em>负责与您的操作系统的本机GUI进行交互，并创建应用程序的GUI（您的应用程序窗口）。</p>
<p><img src="https://cdn-images-1.medium.com/max/600/1*EJETq7XOPz5RVY5IfF6NIg@2x.png" alt="img"></p>
<p>纯粹启动的<em>主要过程</em>不会给您的应用<em>程序</em>的用户任何应用程序窗口。这些由主文件中的<em>主进程</em>使用称为<em>BrowserWindow</em>模块的<em>东西创建</em>。然后，每个浏览器窗口运行其自己的<em>渲染器进程</em>。这个<em>渲染器进程</em>需要一个网页（引用通常的CSS文件，JavaScript文件，图像等的HTML文件）并将其呈现在窗口中。您的网页使用<a href="https://www.chromium.org/" target="_blank" rel="external">Chromium</a>呈现，所以与标准保持非常高的兼容性。</p>
<p>例如，如果您只有一个计算器应用程序，您的<em>主要过程</em>将使用实际网页（计算器）的网页实例化一个窗口。</p>
<p>虽然说只有<em>主进程</em>与操作系统的本机GUI进行交互，但是有一些技术可以将一些工作卸载到<em>渲染器进程（</em>我们将研究如何利用这种技术构建一个特性<em>）。</em></p>
<p>的<em>主要过程</em>可以通过一系列模块的访问本地GUI <a href="https://github.com/atom/electron/tree/master/docs/api" target="_blank" rel="external">直接在电子提供</a>。您的桌面应用程序可以访问所有节点模块，如优秀的<a href="https://github.com/mikaelbr/node-notifier" target="_blank" rel="external"><em>节点通知程序</em></a>，以显示系统通知，<a href="https://www.npmjs.com/package/request" target="_blank" rel="external"><em>请求</em></a>进行HTTP呼叫等。</p>
<hr>
<h3 id="你好，世界！"><a href="#你好，世界！" class="headerlink" title="你好，世界！"></a>你好，世界！</h3><p>让我们开始一个传统的问候语，并安装所有必要的先决条件。</p>
<h4 id="随附存储库"><a href="#随附存储库" class="headerlink" title="随附存储库"></a>随附存储库</h4><p>本指南附有<a href="https://github.com/bojzi/sound-machine-electron-guide" target="_blank" rel="external">声音机教程资料库</a>。<br>使用存储库在某些点跟随或继续。克隆存储库以开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/bojzi/sound-machine-electron-guide.git</div></pre></td></tr></table></figure>
<p>然后您可以跳转到<em>sound-machine-tutorial</em>文件夹中的git标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout &lt;tag-name&gt;</div></pre></td></tr></table></figure>
<p>当代码块的代码可用时，我会通知您：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">跟随：</div><div class="line"> git checkout 00-blank-repository</div></pre></td></tr></table></figure>
<p>克隆/检出您想要的标签后，运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm安装</div></pre></td></tr></table></figure>
<p>以便您没有丢失任何Node模块。</p>
<p>如果您不能切换到另一个标签，最好只需重置存储库状态，然后执行结帐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add  - </div><div class="line">git reset --hard</div></pre></td></tr></table></figure>
<h4 id="开设店铺"><a href="#开设店铺" class="headerlink" title="开设店铺"></a>开设店铺</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">跟随标签00-blank-repository：</div><div class="line"> git checkout 00-blank-repository</div></pre></td></tr></table></figure>
<p>在项目文件夹中创建一个新的<em>package.json</em>文件，其中包含以下内容：</p>
<script src="https://gist.github.com/bojzi/8d6d0273a4a196f5e9d7.js"></script>

<p>这个准系统<em>package.json：</em></p>
<ul>
<li>设置应用程序的名称和版本，</li>
<li>让Electron知道<em>主进程</em>将要运行哪个脚本（<em>main.js</em>）和</li>
<li>设置一个有用的快捷方式 - 通过在CLI（终端或命令提示符）中运行“ <em>npm start</em> ”，可轻松运行应用程序的<em>npm</em>脚本。**</li>
</ul>
<p>现在是获得<em>电子</em>的时候了。实现这一目标的最简单方法是通过<em>npm</em>为您的操作系统安装一个预先构建的二进制文件，并将其保存为package.json中的<em>开发依赖关系（</em>由–save <em>-dev自动进行）</em>。在CLI中运行以下命令（在项目文件夹中）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm安装--save-dev电子预制</div></pre></td></tr></table></figure>
<p>预先构建的二进制码是针对正在安装的操作系统而定制的，并允许运行“ <em>npm启动</em> ”。我们正在将其安装为开发依赖关系，因为我们只需要在开发过程中。</p>
<p>也就是说，或多或少地，您开始使用<em>Electron开发</em>所需的一切。</p>
<h4 id="问候世界"><a href="#问候世界" class="headerlink" title="问候世界"></a>问候世界</h4><p>在该文件夹中创建一个<strong>应用程序</strong>文件夹和一个<em>index.html</em>文件，其内容如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好， 世界！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在项目的根目录中创建一个<em>main.js</em>文件。这就是Electron的主要进程将会启动并允许创建我们的“Hello，world！”网页的文件。创建具有以下内容的文件：</p>
<script src="https://gist.github.com/bojzi/6c63fb06d0b8b306481c.js"></script>

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Please update it, I had to do:</span></div><div class="line"><span class="meta"></span></div><div class="line">'use strict';</div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123;app, BrowserWindow&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</div><div class="line"><span class="keyword">let</span> mainWindow = <span class="literal">null</span></div><div class="line"></div><div class="line">app.on(<span class="string">'ready'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</div><div class="line">        height: <span class="number">600</span>,</div><div class="line">        width: <span class="number">800</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    mainWindow.loadURL(<span class="string">'file://'</span> + __dirname + <span class="string">'/app/index.html'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// The require line is wrong.</span></div><div class="line"><span class="comment">// It's mainWindow.loadURL, not mainWindow.loadUrl.</span></div><div class="line"><span class="comment">// I'm using Electron 1.3.4.</span></div></pre></td></tr></table></figure>
<p>没什么可怕的吧？<em>应用程序</em>模块控制您<br>的<em>应用程序</em>生命周期（例如 - 响应<em>应用程序</em>的就绪状态）<em>。</em>该<em>BrowserWindow</em>模块允许窗口创建。<br>在<em>主窗口</em>对象将是你的主应用程序窗口，并宣布为<em>无效</em>，因为窗口否则将一次JavaScript的垃圾收集踢关闭。</p>
<p>一旦<em>应用程序</em>获得<em>就绪</em>事件，我们使用<em>BrowserWindow</em>创建一个新的800像素宽和600像素高的窗口。<br>该窗口的<em>渲染器进程</em>将渲染我们的<em>index.html</em>文件。</p>
<p>运行我们的“Hello，World！”应用程序，在您的CLI中运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm start</div></pre></td></tr></table></figure>
<p>并沐浴在您的应用程序的荣耀中。</p>
<h3 id="开发一个真正的应用程序"><a href="#开发一个真正的应用程序" class="headerlink" title="开发一个真正的应用程序"></a>开发一个真正的应用程序</h3><h4 id="一台光荣的音响机器"><a href="#一台光荣的音响机器" class="headerlink" title="一台光荣的音响机器"></a>一台光荣的音响机器</h4><p>第一件事 - 首先  <em>是什么声音机器</em>？<br>声音机器是一种小型设备，当您按各种按钮，主要是卡通或反应声音时，会发出声音。这是一个有趣的小工具，以减轻办公室的情绪和一个很好的用例来开发一个桌面应用程序，因为我们将在开发过程中探索很多概念（并获得一个漂亮的声音引导）。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*El4nvvh3h3vjRgwh_wVO7A.png" alt="img"></p>
<p>我们将要构建的功能和我们将要探索的概念是：</p>
<ul>
<li>基本声音机（基本浏览器窗口实例化），</li>
<li>关闭所述声机（远程消息之间<em>主要</em>和<em>渲染过程），</em></li>
<li>播放声音而不使应用程序焦点（全局键盘快捷键），</li>
<li>创建快捷键修改键（Shift，Ctrl和Alt）的设置屏幕（将用户设置存储在主文件夹中）</li>
<li>添加托盘图标（远程创建本机GUI元素并了解菜单和托盘图标）和</li>
<li>打包您的应用程序（打包您的应用程序为Mac，Windows和Linux）。</li>
</ul>
<hr>
<h3 id="构建声音机的基本功能"><a href="#构建声音机的基本功能" class="headerlink" title="构建声音机的基本功能"></a>构建声音机的基本功能</h3><h4 id="起点和应用组织"><a href="#起点和应用组织" class="headerlink" title="起点和应用组织"></a>起点和应用组织</h4><p>在您的腰带下工作的“Hello，world！”应用程序，现在是开始构建音响机器的时候了。</p>
<p>典型的声音机器具有几行按钮，通过制作声音来响应印刷机。声音主要是卡通和/或反应（笑声，鼓掌，玻璃破碎等）。</p>
<p>这也是我们构建的第一个功能 - 响应点击的基本声音机器。</p>
<p><img src="https://cdn-images-1.medium.com/max/400/1*CsKlT-mLLFJlRoYZnAk9Tg@2x.png" alt="img"></p>
<p>基本文件和文件夹结构</p>
<p>我们的应用程序结构将非常简单。</p>
<p>在应用程序的<strong>根目录</strong>中，我们将保留<em>package.json</em>文件，<em>main.js</em>文件和我们需要的任何其他应用程序范围的文件。</p>
<p>该<strong>应用程序</strong>文件夹会将我们的各种类型的HTML文件放在像<strong>css</strong>，<strong>js</strong>，<strong>wav</strong>和<strong>img</strong>这样的文件夹中。</p>
<p>为了使事情更容易，网页设计所需的所有文件已经被包含在存储库的初始状态中。请检查标签01-start-project。如果您遵循并创建了“Hello，world！”应用程序，则必须重新设置存储库，然后执行checkout：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">If you followed along with the <span class="string">"Hello, world!"</span> example:</div><div class="line">git add -A</div><div class="line">git reset --hard</div><div class="line">Follow along with the tag 01-start-project:</div><div class="line">git checkout 01-start-project</div></pre></td></tr></table></figure>
<p>为了保持简单，我们将只有两个声音，但扩展到完整的16个声音只是一个额外的声音，额外的图标和修改<em>index.html的问题</em>。</p>
<h4 id="定义主要过程的其余部分"><a href="#定义主要过程的其余部分" class="headerlink" title="定义主要过程的其余部分"></a>定义主要过程的其余部分</h4><p>我们再来看看<em>main.js</em>来定义声音机的外观。用以下替换文件的内容：</p>
<script src="https://gist.github.com/bojzi/44b5de344405860026ea.js"></script>

<p>我们通过给它一个维度来定制我们创建的窗口，使其不可调整大小并且无框架。它将看起来像一个真正的声音机悬停在桌面上。</p>
<p>现在的问题是 - 如何移动无框窗口（没有标题栏）并关闭它？<br>我将很快谈论定制窗口（和应用程序）关闭（并介绍一种在<em>主进程</em>和<em>渲染器进程</em>之间进行通信的方式），但拖动部分很容易。如果您查看<em>index.css</em>文件（在<strong>app / css中</strong>），您将看到以下内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">html,</div><div class="line">body &#123;</div><div class="line">    ...</div><div class="line">    -webkit-app-region: drag;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>-webkit-app-region：drag; </em>允许整个<em>html</em>是一个可拖动的对象。现在有一个问题，但是您不能单击可拖动对象上的按钮。谜题的另一部分是<em>-webkit-app-region：no-drag; </em>这允许您定义不可破坏（因此可点击的元素）。请考虑以下摘录<em>index.css</em>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.button-sound &#123;</div><div class="line">    ...</div><div class="line">    -webkit-app-region: no-drag;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="在自己的窗口中显示声音机"><a href="#在自己的窗口中显示声音机" class="headerlink" title="在自己的窗口中显示声音机"></a>在自己的窗口中显示声音机</h4><p>在<em>main.js</em>现在文件可以使一个新的窗口，并显示机器声音。而且真的，如果您以<em>npm开始</em>启动您的应用<em>程序，</em>您将看到声音机器活着。现在没有什么发生，这并不奇怪，因为我们只有一个静态网页。</p>
<p>将以下内容放在<em>index.js</em>文件中（位于<strong>app / js中</strong>）以获得交互性：</p>
<script src="https://gist.github.com/bojzi/c8d21791c2ab34834aea.js"></script>

<p>这段代码很简单。我们：</p>
<ul>
<li>查询声音按钮，</li>
<li>通过读取<em>数据声音</em>属性的按钮，</li>
<li>为每个按钮添加一个背景图像</li>
<li>并为播放音频的每个按钮添加一个点击事件（使用<a href="https://developer.mozilla.org/en/docs/Web/API/HTMLAudioElement" target="_blank" rel="external">HTMLAudioElement界面</a>）</li>
</ul>
<p>通过在CLI中运行以下命令来测试应用程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm开始</div></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/800/1*Umzbl_QY7tatF_9Khm400Q@2x.png" alt="img">             </p>
<p>​                                    一个工作的声音机！</p>
<h3 id="通过远程事件从浏览器窗口关闭应用程序"><a href="#通过远程事件从浏览器窗口关闭应用程序" class="headerlink" title="通过远程事件从浏览器窗口关闭应用程序"></a>通过远程事件从浏览器窗口关闭应用程序</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Follow along with the tag 02-basic-sound-machine:</span></div><div class="line">git checkout 02-basic-sound-machine</div></pre></td></tr></table></figure>
<p>要重述 - 应用程序窗口（更准确地说，它们的<em>渲染器进程</em>）不应该与GUI进行交互（这就是关闭窗口）。在<a href="https://github.com/atom/electron/blob/master/docs/tutorial/quick-start.md" target="_blank" rel="external">官方电子快速入门指南</a>说：</p>
<blockquote>
<p>在网页中，不允许调用本机GUI相关的API，因为在网页中管理本机GUI资源非常危险，容易泄漏资源。如果要在网页中执行GUI操作，则网页的渲染器进程必须与主进程通信，以请求主进程执行这些操作。</p>
</blockquote>
<p>Electron提供用于该类型通信的<a href="https://github.com/atom/electron/blob/master/docs/api/ipc-renderer.md" target="_blank" rel="external"><em>ipc</em>（进程间通信）模块</a>。<em>ipc</em>允许订阅<em>频道</em>上的消息并向<em>通道的</em>订户发送消息。信道用于区分消息的接收者，并用字符串（例如“channel-1”，“channel-2”…）表示。消息还可以包含数据。收到消息后，用户可以通过做一些工作做出反应，甚至可以回答。消息传递的最大好处是分离问题 - <em>主进程</em>不必知道哪些<em>渲染器进程</em>有哪些或哪个发送消息。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*VkIt0RY92_fSiZDa9RC6Ng@2x.png" alt="img"></p>
<p>你有邮件。</p>
<p>这正是我们在这里做的 - 将<em>主进程</em>（<em>main.js</em>）订阅到“ <em>关闭主窗口</em> ”通道，并在有人点击关闭按钮时从<em>渲染器进程</em>（<em>index.js</em>）在该<em>通道</em>上发送消息。<em>**</em></p>
<p>将以下内容添加到<em>main.js</em>以订阅频道：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ipc = <span class="built_in">require</span>(<span class="string">'ipc'</span>);</div><div class="line"></div><div class="line">ipc.on(<span class="string">'close-main-window'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    app.quit();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在要求模块之后，在通道上订阅消息非常简单，并且涉及使用带有通道名和回调函数的<em>on（）</em>方法。</p>
<p>要在该频道上发送消息，请将以下内容添加到<em>index.js中</em>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ipC =  <span class="built_in">require</span>（<span class="string">' ipc '</span>）;</div><div class="line"></div><div class="line"><span class="keyword">var</span> closeEl =  <span class="built_in">document</span>。querySelector（<span class="string">' .close '</span>）;</div><div class="line">closeEl。addEventListener（<span class="string">' click '</span>，<span class="function"><span class="keyword">function</span>（）</span>&#123;</div><div class="line">    ipc。send（<span class="string">' close-main-window '</span>）;</div><div class="line">&#125;）;</div></pre></td></tr></table></figure>
<p>再次，我们需要<em>ipc</em>模块，并使用关闭按钮将<em>点击</em>事件绑定到元素。点击关闭按钮，我们通过<em>send（）</em>方法通过“close-main-window”通道<em>发送消息</em>。</p>
<p>还有一个可能咬你更多的细节和我们已经谈过它- <em>可点击</em>拖动领域。<em>index.css</em>必须将关闭按钮定义为不可拖动。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.settings &#123;</div><div class="line">    ...</div><div class="line">    -webkit-app-region：no-drag;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是这样，我们的应用程序现在可以通过关闭按钮关闭。通过检查事件或传递参数，通过<em>ipc进行通信</em>可能会变得复杂，我们稍后会看到一个传递参数的例子。</p>
<blockquote>
<p><a href="https://medium.com/developers-writing/building-a-desktop-application-with-electron-204203eeb658" target="_blank" rel="external">Building a desktop application with Electron – Developers Writing – Medium</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/JavaScript-中-apply-、call-的详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/JavaScript-中-apply-、call-的详解/" itemprop="url">
                  JavaScript 中 apply 、call 的详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-24T23:46:24+08:00">
                2017-03-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="apply-和-call-的区别"><a href="#apply-和-call-的区别" class="headerlink" title="apply 和 call 的区别"></a>apply 和 call 的区别</h2><p>ECMAScript 规范给所有函数都定义了 call 与 apply 两个方法，它们的应用非常广泛，它们的作用也是一模一样，只是传参的形式有区别而已。</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply( )"></a>apply( )</h3><p>apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name : <span class="string">'linxin'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">firstName, lastName</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(firstName + <span class="string">' '</span> + <span class="keyword">this</span>.name + <span class="string">' '</span> + lastName);</div><div class="line">&#125;</div><div class="line"></div><div class="line">func.apply(obj, [<span class="string">'A'</span>, <span class="string">'B'</span>]);    <span class="comment">// A linxin B</span></div></pre></td></tr></table></figure>
<p>可以看到，obj 是作为函数上下文的对象，函数 func 中 this 指向了 obj 这个对象。参数 A 和 B 是放在数组中传入 func 函数，分别对应 func 参数的列表元素。</p>
<h3 id="call"><a href="#call" class="headerlink" title="call( )"></a>call( )</h3><p>call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name: <span class="string">'linxin'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">firstName, lastName</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(firstName + <span class="string">' '</span> + <span class="keyword">this</span>.name + <span class="string">' '</span> + lastName);</div><div class="line">&#125;</div><div class="line"></div><div class="line">func.call(obj, <span class="string">'C'</span>, <span class="string">'D'</span>);       <span class="comment">// C linxin D</span></div></pre></td></tr></table></figure>
<p>对比 apply 我们可以看到区别，C 和 D 是作为单独的参数传给 func 函数，而不是放到数组中。</p>
<p>对于什么时候该用什么方法，其实不用纠结。如果你的参数本来就存在一个数组中，那自然就用 apply，如果参数比较散乱相互之间没什么关联，就用 call。</p>
<h2 id="apply-和-call-的用法"><a href="#apply-和-call-的用法" class="headerlink" title="apply 和 call 的用法"></a>apply 和 call 的用法</h2><h3 id="1-改变-this-指向"><a href="#1-改变-this-指向" class="headerlink" title="1.改变 this 指向"></a>1.改变 this 指向</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name: <span class="string">'linxin'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">func.call(obj);       <span class="comment">// linxin</span></div></pre></td></tr></table></figure>
<p>我们知道，call 方法的第一个参数是作为函数上下文的对象，这里把 obj 作为参数传给了 func，此时函数里的 this 便指向了 obj 对象。此处 func 函数里其实相当于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(obj.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-借用别的对象的方法"><a href="#2-借用别的对象的方法" class="headerlink" title="2.借用别的对象的方法"></a>2.借用别的对象的方法</h3><p>先看例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person1  = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'linxin'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Person2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.getname = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">    Person1.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person2();</div><div class="line">person.getname();       <span class="comment">// linxin</span></div></pre></td></tr></table></figure>
<p>从上面我们看到，Person2 实例化出来的对象 person 通过 getname 方法拿到了 Person1 中的 name。因为在 Person2 中，Person1.call(this) 的作用就是使用 Person1 对象代替 this 对象，那么 Person2 就有了 Person1 中的所有属性和方法了，相当于 Person2 继承了 Person1 的属性和方法。</p>
<h3 id="3-调用函数"><a href="#3-调用函数" class="headerlink" title="3.调用函数"></a>3.调用函数</h3><p>apply、call 方法都会使函数立即执行，因此它们也可以用来调用函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'linxin'</span>);</div><div class="line">&#125;</div><div class="line">func.call();            <span class="comment">// linxin</span></div></pre></td></tr></table></figure>
<h2 id="call-和-bind-的区别"><a href="#call-和-bind-的区别" class="headerlink" title="call 和 bind 的区别"></a>call 和 bind 的区别</h2><p>在 EcmaScript5 中扩展了叫 bind 的方法，在低版本的 IE 中不兼容。它和 call 很相似，接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数。 它们之间的区别有以下两点。</p>
<h3 id="1-bind-发返回值是函数"><a href="#1-bind-发返回值是函数" class="headerlink" title="1.bind 发返回值是函数"></a>1.bind 发返回值是函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name: <span class="string">'linxin'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> func1 = func.bind(obj);</div><div class="line">func1();                        <span class="comment">// linxin</span></div></pre></td></tr></table></figure>
<p>bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window。</p>
<h3 id="2-参数的使用"><a href="#2-参数的使用" class="headerlink" title="2.参数的使用"></a>2.参数的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a, b, c);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> func1 = func.bind(<span class="literal">null</span>,<span class="string">'linxin'</span>);</div><div class="line"></div><div class="line">func(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);            <span class="comment">// A B C</span></div><div class="line">func1(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);           <span class="comment">// linxin A B</span></div><div class="line">func1(<span class="string">'B'</span>, <span class="string">'C'</span>);                <span class="comment">// linxin B C</span></div><div class="line">func.call(<span class="literal">null</span>, <span class="string">'linxin'</span>);      <span class="comment">// linxin undefined undefined</span></div></pre></td></tr></table></figure>
<p>call 是把第二个及以后的参数作为 func 方法的实参传进去，而 func1 方法的实参实则是在 bind 中参数的基础上再往后排。</p>
<p>在低版本浏览器没有 bind 方法，我们也可以自己实现一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</div><div class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>,                        <span class="comment">// 保存原函数</span></div><div class="line">            context = [].shift.call(<span class="built_in">arguments</span>), <span class="comment">// 保存需要绑定的this上下文</span></div><div class="line">            args = [].slice.call(<span class="built_in">arguments</span>);    <span class="comment">// 剩余的参数转为数组</span></div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                    <span class="comment">// 返回一个新函数</span></div><div class="line">            self.apply(context,[].concat.call(args, [].slice.call(<span class="built_in">arguments</span>)));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://www.html-js.com/article/aiqianduan-%204077" target="_blank" rel="external">http://www.html-js.com/article/aiqianduan-%204077</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/LCS最长公共子序列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/LCS最长公共子序列/" itemprop="url">
                  动态规划方法（算法）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-18T11:46:54+08:00">
                2017-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>LCS（最长公共子序列）<code>O(n^2)</code>的时间复杂度,<code>O(n^2)</code>的空间复杂度；</li>
<li>与之类似但不同的最长公共子串方法。<br>最长公共子串用动态规划可实现<code>O(n^2)</code>的时间复杂度，<code>O(n^2)</code>的空间复杂度；还可以进一步优化，用后缀数组的方法优化成线性时间<code>O(nlogn)</code>；空间也可以用其他方法优化成线性。<br>3.LIS（最长递增序列）DP方法可实现<code>O(n^2)</code>的时间复杂度，进一步优化最佳可达到<code>O(nlogn)</code></li>
</ol>
<p>一些定义：<br>字符串 <code>X</code>， <code>Y</code> 长度 分别<code>m</code>，<code>n</code></p>
<p>子串：字符串S的子串<code>r[i,...,j],i&lt;=j</code>,表示<code>r</code>串从i到j这一段，也就是顺次排列<code>r[i],r[i+1],...,r[j]</code>形成的字符串</p>
<p>前缀：<code>Xi =﹤x1，⋯，xi﹥</code> 即 <code>X</code> 序列的前 <code>i</code> 个字符 <code>(1≤i≤m)</code>；<br><code>Yj=﹤y1，⋯，yj﹥</code>即 <code>Y</code> 序列的前 <code>j</code> 个字符 <code>(1≤j≤n)</code>；<br>假定 <code>Z=﹤z1，⋯，zk﹥∈LCS(X , Y)</code></p>
<p><a href="http://segmentfault.com/a/1190000002646526" target="_blank" rel="external">有关后缀数组的定义</a></p>
<h1 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>定义：<br>一个数列 S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。<br>例如：输入两个字符串 BDCABA 和 ABCBDAB，字符串 BCBA 和 BDAB 都是是它们的最长公共子序列，则输出它们的长度 4，并打印任意一个子序列. （Note: 不要求连续）</p>
<p>判断字符串相似度的方法之一 - LCS 最长公共子序列越长，越相似。</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>对于一般性的 LCS 问题（即任意数量的序列）是属于 NP-hard。但当序列的数量确定时，问题可以使用动态规划（Dynamic Programming）在多项式时间解决。可达时间复杂度：<code>O(m*n)</code><br><a href="http://www.julyedu.com/video/play/id/9" target="_blank" rel="external">July 10分钟讲LCS视频</a>，</p>
<h2 id="暴力方法"><a href="#暴力方法" class="headerlink" title="暴力方法"></a>暴力方法</h2><p><img src="https://segmentfault.com/img/bVlvzf" alt="img"></p>
<h2 id="动态规划方法"><a href="#动态规划方法" class="headerlink" title="动态规划方法"></a>动态规划方法</h2><p><strong>最优子结构性质：</strong><br>设序列 <code>X=&lt;x1, x2, …, xm&gt;</code> 和 <code>Y=&lt;y1, y2, …, yn&gt;</code> 的一个最长公共子序列 <code>Z=&lt;z1, z2, …, zk&gt;</code>，则：</p>
<ol>
<li>若 <code>xm = yn</code>，则 <code>zk = xm = yn</code> 则 <code>Zk-1</code> 是 <code>Xm-1</code> 和 <code>Yn-1</code> 的最长公共子序列；<br><img src="https://segmentfault.com/img/bVlvzm" alt="img"></li>
<li>若 <code>xm ≠ yn</code>， 要么<code>Z</code>是 <code>Xm-1</code> 和 <code>Y</code> 的最长公共子序列，要么 <code>Z</code> 是<code>X</code>和 <code>Yn-1</code> 的最长公共子序列。<br>2.1 若 <code>xm ≠ yn</code> 且 <code>zk≠xm</code> ，则 <code>Z</code>是 <code>Xm-1</code> 和 <code>Y</code> 的最长公共子序列；<br>2.2 若 <code>xm ≠ yn 且 zk ≠yn</code> ，则 <code>Z</code> 是<code>X</code>和 <code>Yn-1</code> 的最长公共子序列。<br>综合一下2 就是求二者的大者</li>
</ol>
<p><strong>递归结构：</strong><br><img src="https://segmentfault.com/img/bVlfds" alt="img"> 递归结构容易看到最长公共子序列问题具有子问题<strong>重叠性质</strong>。例如，在计算 <code>X</code> 和 <code>Y</code> 的最长公共子序列时，可能要计算出 <code>X</code> 和 <code>Yn-1</code> 及 <code>Xm-1</code> 和 <code>Y</code>的最长公共子序列。而这两个子问题都包含一个公共子问题，即计算 <code>Xm-1</code> 和 <code>Yn-1</code> 的最长公共子序列。<br><img src="https://segmentfault.com/img/bVlfdw" alt="img"></p>
<p>递归结构容易看到最长公共子序列问题具有子问题重叠性质。例如，在计算 <code>X</code> 和 <code>Y</code> 的最长公共子序列时，可能要计算出 <code>X</code> 和 <code>Yn-1</code>及 <code>Xm-1</code> 和 <code>Y</code> 的最长公共子序列。而这两个子问题都包含一个公共子问题，即计算<code>Xm-1</code> 和 <code>Yn-1</code> 的最长公共子序列。</p>
<p><strong>计算最优值：</strong><br>子问题空间中，总共只有<code>O(m*n)</code> 个不同的子问题，因此，用动态规划算法自底向上地计算最优值能提高算法的效率。</p>
<p>长度表C 和 方向变量B：<br><img src="https://segmentfault.com/img/bVlfeN" alt="img"> java实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"> /* 动态规划</div><div class="line"> * 求最长公共子序列</div><div class="line"> * @ author by gsm</div><div class="line"> * @ 2015.4.1</div><div class="line"> */</div><div class="line">import java.util.Random;</div><div class="line">public class LCS &#123;</div><div class="line"></div><div class="line">    public static int[][] lengthofLCS(char[] X, char[] Y)&#123;</div><div class="line">        /* 构造二维数组c[][]记录X[i]和Y[j]的LCS长度 (i,j)是前缀</div><div class="line">         * c[i][j]=0; 当 i = j = 0;</div><div class="line">         * c[i][j]=c[i-1][j-1]+1; 当 i = j &gt; 0; Xi == Y[i]</div><div class="line">         * c[i][j]=max(c[i-1][j],c[i][j+1]); 当 i = j &gt; 0; Xi != Y[i]</div><div class="line">         * 需要计算 m*n 个子问题的长度 即 任意c[i][j]的长度</div><div class="line">         * -- 填表过程</div><div class="line">         */</div><div class="line">        int[][]c = new int[X.length+1][Y.length+1];</div><div class="line"></div><div class="line">        // 动态规划计算所有子问题</div><div class="line">        for(int i=1;i&lt;=X.length;i++)&#123;</div><div class="line">            for (int j=1;j&lt;=Y.length;j++)&#123;</div><div class="line">                if(X[i-1]==Y[j-1])&#123;</div><div class="line">                    c[i][j] = c[i-1][j-1]+1;</div><div class="line">                &#125;</div><div class="line">                else if(c[i-1][j] &gt;= c[i][j-1])&#123;</div><div class="line">                    c[i][j] = c[i-1][j];</div><div class="line">                &#125;</div><div class="line">                else&#123;</div><div class="line">                    c[i][j] = c[i][j-1];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 打印C数组</div><div class="line">        for(int i=0;i&lt;=X.length;i++)&#123;</div><div class="line">            for (int j=0;j&lt;=Y.length;j++)&#123;</div><div class="line">                System.out.print(c[i][j]+&quot; &quot;);</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">        return c;</div><div class="line">    &#125;</div><div class="line">    // 输出LCS序列</div><div class="line">    public static void print(int[][] arr, char[] X, char[] Y, int i, int j) &#123;</div><div class="line">        if(i == 0 || j == 0)</div><div class="line">            return;</div><div class="line">        if(X[i-1] == Y[j-1]) &#123;</div><div class="line">            System.out.print(&quot;element &quot; + X[i-1] + &quot; &quot;);</div><div class="line">            // 寻找的</div><div class="line">            print(arr, X, Y, i-1, j-1);</div><div class="line">        &#125;else if(arr[i-1][j] &gt;= arr[i][j-1]) &#123;</div><div class="line">            print(arr, X, Y, i-1, j);</div><div class="line">        &#125;else&#123;</div><div class="line">            print(arr, X, Y, i, j-1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        char[] x =&#123;&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;B&apos;,&apos;D&apos;,&apos;A&apos;,&apos;B&apos;&#125;; </div><div class="line">        char[] y =&#123;&apos;B&apos;,&apos;D&apos;,&apos;C&apos;,&apos;A&apos;,&apos;B&apos;,&apos;A&apos;&#125;; </div><div class="line">        int[][] c = lengthofLCS(x,y);</div><div class="line">        print(c, x, y, x.length, y.length);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h1><h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>定义 2 个字符串 query 和 text, 如果 query 里最大连续字符子串在 text 中存在，则返回子串长度. 例如: query=”acbac”，text=”acaccbabb”， 则最大连续子串为 “cba”, 则返回长度 3.</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="时间复杂度：O-m-n-的DP"><a href="#时间复杂度：O-m-n-的DP" class="headerlink" title="时间复杂度：O(m*n)的DP"></a>时间复杂度：<code>O(m*n)</code>的DP</h3><p>这个 LCS 跟前面说的最长公共子序列的 LCS 不一样，不过也算是 LCS 的一个变体，在 LCS 中，子序列是不必要求连续的，而子串则是 “连续” 的</p>
<p>我们还是像之前一样 “从后向前” 考虑是否能分解这个问题，类似最长公共子序列的分析，这里，我们使用<code>c[i,j]</code> 表示 以 <code>Xi</code> 和 <code>Yj</code>结尾的最长公共子串的长度，<strong>因为要求子串连续，所以对于 Xi 与 Yj 来讲，它们要么与之前的公共子串构成新的公共子串；要么就是不构成公共子串。故状态转移方程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">X[i-1] == Y[j-1]，c[i,j] = c[i-1,j-1] + 1；</div><div class="line"></div><div class="line">X[i-1] != Y[j-1]，c[i,j] = 0；</div></pre></td></tr></table></figure>
<p>对于初始化，<code>i==0 或者 j==0，c[i,j] = 0</code><br>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class LCString &#123;</div><div class="line">    public  static int lengthofLCString(String X, String Y)&#123;</div><div class="line">        /* 构造二维数组c[][]记录X[i]和Y[j]的LCS长度 (i,j)是前缀</div><div class="line">         * c[i][j]=0; 当 i = j = 0;</div><div class="line">         * c[i][j]=c[i-1][j-1]+1; 当 i = j &gt; 0; Xi == Y[i]</div><div class="line">         * c[i][j]=0; 当 i = j &gt; 0; Xi != Y[i]</div><div class="line">         * 需要计算 m*n 个子问题的长度 即 任意c[i][j]的长度</div><div class="line">         * -- 填表过程</div><div class="line">         */</div><div class="line">        int[][]c = new int[X.length()+1][Y.length()+1];</div><div class="line">        int maxlen = 0;</div><div class="line">        int maxindex = 0;</div><div class="line">        for(int i =1;i&lt;=X.length();i++)&#123;</div><div class="line">            for(int j=1;j&lt;=Y.length();j++)&#123;</div><div class="line">                if(X.charAt(i-1) == Y.charAt(j-1))&#123;</div><div class="line">                    c[i][j] = c[i-1][j-1]+1;</div><div class="line">                    if(c[i][j] &gt; maxlen)</div><div class="line">                    &#123;</div><div class="line">                        maxlen = c[i][j];</div><div class="line">                        maxindex = i + 1 - maxlen;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return maxlen;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String X = &quot;acbac&quot;;</div><div class="line">        String Y = &quot;acaccbabb&quot;;</div><div class="line">        System.out.println(lengthofLCString(X,Y)); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="时间复杂度O-nlogn-的后缀数组的方法"><a href="#时间复杂度O-nlogn-的后缀数组的方法" class="headerlink" title="时间复杂度O(nlogn)的后缀数组的方法"></a>时间复杂度<code>O(nlogn)</code>的后缀数组的方法</h3><p><a href="http://segmentfault.com/a/1190000002646526" target="_blank" rel="external">有关后缀数组以及求最长重复子串</a><br>前面提过后缀数组的基本定义，与子串有关，可以尝试这方面思路。由于后缀数组最典型的是寻找一个字符串的重复子串，所以，对于两个字符串，我们可以将其连接到一起，如果某一个子串 s 是它们的公共子串，则 s 一定会在连接后字符串后缀数组中出现两次，这样就将最长公共子串转成最长重复子串的问题了，这里的后缀数组我们使用基本的实现方式。</p>
<p>值得一提的是，在找到两个重复子串时，不一定就是 X 与 Y 的公共子串，也可能是 X 或 Y 的自身重复子串，故在连接时候我们在 X 后面插入一个特殊字符‘#’，即连接后为 X#Y。这样一来，只有找到的两个重复子串恰好有一个在 #的前面，这两个重复子串才是 X 与 Y 的公共子串</p>
<h3 id="各方案复杂度对比"><a href="#各方案复杂度对比" class="headerlink" title="各方案复杂度对比"></a>各方案复杂度对比</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">设字符串 X 的长度为 m，Y 的长度为 n，最长公共子串长度为 l。</div><div class="line"></div><div class="line">对于基本算法（brute force），X 的子串（m 个）和 Y 的子串（n 个）一一对比，最坏情况下，复杂度为 O(m*n*l)，空间复杂度为 O(1)。</div><div class="line"></div><div class="line">对于 DP 算法，由于自底向上构建最优子问题的解，时间复杂度为 O(m*n)；空间复杂度为 O(m*n)，当然这里是可以使用滚动数组来优化空间的，滚动数组在动态规划基础回顾中多次提到。</div><div class="line"></div><div class="line">对于后缀数组方法，连接到一起并初始化后缀数组的时间复杂度为 O(m+n)，对后缀数组的字符串排序，由于后缀数组有 m+n 个后缀子串，子串间比较，故复杂度为 O((m+n)*l*lg(m+n))，求得最长子串遍历后缀数组，复杂度为 O(m+n)，所以总的时间复杂度为 O((m+n)*l*lg(m+n))，空间复杂度为 O(m+n)。</div><div class="line"></div><div class="line">总的来说使用后缀数组对数据做一些 “预处理”，在效率上还是能提升不少的。</div></pre></td></tr></table></figure>
<h1 id="LIS-最长递增子序列"><a href="#LIS-最长递增子序列" class="headerlink" title="LIS 最长递增子序列"></a>LIS 最长递增子序列</h1><p>问题描述：找出一个n个数的序列的最长单调递增子序列： 比如<code>A = {5,6,7,1,2,8}</code> 的LIS是<code>5,6,7,8</code></p>
<h2 id="1-O-n-2-的复杂度："><a href="#1-O-n-2-的复杂度：" class="headerlink" title="1. O(n^2)的复杂度："></a>1. <code>O(n^2)</code>的复杂度：</h2><p><strong>1.1 最优子结构：</strong><br><code>LIS[i]</code> 是以<code>arr[i]</code>为末尾的LIS序列的长度。则：<br><code>LIS[i] = {1+Max(LIS(j))}</code>; <code>j&lt;i, arr[j]&lt;arr[i]</code>;<br><code>LIS[i] = 1, j&lt;i</code>, 但是不存在<code>arr[j]&lt;arr[i]</code>;<br>所以问题转化为计算<code>Max(LIS(j))</code> <code>0&lt;i&lt;n</code></p>
<p><strong>1.2 重叠的子问题：</strong><br>以<code>arr[i] (1&lt;= i &lt;= n)</code>每个元素结尾的LIS序列的值是 重叠的子问题。<br>所以填表时候就是建立一个数组<code>DP[i]</code>, 记录以<code>arr[i]</code>为序列末尾的LIS长度。</p>
<p><strong>1.3 DP[i]怎么计算？</strong><br>遍历所有<code>j&lt;i</code>的元素，检查是否<code>DP[j]+1&gt;DP[i] &amp;&amp; arr[j]&lt;arry[i]</code> 若是，则可以更新<code>DP[i]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">int maxLength = 1, bestEnd = 0;</div><div class="line">DP[0] = 1;</div><div class="line">prev[0] = -1;</div><div class="line"></div><div class="line">for (int i = 1; i &lt; N; i++)</div><div class="line">&#123;</div><div class="line">   DP[i] = 1;</div><div class="line">   prev[i] = -1;</div><div class="line"></div><div class="line">   for (int j = i - 1; j &gt;= 0; j--)</div><div class="line">      if (DP[j] + 1 &gt; DP[i] &amp;&amp; array[j] &lt; array[i])</div><div class="line">      &#123;</div><div class="line">         DP[i] = DP[j] + 1;</div><div class="line">         prev[i] = j;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">   if (DP[i] &gt; maxLength)</div><div class="line">   &#123;</div><div class="line">      bestEnd = i;</div><div class="line">      maxLength = DP[i];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="2-O-nlog-的复杂度"><a href="#2-O-nlog-的复杂度" class="headerlink" title="2. O(nlog)的复杂度"></a>2. <code>O(nlog)</code>的复杂度</h2><p><strong>基本思想：</strong></p>
<p>首先通过一个数组<code>MaxV[nMaxLength]</code>来缓存递增子序列LIS的<code>末尾元素</code>最小值；通过<code>nMaxLength</code> 记录到当前遍历为止的最长子序列的长度;</p>
<p>然后我们从第2元素开始，遍历给定的数组<code>arr</code>，</p>
<ol>
<li><code>arr[i] &gt; MaxV[nMaxLength]</code>, 将<code>arr[i]</code>插入到<code>MaxV[++nMaxLength]</code>的末尾 – 意味着我们找到了一个新的最大LIS</li>
<li><code>arr[i] &lt;= MaxV[nMaxLength]</code>, 找到<code>MaxV[]</code>中刚刚大于<code>arr[i]</code>的元素，<code>arr[j]</code>.<code>arr[i]替换arr[j]</code><br>因为MaxV是一个有序数组，查找过程可以使用<code>log(N)</code>的折半查找。<br>这样运行时间: <code>n</code>个整数和每个都需要折半查找 – <code>n*logn = O(nlogn)</code></li>
</ol>
<ul>
<li><code>if &gt;</code> 说明<code>j</code>能够放在最长子序列的末尾形成一个新的最长子序列.</li>
<li><code>if&lt;</code> 说明<code>j</code>需要<code>替换</code>前面一个<code>刚刚大</code>与<code>array[j]</code>的元素</li>
</ul>
<p>最后，输出LIS时候，我们会用一个<code>LIS[]</code>数组，这边<code>LIS[i]</code>记录的是以元素<code>arr[i]</code>为结尾的最长序列的长度</p>
<hr>
<p><strong>初始化准备工作：</strong></p>
<p><code>MaxV[1]</code>首先会被设置成序列第一个元素 即 <code>MaxV[1] = arr[0]</code>，在遍历数组的过程中会不断的更新。<br><code>nMaxLength = 1</code></p>
<hr>
<p><strong>举个栗子：</strong><br><code>arr = {2 1 5 3 6 4 8 9 7}</code></p>
<ul>
<li>首先<code>i=1</code>, 遍历到1， 1 通过跟MaxV[nMaxLength]比较: <code>1&lt;MaxV[nMaxLength]</code>,<br>发现1更有<code>潜力</code>（更小的有潜力，更小的替换之）<br>1 更有潜力, 那么<code>1</code>就<code>替换MaxV[nMaxLength]</code> 即 <code>MaxV[nMaxLength] =1</code> ;<br>这个时候 <code>MaxV={1}， nMaxlength = 1，LIS[1] = 1</code>;</li>
<li>然后 <code>i =2</code>, 遍历到5， 5通过跟<code>MaxV[nMaxLength]</code>比较, <code>5&gt;MaxV[nMaxLength]</code>,<br>发现5 <code>更大</code>； 链接到目前得到的LIS尾部；<br>这个时候 <code>MaxV={1，5}</code>， <code>nMaxlength++ = 2</code>， <code>MaxV[nMaxLength]=5</code>， <code>LIS[i] = 1+1 = 2</code>;</li>
<li>然后 <code>i =3</code>，遍历到3, 3 通过跟MaxV[nMaxLength]比较, <code>3&lt;MaxV[nMaxLength]</code>,<br>发现3更有 <code>潜力</code>，然后从 <code>nMaxLength</code>往前比较，找到第一个刚刚比3大元素替换之。（稍后解释什么叫刚刚大）<br>这个时候 <code>MaxV={1,3}， nMaxlength = 2</code>; 3只是替换， <code>LIS[i]不变 = LIS[3]= 2</code>;</li>
<li>然后 <code>i =4</code>，遍历到6， 6 通过跟 <code>MaxV[nMaxLength]</code>比较, <code>6&gt;MaxV[nMaxLength]</code>,<br>发现6更大； 6就应该链接到目前得到的LIS尾部；<br>这个时候，<code>MaxV={1,3,6} ，nMaxlength = 3</code>，<code>MaxV[nMaxLength+1]=6 , LIS[4] = 3</code></li>
<li>然后<code>i =5</code>，遍历到4, 4 通过跟<code>MaxV[nMaxLength] = 6</code>比较, <code>4&lt;MaxV[nMaxLength]</code>,<br>发现4更有<code>潜力</code>，然后从<code>nMaxLength</code>往前比较，找到刚刚比4大元素 也就是 6替换之。<br>这个时候 <code>MaxV={1,3,4}， nMaxlength = 3</code>，4只是替换， <code>LIS[i]不变 = LIS[5]= 3</code>;</li>
<li>然后<code>i=6</code>, 遍历到8， 8通过跟<code>MaxV[nMaxLength]</code>比较, <code>8&gt;MaxV[nMaxLength]</code>,<br>发现8<code>更大</code>； 8就应该链接到目前得到的LIS尾部；<br>这个时候 <code>MaxV={1,3,4,8}， nMaxlength = 4, Maxv[nMaxlength]=8 LIS[6]=4</code>,</li>
<li>然后<code>i=7</code>, 遍历到9， 9通过跟<code>MaxV[nMaxLength]</code>比较, <code>9&gt;MaxV[nMaxLength]</code>,<br>发现9<code>更大</code>； 9就应该链接到目前得到的LIS尾部；<br>这个时候 <code>MaxV={1,3,4,8，9}， nMaxlength = 5, Maxv[nmaxlength]=9, LIS[7] = 5;</code></li>
<li>然后<code>i=8</code>, 遍历到7, 7 通过跟<code>MaxV[nMaxLength] = 9</code>比较, <code>7&lt;MaxV[nMaxLength]</code>,<br>发现7更有<code>潜力</code>，然后从<code>nMaxLength</code>往前比较，找到第一个比7大元素 也就是 8替换之。<br>这个时候 <code>MaxV={1,3,4,7,9}</code>, <code>nMaxLength = 5, Maxv[nMaxlength]=9</code><br><code>LIS[8] = LIS[替换掉的index] = 4</code>;</li>
</ul>
<table>
<thead>
<tr>
<th>–</th>
<th>2</th>
<th>1</th>
<th>5</th>
<th>3</th>
<th>6</th>
<th>4</th>
<th>8</th>
<th>9</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td>LIS</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>MaxV</td>
<td>2</td>
<td>1</td>
<td>1,5</td>
<td>1,3</td>
<td>1,3,6</td>
<td>1,3,4</td>
<td>1,3,4,8</td>
<td>1,3,4,8,9</td>
<td>1,3,4,7</td>
</tr>
</tbody>
</table>
<p>java实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class LIS &#123;</div><div class="line">    public static int lengthofLCS(int[] arr)&#123;</div><div class="line">        // 辅助变量</div><div class="line">        int[] MaxV = new int [arr.length+1]; // 记录递增子序列 LIS 的末尾元素最小值 </div><div class="line">        int nMaxLength = 1; // 当前LIS的长度</div><div class="line">        int [] LIS = new int[arr.length+1]; //LIS[i]记录的是以第i个元素为结尾的最长序列的长度</div><div class="line">        // 初始化</div><div class="line">        MaxV[0] = -100;</div><div class="line">        MaxV[nMaxLength] = arr[0];</div><div class="line">        LIS[0] = 0;LIS[1] = 1;</div><div class="line"></div><div class="line">        for(int i=1;i&lt;arr.length;i++)&#123;</div><div class="line">            if(arr[i] &gt;MaxV[nMaxLength])&#123;</div><div class="line">                MaxV[++nMaxLength] = arr[i];</div><div class="line">                LIS[i] = LIS[i-1]+1;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                // 新元素 更小，更有“潜力”，替换大的元素</div><div class="line">                int index = binarySearch(MaxV,arr[i],0,nMaxLength);     </div><div class="line">                //*     </div><div class="line">                LIS[i] =index;</div><div class="line">                MaxV[index] = arr[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(LIS);</div><div class="line">        return LIS[LIS.length-1];</div><div class="line">    &#125;</div><div class="line">    // 在MaxV数组中查找一个元素刚刚大于arr[i]</div><div class="line">    // 返回这个元素的index</div><div class="line">    public static int binarySearch(int []arr, int n, int start, int end)&#123;</div><div class="line">        while(start&lt;end)&#123;</div><div class="line">            int mid = (start + end)/2;</div><div class="line">            if(arr[mid]&lt; n)&#123;</div><div class="line">                start = mid+1;</div><div class="line">            &#125;</div><div class="line">            else if(arr[mid]&gt; n) &#123;</div><div class="line">                end = mid -1;</div><div class="line">            &#125;</div><div class="line">            else </div><div class="line">                return mid;</div><div class="line">        &#125;</div><div class="line">        return end;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int[] arr = &#123;2,1,5,3,6,4,8,9,7&#125;;</div><div class="line">        System.out.println(lengthofLCS(arr));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>* : MaxV里面的数组下标代表了长度为index的最长子序列末尾元素，反过来就是末尾元素在MaxV里对应的下标就是他子序列的长度</p>
<hr>
<h1 id="可以转化为LCS的问题"><a href="#可以转化为LCS的问题" class="headerlink" title="可以转化为LCS的问题"></a>可以转化为LCS的问题</h1><ul>
<li>给一个字符串，求这个字符串最少增加几个字符能变成回文</li>
<li>要在一条河的南北两边的各个城市之间造若干座桥．桥两边的城市分别是 a(1)…a(n) 和 b(1)…b(n). 且南边 a(1)…a(n) 是乱序的，北边同理，但是要求 a(i) 只可以和 b(i) 之间造桥, 同时两座桥之间不能交叉. 希望可以得到一个尽量多座桥的方案.</li>
</ul>
<hr>
<p>总结：</p>
<p>- 通常DP是一个不算最好，但是比最直接的算法好很多的方法。 DP一般是O（n^2）;但是如果想进一步优化 O（nlogn）就要考虑其他的了</p>
<p>- 对，要想更好的方法就是要挖掘题目本身更加隐匿的性质了</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000002641054" target="_blank" rel="external">算法设计 - LCS 最长公共子序列&amp;&amp;最长公共子串 &amp;&amp;LIS 最长递增子序列</a></p>
<p><a href="http://segmentfault.com/blog/exploring/" target="_blank" rel="external">http://segmentfault.com/blog/exploring/</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/在Node.js中查找JavaScript内存泄漏简略指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/在Node.js中查找JavaScript内存泄漏简略指南/" itemprop="url">
                  在Node.js中查找JavaScript内存泄漏简略指南
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-16T16:07:25+08:00">
                2017-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#intro" target="_blank" rel="external">介绍</a></li>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#min-theory" target="_blank" rel="external">最小理论</a></li>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#reproduce" target="_blank" rel="external">步骤1.重现并确认问题</a></li>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#heapdump" target="_blank" rel="external">第2步。至少取3堆堆</a></li>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#find-problem" target="_blank" rel="external">步骤3.查找问题</a></li>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#confirm" target="_blank" rel="external">步骤4.确认问题已解决</a></li>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#links" target="_blank" rel="external">链接到一些其他资源</a></li>
<li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/#summary" target="_blank" rel="external">概要</a></li>
</ul>
<blockquote>
<p>你可能想要的书签：简单指南查找JavaScript内存泄漏在Node.js由<a href="https://twitter.com/akras14" target="_blank" rel="external">@ akras14 </a><a href="https://t.co/oRyQboa8Uw" target="_blank" rel="external">https://t.co/oRyQboa8Uw</a></p>
<p>- Node.js（@nodejs）<a href="https://twitter.com/nodejs/status/684678799896625152" target="_blank" rel="external">2016年1月6日</a></p>
</blockquote>
<p>请考虑<a href="https://www.alexkras.com/recommends/kindle-memory-leak" target="_blank" rel="external">在亚马逊上查看本指南</a>，如果你会发现它有所帮助。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>几个月前，我不得不调试Node.js中的内存泄漏。我发现了很多文章专门的主题，但即使仔细阅读其中一些，我仍然很困惑，我究竟应该做什么来调试我们的问题。</p>
<p>我的目的是这个职位是一个简单的指南，在节点中查找内存泄漏。我将概述一个易于遵循的方法，应该（在我看来）成为任何内存泄漏调试在节点的起点。在某些情况下，这种方法可能不够。我将链接到您可能想要考虑的一些其他资源。</p>
<h2 id="最小理论"><a href="#最小理论" class="headerlink" title="最小理论"></a>最小理论</h2><p>JavaScript是一种垃圾收集语言。因此，Node进程使用的所有内存都由V8 JavaScript引擎自动分配和取消分配。</p>
<p>V8如何知道何时解除分配内存？V8保留程序中所有变量的图形，从根节点开始。JavaScript中有4种类型的数据类型：Boolean，String，Number和Object。前3个是简单类型，它们只能保留分配给它们的数据（即文本字符串）。对象和JavaScript中的一切都是一个对象（即数组是对象），可以保持引用（指针）到其他对象。</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/memory-graph.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/memory-graph.png" alt="内存图"></a></p>
<p>周期性地，V8将遍历存储器图，尝试识别从根节点不再能够到达的数据组。如果从根节点无法访问，V8假定数据不再使用并释放内存。这个过程称为<strong>垃圾收集</strong>。</p>
<h3 id="什么时候发生内存泄漏？"><a href="#什么时候发生内存泄漏？" class="headerlink" title="什么时候发生内存泄漏？"></a>什么时候发生内存泄漏？</h3><p>当一些不再需要的数据仍然可以从根节点到达时，在JavaScript中发生内存泄漏。V8将假设数据仍在使用，并且不会释放内存。<strong>为了调试内存泄漏，我们需要找到错误保存的数据，并确保V8能够清理它。</strong></p>
<p>还有一点很重要，要注意的是，垃圾回收不会一直运行。通常V8可以在认为合适时触发垃圾收集。例如，它可以定期运行垃圾收集，或者它可以触发垃圾收集，如果它感测到可用内存量越来越低。节点对每个进程可用的内存数量有限，因此V8必须明智地使用它。</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/node-error.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/node-error.png" alt="节点错误"></a></p>
<p>后来的情况下，<strong>垃圾收集</strong>可能是<strong>性能明显下降的来源</strong>。</p>
<p>想象一下，你有一个应用程序有很多内存泄漏。很快，Node进程会开始耗尽内存，这将导致V8触发一个无法回收的垃圾收集。但是由于大多数数据仍然可以从根节点到达，非常少的内存将被清理，保持大部分的位置。</p>
<p>比以后更快，Node进程会再次运行内存，触发另一个垃圾收集。在你知道它之前，你的应用程序进入一个不断的垃圾收集周期，只是为了保持过程的功能。由于V8花费大部分时间来处理垃圾收集，因此只剩下很少的资源来运行实际程序。</p>
<h2 id="步骤1-重现并确认问题"><a href="#步骤1-重现并确认问题" class="headerlink" title="步骤1.重现并确认问题"></a>步骤1.重现并确认问题</h2><p>正如我前面指出的，V8 JavaScript引擎有一个复杂的逻辑，它用于确定何时运行垃圾收集。记住这一点，即使我们可以看到Node进程的内存继续上升，<strong>我们不能确定我们目睹了内存泄漏，直到我们知道Garbage Collection已经运行</strong>，允许未使用的内存被清除。</p>
<p>幸运的是，Node允许我们手动触发垃圾收集，这是我们在尝试确认内存泄漏时应该做的第一件事。这可以通过运行带有<code>--expose-gc</code>标志（ie <code>node --expose-gc index.js</code>）的Node来实现。一旦节点在该模式下运行，您可以随时通过<code>global.gc()</code>从您的程序调用来以编程方式触发垃圾收集。</p>
<p>您还可以通过调用来检查进程使用的内存量<code>process.memoryUsage().heapUsed</code>。</p>
<p><strong>通过手动触发垃圾收集和检查使用的堆，你可以确定你是否实际上观察你的程序中的内存泄漏。</strong></p>
<h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><p>我创建了一个简单的内存泄漏程序，你可以在这里看到：<a href="https://github.com/akras14/memory-leak-example" target="_blank" rel="external">https</a> : <a href="https://github.com/akras14/memory-leak-example" target="_blank" rel="external">//github.com/akras14/memory-leak-example</a></p>
<p>您可以克隆它，运行<code>npm install</code>，然后运行<code>node --expose-gc index.js</code>以查看它的操作。</p>
<table>
<thead>
<tr>
<th>12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849</th>
<th>“use strict”;require(‘heapdump’); var leakyData = [];var nonLeakyData = []; class SimpleClass {  constructor(text){    this.text = text;  }} function cleanUpData(dataStore, randomObject){  var objectIndex = dataStore.indexOf(randomObject);  dataStore.splice(objectIndex, 1);} function getAndStoreRandomData(){  var randomData = Math.random().toString();  var randomObject = new SimpleClass(randomData);   leakyData.push(randomObject);  nonLeakyData.push(randomObject);   // cleanUpData(leakyData, randomObject); //&lt;– Forgot to clean up  cleanUpData(nonLeakyData, randomObject);} function generateHeapDumpAndStats(){  //1. Force garbage collection every time this function is called  try {    global.gc();  } catch (e) {    console.log(“You must run program with ‘node –expose-gc index.js’ or ‘npm start’”);    process.exit();  }   //2. Output Heap stats  var heapUsed = process.memoryUsage().heapUsed;  console.log(“Program is using “ + heapUsed + “ bytes of Heap.”)   //3. Get Heap dump  process.kill(process.pid, ‘SIGUSR2’);} //Kick off the programsetInterval(getAndStoreRandomData, 5); //Add random data every 5 millisecondssetInterval(generateHeapDumpAndStats, 2000); //Do garbage collection and heap dump every 2 seconds</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>程序将：</p>
<ol>
<li>每5毫秒生成一个随机对象并将其存储在2个数组中，一个名为<em>leakyData</em>和另一个<em>nonLeakyData</em>。我们将每5毫秒清除nonLeakyData数组，但是我们会<strong>“忘记”</strong>清理leakyData数组。</li>
<li>每2秒，程序将输出所使用的内存量（并生成堆转储，但我们将在下一节中讨论更多）。</li>
</ol>
<p>如果用<code>node --expose-gc index.js</code>（或<code>npm start</code>）运行程序，它将开始输出内存统计信息。让它运行一两分钟，并杀死它<code>Ctr + c</code>。</p>
<p>你会看到内存快速增长，即使我们每2秒触发一次垃圾收集，在我们得到统计数据之前：</p>
<table>
<thead>
<tr>
<th>123456789101112</th>
<th>//1. Force garbage collection every time this function is calledtry {  global.gc();} catch (e) {  console.log(“You must run program with ‘node –expose-gc index.js’ or ‘npm start’”);  process.exit();} //2. Output Heap statsvar heapUsed = process.memoryUsage().heapUsed;console.log(“Program is using “ + heapUsed + “ bytes of Heap.”)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>使用stats输出看起来像下面：</p>
<table>
<thead>
<tr>
<th>12345678910111213141516</th>
<th>Program is using 3783656 bytes of Heap.Program is using 3919520 bytes of Heap.Program is using 3849976 bytes of Heap.Program is using 3881480 bytes of Heap.Program is using 3907608 bytes of Heap.Program is using 3941752 bytes of Heap.Program is using 3968136 bytes of Heap.Program is using 3994504 bytes of Heap.Program is using 4032400 bytes of Heap.Program is using 4058464 bytes of Heap.Program is using 4084656 bytes of Heap.Program is using 4111128 bytes of Heap.Program is using 4137336 bytes of Heap.Program is using 4181240 bytes of Heap.Program is using 4207304 bytes of Heap.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>如果你绘制数据，内存增长变得更加明显。</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/with-memory-leak.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/with-memory-leak.png" alt="带内存泄漏"></a></p>
<p><em>注意：如果你好奇我如何绘制数据，请继续阅读。如果没有，请跳到下一节。</em></p>
<p>我将输出的统计信息保存到一个JSON文件中，然后读入它并用几行Python绘制它。我把它保持在单独的早午餐以避免混乱，但你可以在这里查看：<a href="https://github.com/akras14/memory-leak-example/tree/plot" target="_blank" rel="external">https</a>：<a href="https://github.com/akras14/memory-leak-example/tree/plot" target="_blank" rel="external">//github.com/akras14/memory-leak-example/tree/plot</a></p>
<p>相关部分为：</p>
<table>
<thead>
<tr>
<th>1234567891011121314151617181920212223</th>
<th>var fs = require(‘fs’);var stats = []; //— skip — var heapUsed = process.memoryUsage().heapUsed;stats.push(heapUsed); //— skip — //On ctrl+c save the stats and exitprocess.on(‘SIGINT’, function(){  var data = JSON.stringify(stats);  fs.writeFile(“stats.json”, data, function(err) {    if(err) {      console.log(err);    } else {      console.log(“\nSaved stats to stats.json”);    }    process.exit();  });});</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>和</p>
<table>
<thead>
<tr>
<th>1234567891011121314</th>
<th>#!/usr/bin/env python import matplotlib.pyplot as pltimport json statsFile = open(‘stats.json’, ‘r’)heapSizes = json.load(statsFile) print(‘Plotting %s’ % ‘, ‘.join(map(str, heapSizes))) plt.plot(heapSizes)plt.ylabel(‘Heap Size’)plt.show()</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>你可以检查出<a href="https://github.com/akras14/memory-leak-example/tree/plot" target="_blank" rel="external">plot</a>分支，并像往常一样运行程序。一旦你完成运行<code>python plot.py</code>生成情节。您需要在您的机器上安装<a href="http://matplotlib.org/" target="_blank" rel="external">Matplotlib</a>库才能正常工作。</p>
<p>或者可以在Excel中绘制数据。</p>
<h2 id="第2步。至少取3堆堆"><a href="#第2步。至少取3堆堆" class="headerlink" title="第2步。至少取3堆堆"></a>第2步。至少取3堆堆</h2><p>好了，所以我们重现了问题，现在是什么？现在我们需要弄清楚问题在哪里，并解决它</p>
<p>您可能已经注意到我的示例程序中的以下行：</p>
<table>
<thead>
<tr>
<th>12345678</th>
<th>require(‘heapdump’);// —skip— //3. Get Heap dumpprocess.kill(process.pid, ‘SIGUSR2’); // —skip—</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>我使用一个node-heapdump模块，你可以在这里找到：<a href="https://github.com/bnoordhuis/node-heapdump" target="_blank" rel="external">https</a> : <a href="https://github.com/bnoordhuis/node-heapdump" target="_blank" rel="external">//github.com/bnoordhuis/node-heapdump</a></p>
<p>为了使用node-heapdump，你只需要：</p>
<ol>
<li>安装它。</li>
<li>要求它在你的程序的顶部</li>
<li><code>kill -USR2 </code>在Unix上调用像平台</li>
</ol>
<p>如果你从来没有看到该<code>kill</code>部分，它是Unix中的一个命令，它允许你（除了别的以外）发送一个自定义信号（aka User Signal）给任何正在运行的进程。Node-heapdump配置为进行进程的堆转储，任何时候它接收<strong>用户信号两个</strong>因此<code>-USR2</code>，后跟进程id。</p>
<p>在我的示例程序中，我<code>kill -USR2 </code>通过运行自动化命令<code>process.kill(process.pid, &#39;SIGUSR2&#39;);</code>，其中<code>process.kill</code>是一个<code>kill</code>命令的节点包装器，<code>SIGUSR2</code>是Node的说法<code>-USR2</code>，并<code>process.pid</code>获取当前Node进程的ID。我在每个垃圾收集之后运行此命令以获得干净的堆转储。</p>
<p>我不认为<code>process.kill(process.pid, &#39;SIGUSR2&#39;);</code>会在Windows上工作，但你可以运行<code>heapdump.writeSnapshot()</code>。</p>
<p>这个例子可能会更容易一些<code>heapdump.writeSnapshot()</code>，但是我想提一提的是，你可以<code>kill -USR2 </code>在Unix上像平台一样触发堆 信号，这样可以派上用场。</p>
<p>下一节将讨论如何使用生成的堆转储来隔离内存泄漏。</p>
<h2 id="步骤3-查找问题"><a href="#步骤3-查找问题" class="headerlink" title="步骤3.查找问题"></a>步骤3.查找问题</h2><p>在第2步中，我们生成了一堆堆转储，但<strong>我们至少需要3个</strong>，你很快就会明白为什么。</p>
<p>一旦你有你的堆转储。转到Google Chrome浏览器，打开Chrome开发工具（Windows上为F12或Mac上为Command + Options + i）。</p>
<p>一旦进入开发工具导航到“配置文件”选项卡，选择屏幕底部的“加载”按钮，导航到您采取的第一个堆转储，并选择它。堆转储将加载到Chrome视图中，如下所示：</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/1st-Heap-Dump.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/1st-Heap-Dump.png" alt="第一堆"></a></p>
<p>继续加载2个堆转储到视图中。例如，您可以使用您所采取的最后2个堆转储。最重要的是，堆转储必须按照它们被采用的顺序加载。您的“配置文件”选项卡应类似于以下内容。</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/3-Heap-Dumps.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/3-Heap-Dumps.png" alt="3堆堆"></a></p>
<p>从上面的图像可以看出，堆随着时间的推移继续增长。</p>
<h3 id="3堆倾销法"><a href="#3堆倾销法" class="headerlink" title="3堆倾销法"></a>3堆倾销法</h3><p>一旦堆转储被加载，您将在“个人档案”选项卡中看到很多子视图，并且很容易丢失它们。然而，有一种观点，我发现特别有帮助。</p>
<p>点击你已经采取的最后一个堆转储，它会立即将你进入“摘要”视图。在“摘要”下拉列表的左侧，您应该会看到另一个显示“全部”的下拉菜单。点击它并选择“在heapdump-YOUR-FIRST-HEAP-DUMP和heapdump-YOUR-SECOND-TO-LAST-HEAP-DUMP之间分配的对象”，如下图所示。</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/3-Heap-Dump-View.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/3-Heap-Dump-View.png" alt="3堆堆视图"></a></p>
<p>它将显示有时在您的第一个堆转储和第二个到最后一个堆转储之间分配的所有对象。这些事情，这些对象仍然挂在你的最后堆转储是引起关注，应该调查，因为他们应该被拾起由垃圾收集。</p>
<p>相当惊人的东西实际上，但不是很直观，发现和容易忽视。</p>
<h3 id="忽略括号中的任何内容，例如（字符串），至少在开头"><a href="#忽略括号中的任何内容，例如（字符串），至少在开头" class="headerlink" title="忽略括号中的任何内容，例如（字符串），至少在开头"></a>忽略括号中的任何内容，例如（字符串），至少在开头</h3><p>完成示例应用程序的概述步骤后，我结束了以下视图。</p>
<p>注意，<strong>浅尺寸</strong>表示对象本身的大小，而<strong>保留尺寸</strong>表示对象的尺寸和它的所有子。</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/memory-leak.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/memory-leak.png" alt="内存泄漏"></a></p>
<p>似乎有5个条目保留在我上次的快照，应该不存在：（数组），（编译代码），（字符串），（系统）和SimpleClass。</p>
<p>其中只有<strong>SimpleClass</strong>看起来很熟悉，因为它来自示例应用程序中的以下代码。</p>
<table>
<thead>
<tr>
<th>12</th>
<th>var randomObject = new SimpleClass(randomData);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>可能很有可能先通过（数组）或（字符串）条目开始查找。摘要视图中的所有对象按其构造函数名称分组。在数组或字符串的情况下，这些是JavaScript引擎内部的构造函数。虽然你的程序肯定坚持通过这些构造函数创建的一些数据，你也会在那里得到很多噪音，使得更难找到内存泄漏的来源。</p>
<p>这就是为什么最好跳过这些，而是看看你是否可以发现任何更明显的嫌疑犯，如示例应用程序中的<strong>SimpleClass</strong>构造函数。</p>
<p>单击SimpleClass构造函数中的下拉箭头，并从结果列表中选择任何创建的对象，将填充窗口下部的保留路径（参见上图）。从那里，很容易跟踪leakyData数组持有我们的数据。</p>
<p>如果你在你的应用程序没有幸运，像我在我的示例应用程序，你可能需要看看内部构造函数（如字符串），并试图找出是什么导致内存泄漏。在这种情况下，诀窍是尝试识别在一些内部构造器组中经常出现的值组，并尝试使用它作为指向可疑内存泄漏的提示。</p>
<p>例如，在示例应用程序案例中，您可能会观察到很多字符串看起来像转换为字符串的随机数。如果您检查其保留路径，Chrome开发工具将指向leakyData数组。</p>
<h2 id="步骤4-确认问题已解决"><a href="#步骤4-确认问题已解决" class="headerlink" title="步骤4.确认问题已解决"></a>步骤4.确认问题已解决</h2><p>在您确定并修复了可疑的内存泄漏后，您应该会发现堆使用情况有很大的不同。</p>
<p>如果我们在示例应用中取消注释以下行：</p>
<table>
<thead>
<tr>
<th>12</th>
<th>cleanUpData(leakyData, randomObject); //&lt;– Forgot to clean up</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>并按照步骤1中所述重新运行应用程序，请注意以下输出：</p>
<table>
<thead>
<tr>
<th>12345678910111213141516</th>
<th>Program is using 3756664 bytes of Heap.Program is using 3862504 bytes of Heap.Program is using 3763208 bytes of Heap.Program is using 3763400 bytes of Heap.Program is using 3763424 bytes of Heap.Program is using 3763448 bytes of Heap.Program is using 3763472 bytes of Heap.Program is using 3763496 bytes of Heap.Program is using 3763784 bytes of Heap.Program is using 3763808 bytes of Heap.Program is using 3763832 bytes of Heap.Program is using 3758368 bytes of Heap.Program is using 3758368 bytes of Heap.Program is using 3758368 bytes of Heap.Program is using 3758368 bytes of Heap.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>如果我们绘制数据，它将看起来如下：</p>
<p><a href="https://www.alexkras.com/wp-content/uploads/without-memory-leak.png" target="_blank" rel="external"><img src="https://www.alexkras.com/wp-content/uploads/without-memory-leak.png" alt="无内存泄漏"></a></p>
<p>Hooray，内存泄漏了。</p>
<p><em>注意，内存使用的初始峰值仍然存在，这是正常的，而你等待程序稳定。注意你的分析中的尖峰，以确保你不会将其解释为内存泄漏。</em></p>
<h2 id="链接到一些其他资源"><a href="#链接到一些其他资源" class="headerlink" title="链接到一些其他资源"></a>链接到一些其他资源</h2><h3 id="使用Chrome-DevTools进行内存分析"><a href="#使用Chrome-DevTools进行内存分析" class="headerlink" title="使用Chrome DevTools进行内存分析"></a>使用Chrome DevTools进行内存分析</h3><iframe width="560" height="315" src="https://www.youtube.com/embed/L3ugr9BJqIs" frameborder="0" allowfullscreen></iframe>

<p>您在本文中阅读的大部分内容都来自上面的视频。本文存在的唯一原因是，我必须在两个星期内观看这个视频3次，以发现（我相信是）的关键点，我想让发现过程更容易为其他人。</p>
<p>我强烈建议观看这个视频补充这篇文章。</p>
<h3 id="另一个有用的工具-memwatch-next"><a href="#另一个有用的工具-memwatch-next" class="headerlink" title="另一个有用的工具 - memwatch-next"></a>另一个有用的工具 - memwatch-next</h3><p>这是另一个很酷的工具，我认为值得一提。你可以<a href="https://hacks.mozilla.org/2012/11/tracking-down-memory-leaks-in-node-js-a-node-js-holiday-season/" target="_blank" rel="external">在这里</a>阅读更多的一些推理（短读，值得你的时间）。</p>
<p>或者直接去回购：<a href="https://github.com/marcominetti/node-memwatch" target="_blank" rel="external">https</a>：<a href="https://github.com/marcominetti/node-memwatch" target="_blank" rel="external">//github.com/marcominetti/node-memwatch</a></p>
<p>为了节省您的点击，您可以安装它 <code>npm install memwatch-next</code></p>
<p>然后使用它与两个事件：</p>
<table>
<thead>
<tr>
<th>12345678910</th>
<th>var memwatch = require(‘memwatch-next’);memwatch.on(‘leak’, function(info) { /<em>Log memory leak info, runs when memory leak is detected </em>/ });memwatch.on(‘stats’, function(stats) { /<em>Log memory stats, runs when V8 does Garbage Collection</em>/ }); //It can also do this…var hd = new memwatch.HeapDiff();// Do something that might leak memoryvar diff = hd.end();console.log(diff);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>最后一个控制台日志将输出如下内容，显示内存中已经生成了什么类型的对象。</p>
<table>
<thead>
<tr>
<th>12345678910111213141516171819</th>
<th>{  “before”: { “nodes”: 11625, “size_bytes”: 1869904, “size”: “1.78 mb” },  “after”:  { “nodes”: 21435, “size_bytes”: 2119136, “size”: “2.02 mb” },  “change”: { “size_bytes”: 249232, “size”: “243.39 kb”, “freed_nodes”: 197,    “allocated_nodes”: 10007,    “details”: [      { “what”: “String”,        “size_bytes”: -2120,  “size”: “-2.07 kb”,  “+”: 3,    “-“: 62      },      { “what”: “Array”,        “size_bytes”: 66687,  “size”: “65.13 kb”,  “+”: 4,    “-“: 78      },      { “what”: “LeakingClass”,        “size_bytes”: 239952, “size”: “234.33 kb”, “+”: 9998, “-“: 0      }    ]  }}</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>很酷。</p>
<h3 id="从developer-chrome-com的JavaScript内存分析"><a href="#从developer-chrome-com的JavaScript内存分析" class="headerlink" title="从developer.chrome.com的JavaScript内存分析"></a>从developer.chrome.com的JavaScript内存分析</h3><p><a href="https://developer.chrome.com/devtools/docs/javascript-memory-profiling" target="_blank" rel="external">https://developer.chrome.com/devtools/docs/javascript-memory-profiling</a></p>
<p>绝对是必读。它涵盖了我所涉及的所有主题和更多，更多的细节，更准确的🙂</p>
<p>不要忽略底部的Addy Osmani的演讲，他提到了一堆调试提示和资源。</p>
<p>你可以幻灯片<a href="https://speakerdeck.com/addyosmani/javascript-memory-management-masterclass" target="_blank" rel="external">在这里</a>：和示例代码<a href="https://github.com/addyosmani/memory-mysteries" target="_blank" rel="external">在这里</a>：</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>请考虑<a href="https://www.alexkras.com/recommends/kindle-memory-leak" target="_blank" rel="external">在Amazon上查看本指南</a>，如果您发现它有帮助。</p>
<ol>
<li>尝试重现和识别内存泄漏时手动触发垃圾收集。您可以从程序中运行带有<code>--expose-gc</code>标志和调用的Node <code>global.gc()</code>。</li>
<li>使用<a href="https://github.com/bnoordhuis/node-heapdump" target="_blank" rel="external">https://github.com/bnoordhuis/node-heapdump</a>采取至少3堆堆转储</li>
<li>使用3堆转储方法隔离内存泄漏</li>
<li>确认内存泄漏已消失</li>
<li>利润</li>
</ol>
<ul>
<li><em>原文：<a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/" target="_blank" rel="external">Simple Guide to Finding a JavaScript Memory Leak in Node.js</a></em></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/JavaScript继承与原型链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/JavaScript继承与原型链/" itemprop="url">
                  JavaScript继承与原型链
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T11:22:27+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JavaScript对于有基于类的语言经验的开发人员来说有点令人困惑 (如Java或C ++) ，因为它是动态的，并且本身不提供类实现.。(在ES2015/ES6中引入了class关键字，但是只是语法糖，JavaScript 仍然是基于原型的)。</p>
<p>当谈到继承时，Javascript 只有一种结构：对象。每个对象都有一个内部链接到另一个对象，称为它的<strong>原型 prototype</strong>。该原型对象有自己的原型，等等，直到达到一个以null为原型的对象。根据定义，null没有原型，并且作为这个<strong>原型链 **</strong>prototype chain**中的最终链接。</p>
<p>虽然，原型继承经常被视作 JavaScript 的一个弱点，但事实上，原型继承模型比经典的继承模型更强大。举例来说，在原型继承模型的基础之上建立一个经典的继承模型是相当容易的。</p>
<h2 id="基于原型链的继承"><a href="#基于原型链的继承" class="headerlink" title="基于原型链的继承"></a>基于原型链的继承</h2><h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h3><p>JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>
<p>遵循ECMAScript标准，<code>someObject.[[Prototype]]</code> 符号是用于指派 <code>someObject</code>的原型。这个等同于 JavaScript 的 <code>__proto__</code>  属性。从 ECMAScript 6 开始, <code>[[Prototype]]</code> 可以用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="external"><code>Object.getPrototypeOf()</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="external"><code>Object.setPrototypeOf()</code></a>访问器来访问。</p>
<p>这里演示当尝试访问属性时会发生什么：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 让我们假设我们有一个对象 o, 其有自己的属性 a 和 b：</span></div><div class="line"><span class="comment">// &#123;a: 1, b: 2&#125;</span></div><div class="line"><span class="comment">// o 的原型 o.[[Prototype]]有属性 b 和 c：</span></div><div class="line"><span class="comment">// &#123;b: 3, c: 4&#125;</span></div><div class="line"><span class="comment">// 最后, o.[[Prototype]].[[Prototype]] 是 null.</span></div><div class="line"><span class="comment">// 这就是原型链的末尾，即 null，</span></div><div class="line"><span class="comment">// 根据定义，null 没有[[Prototype]].</span></div><div class="line"><span class="comment">// 综上，整个原型链如下: </span></div><div class="line"><span class="comment">// &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; null</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 1</span></div><div class="line"><span class="comment">// a是o的自身属性吗？是的，该属性的值为1</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.b); <span class="comment">// 2</span></div><div class="line"><span class="comment">// b是o的自身属性吗？是的，该属性的值为2</span></div><div class="line"><span class="comment">// o.[[Prototype]]上还有一个'b'属性,但是它不会被访问到.这种情况称为"属性遮蔽 (property shadowing)".</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.c); <span class="comment">// 4</span></div><div class="line"><span class="comment">// c是o的自身属性吗？不是，那看看o.[[Prototype]]上有没有.</span></div><div class="line"><span class="comment">// c是o.[[Prototype]]的自身属性吗？是的,该属性的值为4</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.d); <span class="comment">// undefined</span></div><div class="line"><span class="comment">// d是o的自身属性吗？不是,那看看o.[[Prototype]]上有没有.</span></div><div class="line"><span class="comment">// d是o.[[Prototype]]的自身属性吗？不是，那看看o.[[Prototype]].[[Prototype]]上有没有.</span></div><div class="line"><span class="comment">// o.[[Prototype]].[[Prototype]]为null，停止搜索，</span></div><div class="line"><span class="comment">// 没有d属性，返回undefined</span></div></pre></td></tr></table></figure>
<p>创建一个对象它自己的属性的方法就是设置这个对象的属性。唯一例外的获取和设置的行为规则就是当有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters" target="_blank" rel="external">一个 getter或者一个setter</a> 被设置成继承的属性的时候。</p>
<h3 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h3><p>JavaScript 并没有其他基于类的语言所定义的“方法”。在 JavaScript 里，任何函数都可以添加到对象上作为对象的属性。函数的继承与其他的属性继承没有差别，包括上面的“属性遮蔽”（这种情况相当于其他语言的方法重写）。</p>
<p>当继承的函数被调用时，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external"><code>this</code></a> 指向的是当前继承的对象，而不是继承的函数所在的原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  a: <span class="number">2</span>,</div><div class="line">  m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.m()); <span class="comment">// 3</span></div><div class="line"><span class="comment">// 当调用 o.m 时,'this'指向了o.</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</div><div class="line"><span class="comment">// p是一个对象, p.[[Prototype]]是o.</span></div><div class="line"></div><div class="line">p.a = <span class="number">12</span>; <span class="comment">// 创建 p 的自身属性a.</span></div><div class="line"><span class="built_in">console</span>.log(p.m()); <span class="comment">// 13</span></div><div class="line"><span class="comment">// 调用 p.m 时, 'this'指向 p. </span></div><div class="line"><span class="comment">// 又因为 p 继承 o 的 m 函数</span></div><div class="line"><span class="comment">// 此时的'this.a' 即 p.a，即 p 的自身属性 'a'</span></div></pre></td></tr></table></figure>
<h2 id="使用不同的方法来创建对象和生成原型链"><a href="#使用不同的方法来创建对象和生成原型链" class="headerlink" title="使用不同的方法来创建对象和生成原型链"></a>使用不同的方法来创建对象和生成原型链</h2><h3 id="使用普通语法创建对象"><a href="#使用普通语法创建对象" class="headerlink" title="使用普通语法创建对象"></a>使用普通语法创建对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;a: <span class="number">1</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// o这个对象继承了Object.prototype上面的所有属性</span></div><div class="line"><span class="comment">// 所以可以这样使用 o.hasOwnProperty('a').</span></div><div class="line"><span class="comment">// hasOwnProperty 是Object.prototype的自身属性。</span></div><div class="line"><span class="comment">// Object.prototype的原型为null。</span></div><div class="line"><span class="comment">// 原型链如下:</span></div><div class="line"><span class="comment">// o ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">"yo"</span>, <span class="string">"whadup"</span>, <span class="string">"?"</span>];</div><div class="line"></div><div class="line"><span class="comment">// 数组都继承于Array.prototype </span></div><div class="line"><span class="comment">// (indexOf, forEach等方法都是从它继承而来).</span></div><div class="line"><span class="comment">// 原型链如下:</span></div><div class="line"><span class="comment">// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数都继承于Function.prototype</span></div><div class="line"><span class="comment">// (call, bind等方法都是从它继承而来):</span></div><div class="line"><span class="comment">// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></div></pre></td></tr></table></figure>
<h3 id="使用构造器创建对象"><a href="#使用构造器创建对象" class="headerlink" title="使用构造器创建对象"></a>使用构造器创建对象</h3><p>在 JavaScript 中，构造器其实就是一个普通的函数。当使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="external">new 操作符</a> 来作用这个函数时，它就可以被称为构造方法（构造函数）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.vertexes = [];</div><div class="line">  <span class="keyword">this</span>.edges = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Graph.prototype = &#123;</div><div class="line">  addVertex: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.vertexes.push(v);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Graph();</div><div class="line"><span class="comment">// g是生成的对象,他的自身属性有'vertices'和'edges'.</span></div><div class="line"><span class="comment">// 在g被实例化时,g.[[Prototype]]指向了Graph.prototype.</span></div></pre></td></tr></table></figure>
<h3 id="使用-Object-create-创建对象"><a href="#使用-Object-create-创建对象" class="headerlink" title="使用 Object.create 创建对象"></a>使用 Object.create 创建对象</h3><p>ECMAScript 5 中引入了一个新方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external"><code>Object.create()</code></a>。可以调用这个方法来创建一个新对象。新对象的原型就是调用 <code>create</code> 方法时传入的第一个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;a: <span class="number">1</span>&#125;; </div><div class="line"><span class="comment">// a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</div><div class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(b.a); <span class="comment">// 1 (继承而来)</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>.create(b);</div><div class="line"><span class="comment">// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> d = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="comment">// d ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(d.hasOwnProperty); <span class="comment">// undefined, 因为d没有继承Object.prototype</span></div></pre></td></tr></table></figure>
<h3 id="使用-class-关键字"><a href="#使用-class-关键字" class="headerlink" title="使用 class 关键字"></a>使用 <code>class</code> 关键字</h3><p>ECMAScript6 引入了一套新的关键字用来实现 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">class</a>。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不一样的。 JavaScript 仍然是基于原型的。这些新的关键字包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class" target="_blank" rel="external"><code>class</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/constructor" target="_blank" rel="external"><code>constructor</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/static" target="_blank" rel="external"><code>static</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/extends" target="_blank" rel="external"><code>extends</code></a>, 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super" target="_blank" rel="external"><code>super</code></a>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(height, width) &#123;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(sideLength) &#123;</div><div class="line">    <span class="keyword">super</span>(sideLength, sideLength);</div><div class="line">  &#125;</div><div class="line">  get area() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</div><div class="line">  &#125;</div><div class="line">  set sideLength(newLength) &#123;</div><div class="line">    <span class="keyword">this</span>.height = newLength;</div><div class="line">    <span class="keyword">this</span>.width = newLength;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。</p>
<p>遍历对象的属性时，原型链上的<strong>每个</strong>可枚举属性都会被枚举出来。</p>
<p>检测对象的属性是定义在自身上还是在原型链上，有必要使用 <a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="external">hasOwnProperty</a> 方法，所有继承自 <code>Object.proptotype 的对象都包含这个方法</code>。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="external">hasOwnProperty</a> 是 JavaScript 中唯一一个只涉及对象自身属性而不会遍历原型链的方法。</p>
<p>注意：仅仅通过判断值是否为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="external">undefined</a> 还<strong>不</strong>足以检测一个属性是否存在，一个属性可能存在而其值恰好为 <code>undefined</code>。</p>
<h3 id="不好的实践：扩展原生对象的原型"><a href="#不好的实践：扩展原生对象的原型" class="headerlink" title="不好的实践：扩展原生对象的原型"></a>不好的实践：扩展原生对象的原型</h3><p>一个经常被用到的错误实践是去扩展 <code>Object.prototype</code> 或者其他内置对象的原型。</p>
<p>该技术被称为 monkey patching，它破坏了原型链的密封性。尽管，一些流行的框架（如 Prototype.js）在使用该技术，但是并没有足够好的理由要用其他<em>非标准</em>的方法将内置的类型系统搞乱。</p>
<p>我们去扩展内置对象原型的<strong>唯一</strong>理由是引入新的 JavaScript 引擎的某些新特性，比如 <code>Array.forEach</code>。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>B</code> 将继承自 <code>A：</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.varA = a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 以上函数 A 的定义中，既然 A.prototype.varA 总是会被 this.varA 遮蔽，</span></div><div class="line"><span class="comment">// 那么将 varA 加入到原型（prototype）中的目的是什么？</span></div><div class="line">A.prototype = &#123;</div><div class="line">  varA : <span class="literal">null</span>,  </div><div class="line"><span class="comment">/*</span></div><div class="line">既然它没有任何作用，干嘛不将 varA 从原型（prototype）去掉 ? </div><div class="line">也许作为一种在隐藏类中优化分配空间的考虑 ?</div><div class="line">https://developers.google.com/speed/articles/optimizing-javascript </div><div class="line">如果varA并不是在每个实例中都被初始化，那这样做将是有效果的。</div><div class="line">*/</div><div class="line">  doSomething : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">a, b</span>)</span>&#123;</div><div class="line">  A.call(<span class="keyword">this</span>, a);</div><div class="line">  <span class="keyword">this</span>.varB = b;</div><div class="line">&#125;</div><div class="line">B.prototype = <span class="built_in">Object</span>.create(A.prototype, &#123;</div><div class="line">  varB : &#123;</div><div class="line">    value: <span class="literal">null</span>, </div><div class="line">    enumerable: <span class="literal">true</span>, </div><div class="line">    configurable: <span class="literal">true</span>, </div><div class="line">    writable: <span class="literal">true</span> </div><div class="line">  &#125;,</div><div class="line">  doSomething : &#123; </div><div class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// override</span></div><div class="line">      A.prototype.doSomething.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); </div><div class="line">      <span class="comment">// call super</span></div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line">    enumerable: <span class="literal">true</span>,</div><div class="line">    configurable: <span class="literal">true</span>, </div><div class="line">    writable: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">B.prototype.constructor = B;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</div><div class="line">b.doSomething();</div></pre></td></tr></table></figure>
<p><code>最重要的部分是：</code></p>
<ul>
<li><code>类型被定义在 .prototype 中</code></li>
<li><code>而你用 Object.create() 来继承</code></li>
</ul>
<h2 id="prototype-和-Object-getPrototypeOf"><a href="#prototype-和-Object-getPrototypeOf" class="headerlink" title="prototype 和 Object.getPrototypeOf"></a><code>prototype 和 Object.getPrototypeOf</code></h2><p><code>对于从 Java 或 C++ 转过来的开发人员来说 JavaScript 会有点让人困惑，因为它全部都是动态的，都是运行时，而且不存在类（classes）。所有的都是实例（对象）。即使我们模拟出的 “类（classes）”，也只是一个函数对象。</code></p>
<p><code>你可能已经注意到，我们的函数 A 有一个特殊的属性叫做原型。这个特殊的属性与 JavaScript 的 new 运算符一起工作。对原型对象的引用会复制到新实例内部的 [[Prototype]] 属性。例如，当你这样： var a1 = new A()， JavaScript 就会设置：a1.[[Prototype]] = A.prototype（在内存中创建对象后，并在运行 this 绑定的函数 A()之前）。然后在你访问实例的属性时，JavaScript 首先检查它们是否直接存在于该对象中（即是否是该对象的自身属性），如果不是，它会在 [[Prototype]] 中查找。也就是说，你在原型中定义的元素将被所有实例共享，甚至可以在稍后对原型进行修改，这种变更将影响到所有现存实例。</code></p>
<p><code>像上面的例子中，如果你执行 var a1 = new A(); var a2 = new A(); 那么 a1.doSomething 事实上会指向Object.getPrototypeOf(a1).doSomething，它就是你在 A.prototype.doSomething 中定义的内容。比如：Object.getPrototypeOf(a1).doSomething == Object.getPrototypeOf(a2).doSomething == A.prototype.doSomething。</code></p>
<p><code>简而言之， prototype 是用于类型的，而 Object.getPrototypeOf() 是用于实例的（instances），两者功能一致。</code></p>
<p><code>[[Prototype]] 看起来就像**递归**引用， 如a1.doSomething，Object.getPrototypeOf(a1).doSomething，Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething 等等等， 直到它找到 doSomething 这个属性或者 Object.getPrototypeOf 返回 null。</code></p>
<p><code>因此，当你执行：</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Foo();</div></pre></td></tr></table></figure>
<p><code>JavaScript 实际上执行的是：</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o.[[Prototype]] = Foo.prototype;</div><div class="line">Foo.call(o);</div></pre></td></tr></table></figure>
<p><code>（或者类似上面这样的），然后当你执行：</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">o.someProp;</div></pre></td></tr></table></figure>
<p><code>它会检查是否存在 someProp 属性。如果没有，它会查找Object.getPrototypeOf(o).someProp ,如果仍旧没有，它会继续查找Object.getPrototypeOf(Object.getPrototypeOf(o)).someProp ，一直查找下去，直到它找到这个属性 或者 Object.getPrototypeOf() 返回 null 。</code></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><code>结论</code></h2><p><code>在用原型继承编写复杂代码前理解原型继承模型十分**重要**。同时，还要清楚代码中原型链的长度，并在必要时结束原型链，以避免可能存在的性能问题。此外，除非为了兼容新 JavaScript 特性，否则，永远**不要**扩展原生的对象原型。</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/JavaScript内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/JavaScript内存管理/" itemprop="url">
                  JavaScript内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T10:33:23+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>诸如 C 语言这般的低级语言一般都有低级的内存管理接口，比如 <code>malloc() 和</code> <code>free()</code>。而另外一些高级语言，比如 JavaScript， 其在变量（对象，字符串等等）创建时分配内存，然后在它们不再使用时“自动”释放。后者被称为<strong>垃圾回收</strong>。“自动”是容易让人混淆，迷惑的，并给 JavaScript（和其他高级语言）开发者一个印象：他们可以不用关心内存管理。然而这是错误的。</p>
<h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>不管什么程序语言，内存生命周期基本是一致的：   </p>
<ol>
<li>分配你所需要的内存</li>
<li>使用分配到的内存（读、写）</li>
<li>不需要时将其释放\归还</li>
</ol>
<p>在所有语言中第一和第二部分都很清晰。最后一步在低级语言中很清晰，但是在像JavaScript 等高级语言中，这一步是隐藏的、透明的。</p>
<h3 id="JavaScript-的内存分配"><a href="#JavaScript-的内存分配" class="headerlink" title="JavaScript 的内存分配"></a>JavaScript 的内存分配</h3><h4 id="值的初始化"><a href="#值的初始化" class="headerlink" title="值的初始化"></a>值的初始化</h4><p>为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// 给数值变量分配内存</span></div><div class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span>; <span class="comment">// 给字符串分配内存</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  a: <span class="number">1</span>,</div><div class="line">  b: <span class="literal">null</span></div><div class="line">&#125;; <span class="comment">// 给对象及其包含的值分配内存</span></div><div class="line"></div><div class="line"><span class="comment">// 给数组及其包含的值分配内存（就像对象一样）</span></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">"abra"</span>]; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a + <span class="number">2</span>;</div><div class="line">&#125; <span class="comment">// 给函数（可调用的对象）分配内存</span></div><div class="line"></div><div class="line"><span class="comment">// 函数表达式也能分配一个对象</span></div><div class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span>;</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h4 id="通过函数调用的内存分配"><a href="#通过函数调用的内存分配" class="headerlink" title="通过函数调用的内存分配"></a>通过函数调用的内存分配</h4><p>有些函数调用结果是分配对象内存：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 分配一个 Date 对象</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); <span class="comment">// 分配一个 DOM 元素</span></div></pre></td></tr></table></figure>
<p>有些方法分配新变量或者新对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span>;</div><div class="line"><span class="keyword">var</span> s2 = s.substr(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2 是一个新的字符串</span></div><div class="line"><span class="comment">// 因为字符串是不变量，</span></div><div class="line"><span class="comment">// JavaScript 可能决定不分配内存，</span></div><div class="line"><span class="comment">// 只是存储了 [0-3] 的范围。</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">"ouais ouais"</span>, <span class="string">"nan nan"</span>];</div><div class="line"><span class="keyword">var</span> a2 = [<span class="string">"generation"</span>, <span class="string">"nan nan"</span>];</div><div class="line"><span class="keyword">var</span> a3 = a.concat(a2); </div><div class="line"><span class="comment">// 新数组有四个元素，是 a 连接 a2 的结果</span></div></pre></td></tr></table></figure>
<h3 id="值的使用"><a href="#值的使用" class="headerlink" title="值的使用"></a>值的使用</h3><p>使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p>
<h3 id="当内存不再需要使用时释放"><a href="#当内存不再需要使用时释放" class="headerlink" title="当内存不再需要使用时释放"></a>当内存不再需要使用时释放</h3><p>大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。</p>
<p>高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是<a href="http://en.wikipedia.org/wiki/Decidability_%28logic%29" target="_blank" rel="external">无法判定的</a> (无法通过某种算法解决).</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。本节将解释必要的概念，了解主要的垃圾回收算法和它们的局限性。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>垃圾回收算法主要依赖于<strong>引用</strong>（<em>reference</em>）的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它<a href="https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain" target="_blank" rel="external">原型</a>的引用（隐式引用）和对它属性的引用（显式引用）。</p>
<p>在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。</p>
<h3 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h3><p>这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123; </div><div class="line">  a: &#123;</div><div class="line">    b:<span class="number">2</span></div><div class="line">  &#125;</div><div class="line">&#125;; </div><div class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></div><div class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// o2变量是第二个对“这个对象”的引用</span></div><div class="line"></div><div class="line">o = <span class="number">1</span>;      <span class="comment">// 现在，“这个对象”的原始引用o被o2替换了</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> oa = o2.a; <span class="comment">// 引用“这个对象”的a属性</span></div><div class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></div><div class="line"></div><div class="line">o2 = <span class="string">"yo"</span>; <span class="comment">// 最初的对象现在已经是零引用了</span></div><div class="line">           <span class="comment">// 他可以被垃圾回收了</span></div><div class="line">           <span class="comment">// 然而它的属性a的对象还在被oa引用，所以还不能回收</span></div><div class="line"></div><div class="line">oa = <span class="literal">null</span>; <span class="comment">// a属性的那个对象现在也是零引用了</span></div><div class="line">           <span class="comment">// 它可以被垃圾回收了</span></div></pre></td></tr></table></figure>
<h4 id="限制：循环引用"><a href="#限制：循环引用" class="headerlink" title="限制：循环引用"></a>限制：循环引用</h4><p>该算法有个限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</div><div class="line">  o.a = o2; <span class="comment">// o 引用 o2</span></div><div class="line">  o2.a = o; <span class="comment">// o2 引用 o</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">"azerty"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<h4 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h4><p>IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄露：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div;</div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  div = <span class="built_in">document</span>.getElementById(<span class="string">"myDivElement"</span>);</div><div class="line">  div.circularReference = div;</div><div class="line">  div.lotsOfData = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).join(<span class="string">"*"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在上面的例子里，<code>myDivElement</code> 这个 DOM 元素里的 <code>circularReference 属性</code>引用了 <code>myDivElement</code>，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 <code>lotsOfData</code> 属性)，而这个数据占用的内存将永远不会被释放。</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p>
<p>这个算法假定设置一个叫做<strong>根</strong>（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p>
<p>这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。</p>
<p>从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。</p>
<h4 id="循环引用不再是问题了"><a href="#循环引用不再是问题了" class="headerlink" title="循环引用不再是问题了"></a>循环引用不再是问题了</h4><p>在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。</p>
<p>第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收<br>。</p>
<h4 id="限制-那些无法从根对象查询到的对象都将被清除"><a href="#限制-那些无法从根对象查询到的对象都将被清除" class="headerlink" title="限制: 那些无法从根对象查询到的对象都将被清除"></a>限制: 那些无法从根对象查询到的对象都将被清除</h4><p>尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/JavaScript模块系统对决(PK)：CommonJS-vs-AMD-vs-ES2015/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/JavaScript模块系统对决(PK)：CommonJS-vs-AMD-vs-ES2015/" itemprop="url">
                  JavaScript模块系统对决(PK)：CommonJS vs AMD vs ES2015
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T17:09:52+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>了解目前使用的不同JavaScript模块系统，并找出哪些是您的项目的最佳选择。</p>
</blockquote>
<p>随着JavaScript开发越来越普遍，命名空间和depedencies更难以处理。开发了不同的解决方案以模块系统的形式来处理这个问题。在这篇文章中，我们将探讨开发人员目前使用的不同解决方案以及他们尝试解决的问题。阅读！</p>
<hr>
<h2 id="简介：为什么需要JavaScript模块？"><a href="#简介：为什么需要JavaScript模块？" class="headerlink" title="简介：为什么需要JavaScript模块？"></a>简介：为什么需要JavaScript模块？</h2><p>如果你熟悉其他开发平台，你可能有一些概念的<em>封装</em>和<em>依赖</em>的概念。通常孤立地开发不同的软件，直到先前存在的软件需要满足某些需求。在将其他软件带入项目的时刻，在它和新的代码之间创建依赖关系。由于这些软件需要一起工作，因此它们之间不会出现冲突是很重要的。这可能听起来很小，但是没有某种<em>封装，</em>这是两个<em>模块</em>相互冲突之前的时间问题。这是C库中的元素之一通常带有前缀的原因之一：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYLIB_INIT_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLIB_INIT_H</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> mylib_init_code &#123;</div><div class="line">    mylib_init_code_success,</div><div class="line">    mylib_init_code_error</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">enum</span> mylib_init_code <span class="title">mylib_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// (...)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//MYLIB_INIT_H</span></span></div></pre></td></tr></table></figure>
<p>封装对于防止冲突和缓解发展至关重要。</p>
<p>当涉及到依赖关系时，在传统的客户端JavaScript开发中，它们是隐式的。换句话说，开发者的任务是确保在执行任何代码块时都满足依赖关系。开发人员还需要确保依赖关系以正确的顺序满足（某些库的要求）。</p>
<p>以下示例是<a href="https://github.com/jashkenas/backbone/blob/master/examples/todos/index.html" target="_blank" rel="external">Backbone.js的</a>示例的一部分。脚本以正确的顺序手动加载：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Backbone.js Todos<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"todos.css"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../test/vendor/json2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../test/vendor/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../test/vendor/underscore.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../backbone.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../backbone.localStorage.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"todos.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- (...) --&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>随着JavaScript开发变得越来越复杂，依赖管理可能变得麻烦。重构也受损：在哪里应该更新的依赖关系来维持负载链的正确顺序？</p>
<p>JavaScript模块系统试图处理这些问题和其他问题。他们出生的必要性，以适应不断增长的JavaScript景观。让我们看看不同的解决方案带来的表。</p>
<h2 id="一个Ad-Hoc解决方案：显露模块模式"><a href="#一个Ad-Hoc解决方案：显露模块模式" class="headerlink" title="一个Ad-Hoc解决方案：显露模块模式"></a>一个Ad-Hoc解决方案：显露模块模式</h2><p>大多数模块系统相对较新。在它们可用之前，特定的编程模式开始越来越多地被使用在越来越多的JavaScript代码：揭示模块模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myRevealingModule = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> privateVar = <span class="string">"Ben Cherry"</span>,</div><div class="line">        publicVar = <span class="string">"Hey there!"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Name:"</span> + privateVar );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">publicSetName</span>(<span class="params"> strName </span>) </span>&#123;</div><div class="line">        privateVar = strName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">publicGetName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        privateFunction();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Reveal public pointers to</span></div><div class="line">    <span class="comment">// private functions and properties</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        setName: publicSetName,</div><div class="line">        greeting: publicVar,</div><div class="line">        getName: publicGetName</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">myRevealingModule.setName( <span class="string">"Paul Kinlan"</span> );</div></pre></td></tr></table></figure>
<blockquote>
<p>这个例子取自<a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/" target="_blank" rel="external">Addy Osmani的JavaScript设计模式</a>书。</p>
</blockquote>
<p>JavaScript范围（至少达到ES2015中<code>let</code>的外观）在函数级别工作。换句话说，在函数中声明的任何绑定都不能逃避它的作用域。正是由于这个原因，揭示模块模式依赖于封装私有内容的函数（像许多其他JavaScript模式一样）。</p>
<p>在上面的示例中，<em>公共</em>符号在返回的字典中显示。所有其他声明由包围它们的函数作用域保护。不必使用<code>var</code>和立即调用包含私有作用域的函数; 一个命名函数也可以用于模块。</p>
<p>这种模式已经在JavaScript项目中使用了相当长的时间，并且与封装事物相当好。它不做太多关于依赖性问题。正确的模块系统也尝试处理这个问题。另一个限制在于，包括其他模块不能在同一源（除非使用<code>eval</code>）。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>足够简单，可以在任何地方实现（没有库，不需要语言支持）。</li>
<li>可以在单个文件中定义多个模块。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>没有办法以编程方式导入模块（除了使用<code>eval</code>）。</li>
<li>依赖需要手动处理。</li>
<li>模块的异步加载是不可能的。</li>
<li>循环依赖可能很麻烦。</li>
<li>很难分析静态代码分析器。</li>
</ul>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>CommonJS是一个旨在定义一系列规范以帮助开发服务器端JavaScript应用程序的项目。CommonJS团队尝试解决的一个领域是模块。Node.js开发人员原本打算遵循CommonJS规范，但后来决定反对它。当涉及到模块时，Node.js的实现非常受它的影响：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In circle.js</span></div><div class="line"><span class="keyword">const</span> PI = <span class="built_in">Math</span>.PI;</div><div class="line"></div><div class="line">exports.area = (r) =&gt; PI * r * r;</div><div class="line"></div><div class="line">exports.circumference = (r) =&gt; <span class="number">2</span> * PI * r;</div><div class="line"></div><div class="line"><span class="comment">// In some file</span></div><div class="line"><span class="keyword">const</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>);</div><div class="line"><span class="built_in">console</span>.log( <span class="string">`The area of a circle of radius 4 is <span class="subst">$&#123;circle.area(4)&#125;</span>`</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>在一个晚上，当我提到一个令人沮丧的请求一个功能，我认为是一个可怕的想法，Joyent对我说，“忘记CommonJS。它已经死了，我们是服务器端的JavaScript。- <a href="https://github.com/nodejs/node-v0.x-archive/issues/5132#issuecomment-15432598" target="_blank" rel="external">NPM创建者Isaac Z. Schlueter引用Node.js创建者Ryan Dahl</a></p>
</blockquote>
<p>在Node.js的模块系统的顶部有以库的形式的抽象，以桥接Node.js的模块和CommonJS之间的差距。为了这篇文章的目的，我们将只显示大致相同的基本功能。</p>
<p>在Node和CommonJS的模块中，基本上有两个元素与模块系统交互：<code>require</code>和<code>exports</code>。<code>require</code>是一个可用于将符号从另一个模块导入到当前作用域的函数。传递给<code>require</code>的<em>参数</em>是模块的<em>id</em>。在Node的实现中，它是目录中模块的名称<code>node_modules</code>（或者，如果它不在该目录中，则是它的路径）。<code>exports</code>是一个特殊的对象：放在其中的任何东西将被导出为一个公共元素。字段的名称保留。Node和CommonJS之间的特殊区别是以<code>module.exports</code>对象的形式出现。在Node中，<code>module.exports</code>是被导出的真正的特殊对象，而<code>exports</code>只是一个默认绑定的变量<code>module.exports</code>。<code>module.exports</code>另一方面，CommonJS没有对象。实际的含义是，在节点中，不可能导出完全预构造的对象，而不通过<code>module.exports</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This won't work, replacing exports entirely breaks the binding to</span></div><div class="line"><span class="comment">// modules.exports.</span></div><div class="line">exports =  (width) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    area: () =&gt; width * width</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// This works as expected.</span></div><div class="line"><span class="built_in">module</span>.exports = (width) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    area: () =&gt; width * width</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CommonJS模块的设计考虑了服务器开发。当然，API是同步的。换句话说，模块在源文件中的时刻和它们所需的顺序被加载。</p>
<blockquote>
<p><a href="https://twitter.com/intent/tweet?text=%22CommonJS%20modules%20were%20designed%20with%20server%20development%20in%20mind.%22%20via%20@auth0%20http://auth0.com/blog/javascript-module-systems-showdown/" target="_blank" rel="external">“CommonJS模块的设计考虑了服务器开发。TWEET这个 <img src="https://cdn.auth0.com/blog/resources/twitter.svg" alt="img"></a></p>
</blockquote>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>简单：开发人员可以抓住这个概念，而不用看文档。</li>
<li>集成了依赖性管理：模块需要其他模块，并按需要加载。</li>
<li><code>require</code> 可以在任何地方调用：模块可以以编程方式加载。</li>
<li>支持循环依赖性。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>同步API使其不适合某些用途（客户端）。</li>
<li>每个模块一个文件。</li>
<li>浏览器需要加载器库或翻译。</li>
<li>没有模块的构造函数（Node支持这个功能）。</li>
<li>很难分析静态代码分析器。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们已经谈到了一个实现（部分形式）：Node.js.</p>
<p><img src="https://cdn.auth0.com/blog/jsmodules/Node.js_logo.svg" alt="Node.js JavaScript模块"></p>
<p>对于客户端，目前有两个受欢迎的选项：<a href="https://webpack.github.io/docs/commonjs.html" target="_blank" rel="external">webpack</a>和<a href="http://browserify.org/index.html" target="_blank" rel="external">browserify</a>。Browserify被明确发展解析节点般的模块定义（多节点程序包工作外的开箱即用的吧！），并捆绑你的代码加上这些模块中携带的所有依赖一个单一的文件中的代码。在另一方面Webpack中被开发用于处理发布之前创建源转换的复杂管道。这包括将CommonJS模块捆绑在一起。</p>
<h2 id="异步模块定义（AMD）"><a href="#异步模块定义（AMD）" class="headerlink" title="异步模块定义（AMD）"></a>异步模块定义（AMD）</h2><p>AMD是由一群不喜欢CommonJS所采用的方向的开发者组成的。事实上，AMD在开发初期就从CommonJS中分离出来。AMD和CommonJS的主要区别在于它支持异步模块加载。</p>
<blockquote>
<p><a href="https://twitter.com/intent/tweet?text=%22The%20main%20difference%20between%20AMD%20and%20CommonJS%20lies%20in%20its%20support%20for%20asynchronous%20module%20loading.%22%20via%20@auth0%20http://auth0.com/blog/javascript-module-systems-showdown/" target="_blank" rel="external">“AMD和CommonJS的主要区别在于它支持异步模块加载。TWEET这个 <img src="https://cdn.auth0.com/blog/resources/twitter.svg" alt="img"></a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Calling define with a dependency array and a factory function</span></div><div class="line">define([<span class="string">'dep1'</span>, <span class="string">'dep2'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">dep1, dep2</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//Define the module value by returning a value.</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Or:</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dep1 = <span class="built_in">require</span>(<span class="string">'dep1'</span>),</div><div class="line">        dep2 = <span class="built_in">require</span>(<span class="string">'dep2'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>异步加载是通过使用JavaScript的传统闭包成语实现的：当所请求的模块完成加载时调用一个函数。模块定义和导入模块由相同的函数承载：当模块被定义时，其依赖性被显式化。因此，AMD加载器可以在运行时对给定项目的依赖图的完整图片。因此，可以同时加载彼此不依赖于加载的库。这对于浏览器尤其重要，因为启动时间对于良好的用户体验至关重要。</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>异步加载（更好的启动时间）。</li>
<li>支持循环依赖性。</li>
<li>兼容性<code>require</code>和<code>exports</code>。</li>
<li>依赖管理完全集成。</li>
<li>如果需要，模块可以分割成多个文件。</li>
<li>支持构造函数。</li>
<li>插件支持（自定义加载步骤）。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>句法稍微复杂一些。</li>
<li>加载器库是必需的，除非传递。</li>
<li>很难分析静态代码分析器。</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>目前最流行的AMD实现是<a href="http://requirejs.org/" target="_blank" rel="external">require.js</a>和<a href="https://dojotoolkit.org/" target="_blank" rel="external">Dojo</a>。</p>
<p><img src="https://cdn.auth0.com/blog/jsmodules/requirejs-logo.svg" alt="Require.js for JavaScript模块"></p>
<p>使用require.js非常简单：在HTML文件中包含库，并使用<code>data-main</code>属性告诉require.js应该首先加载哪个模块。Dojo有<a href="http://dojotoolkit.org/documentation/tutorials/1.10/hello_dojo/index.html" target="_blank" rel="external">类似的设置</a>。</p>
<h2 id="ES2015模块"><a href="#ES2015模块" class="headerlink" title="ES2015模块"></a>ES2015模块</h2><p>幸运的是，ECMA团队背后的标准化JavaScript决定解决模块的问题。结果可以在最新版本的JavaScript标准中看到：ECMAScript 2015（以前称为ECMAScript 6）。结果是语法上愉快的，并且与同步和异步操作模式兼容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//------ lib.js ------</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.sqrt;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diag</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> sqrt(square(x) + square(y));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//------ main.js ------</span></div><div class="line"><span class="keyword">import</span> &#123; square, diag &#125; <span class="keyword">from</span> <span class="string">'lib'</span>;</div><div class="line"><span class="built_in">console</span>.log(square(<span class="number">11</span>)); <span class="comment">// 121</span></div><div class="line"><span class="built_in">console</span>.log(diag(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<blockquote>
<p>示例取自<a href="http://www.2ality.com/2014/09/es6-modules-final.html" target="_blank" rel="external">Axel Rauschmayer博客</a></p>
</blockquote>
<p>该<code>import</code>伪指令可以用于将模块带入命名空间。这个指令，与<code>require</code>和<code>define</code>不是动态的（即它不能在任何地方被调用）。<code>export</code>另一方面，该指令可以用于将元素显式地公开。</p>
<p>静态特性<code>import</code>和<code>export</code>静态指令允许静态分析器构建一个完整的依赖关系树，而不需要运行代码。ES2015不支持动态加载模块，但草案规范：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">System.import(<span class="string">'some_module'</span>)</div><div class="line">      .then(some_module =&gt; &#123;</div><div class="line">          <span class="comment">// Use some_module</span></div><div class="line">      &#125;)</div><div class="line">      .catch(error =&gt; &#123;</div><div class="line">          <span class="comment">// ...</span></div><div class="line">      &#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>实际上，ES2015 <a href="https://github.com/lukehoban/es6features/issues/75" target="_blank" rel="external">只指定</a>静态模块装载器<a href="https://github.com/lukehoban/es6features/issues/75" target="_blank" rel="external">的语法</a>。实际上，在解析这些指令之后，ES2015实现不需要做任何事情。仍然需要模块加载器，如System.js。提供了浏览器模块加载的草案<a href="https://github.com/whatwg/loader" target="_blank" rel="external">规范</a>。</p>
</blockquote>
<p>这个解决方案通过集成在语言中，使运行时选择模块的最佳加载策略。换句话说，当异步加载产生好处时，它可以被运行时使用。</p>
<blockquote>
<p><strong>更新（2017年2月）：</strong>现在有一个<a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="external">动态加载模块</a>的<a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="external">规范</a>。这是对ECMAScript标准的未来版本的提议。</p>
</blockquote>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li>支持同步和异步加载。</li>
<li>语法简单。</li>
<li>支持静态分析工具。</li>
<li>集成在语言（最终支持到处，不需要图书馆）。</li>
<li>支持循环依赖。</li>
</ul>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>仍然不支持全部。</li>
</ul>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>遗憾的是，没有一个主要的JavaScript运行时在其当前稳定的分支中支持ES2015模块。这意味着在Firefox，Chrome或Node.js中不支持。幸运的是，许多转换器支持模块，并且<a href="https://github.com/ModuleLoader/es6-module-loader" target="_blank" rel="external">polyfill</a>也可用。目前，为<a href="https://babeljs.io/" target="_blank" rel="external">Babel</a>预设的ES2015 可以毫无问题地处理模块。</p>
<p><img src="https://cdn.auth0.com/blog/jsmodules/babel.png" alt="Babel for JavaScript模块"></p>
<h2 id="一体化解决方案：System-js"><a href="#一体化解决方案：System-js" class="headerlink" title="一体化解决方案：System.js"></a>一体化解决方案：System.js</h2><p>你可能会发现自己试图使用一个模块系统远离遗留代码。或者你可能想确保发生了什么，你选择的解决方案仍然可以工作。输入<a href="https://github.com/systemjs/systemjs" target="_blank" rel="external">System.js</a>：支持CommonJS，AMD和ES2015模块的通用模块加载程序。它可以与转换器一起工作，如Babel或Traceur，并且可以支持Node和IE8 +环境。使用它是在代码中加载System.js，然后将其指向您的基本URL：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"system.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="comment">// set our baseURL reference path</span></div><div class="line">  System.config(&#123;</div><div class="line">    baseURL: <span class="string">'/app'</span>,</div><div class="line">    <span class="comment">// or 'traceur' or 'typescript'</span></div><div class="line">    transpiler: <span class="string">'babel'</span>,</div><div class="line">    <span class="comment">// or traceurOptions or typescriptOptions</span></div><div class="line">    babelOptions: &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="comment">// loads /app/main.js</span></div><div class="line">  System.import(<span class="string">'main.js'</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>由于System.js可以即时完成所有工作，因此使用ES2015模块通常应该在生产模式下的构建步骤中保留给转换器。当不处于生产模式时，System.js可以为您调用转换程序，提供生产和调试环境之间的无缝转换。</p>
<h2 id="Aside：我们在Auth0使用什么"><a href="#Aside：我们在Auth0使用什么" class="headerlink" title="Aside：我们在Auth0使用什么"></a>Aside：我们在Auth0使用什么</h2><p>在Auth0，我们大量使用JavaScript。对于我们的服务器端代码，我们使用CommonJS风格的Node.js模块。对于某些客户端代码，我们更喜欢AMD。对于我们基于React的<a href="https://github.com/auth0/lock-passwordless" target="_blank" rel="external">无密码锁库，</a>我们选择了ES2015模块。</p>
<p>喜欢你看到的？<a href="javascript:signup(" target="_blank" rel="external">注册</a>)并开始在您的项目中使用Auth0。</p>
<p>你是一个开发人员，喜欢我们的代码？如果是，<a href="https://auth0.com/jobs" target="_blank" rel="external">请</a>立即<a href="https://auth0.com/jobs" target="_blank" rel="external">申请</a>工程学位置。我们有一个真棒团队！</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>构建模块和处理依赖性在过去是麻烦的。较新的解决方案，以图书馆或ES2015模块的形式，已经消耗了大部分的痛苦。如果你正在寻找一个新的模块或项目，ES2015是正确的方法去。它将始终被支持，并且使用transpiler和polyfills的当前支持是优秀的。另一方面，如果你更喜欢使用纯ES5代码，那么客户端的AMD和服务器的CommonJS / Node之间的通常分割仍然是通常的选择。不要忘记在下面的评论部分留下你的想法。Hack on！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/Javascript中4种类型的内存泄漏和如何摆脱它们/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/Javascript中4种类型的内存泄漏和如何摆脱它们/" itemprop="url">
                  Javascript中4种类型的内存泄漏和如何摆脱它们
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T14:22:06+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/" target="_blank" rel="external">4 Types of Memory Leaks in JavaScript and How to Get Rid Of Them</a></p>
<p>了解JavaScript中的内存泄漏，以及可以做什么来解决它！</p>
</blockquote>
<p>在本文中，我们将探讨客户端JavaScript代码中的常见类型的内存泄漏。我们还将学习如何使用Chrome开发工具找到它们！</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>内存泄漏是每个开发人员最终面临的问题。即使使用内存管理的语言，也有可能泄漏内存的情况。泄漏是整类问题的原因：减速，崩溃，高延迟，甚至与其他应用程序的问题。</p>
<blockquote>
<p>诸如 C 语言这般的低级语言一般都有低级的内存管理接口，比如 <code>malloc() 和</code> <code>free()</code>。而另外一些高级语言，比如 JavaScript， 其在变量（对象，字符串等等）创建时分配内存，然后在它们不再使用时“自动”释放。后者被称为<strong>垃圾回收</strong>。“自动”是容易让人混淆，迷惑的，并给 JavaScript（和其他高级语言）开发者一个印象：他们可以不用关心内存管理。然而这是错误的。</p>
</blockquote>
<h3 id="什么是内存泄露？"><a href="#什么是内存泄露？" class="headerlink" title="什么是内存泄露？"></a>什么是内存泄露？</h3><p>实质上，内存泄漏可以定义为应用程序不再需要的内存，因为某种原因，该内存不会返回到操作系统或可用内存池。编程语言有利于不同的管理内存的方式。这些方式可以减少泄漏内存的机会。然而，某一块内存是否未被使用实际上是一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management#Release_when_the_memory_is_not_needed_anymore" target="_blank" rel="external">不可判定的问题</a>。换句话说，只有开发人员才能明确是否可以将一块内存返回到操作系统。某些编程语言提供了帮助开发人员做这些的功能。其他人期望开发人员完全明确一段内存未使用。维基百科有关于<a href="https://en.wikipedia.org/wiki/Manual_memory_management" target="_blank" rel="external">手动</a>和<a href="https://en.wikipedia.org/wiki/Manual_memory_management" target="_blank" rel="external">自动</a>内存管理的好文章。</p>
<h3 id="JavaScript中的内存管理"><a href="#JavaScript中的内存管理" class="headerlink" title="JavaScript中的内存管理"></a>JavaScript中的内存管理</h3><p>JavaScript是所谓的<em>垃圾收集语言</em>之一。垃圾收集语言通过定期检查哪些先前分配的内存仍然可以从应用程序的其他部分“达到”来帮助开发人员管理内存。换句话说，垃圾收集语言将管理内存的问题从“还需要什么内存？降低到“应用程序的其他部分仍然可以重新分配内存？”。差别是微妙的，但重要的是：虽然只有开发人员知道将来是否需要一块分配的内存，取不到的内存可以通过算法确定并标记为返回到操作系统。</p>
<blockquote>
<p>非垃圾收集语言通常使用其他技术来管理内存：显式管理，开发人员明确告诉编译器何时不需要一块内存; 和引用计数，其中使用计数与存储器的每个块相关联（当计数达到零时，其被返回到OS）。这些技术有自己的权衡（和潜在的泄漏原因）。</p>
</blockquote>
<h2 id="JavaScript中的内存溢出"><a href="#JavaScript中的内存溢出" class="headerlink" title="JavaScript中的内存溢出"></a>JavaScript中的内存溢出</h2><p>垃圾收集语言内存泄漏的主要原因是<em>不需要的引用</em>。要理解什么是不需要的引用，首先我们需要了解垃圾回收器如何确定是否可以到达一块内存。</p>
<blockquote>
<p><a href="https://twitter.com/intent/tweet?text=%22The%20main%20cause%20for%20leaks%20in%20garbage%20collected%20languages%20are%20unwanted%20references.%22%20via%20@auth0%20http://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/" target="_blank" rel="external">“垃圾收集语言泄漏的主要原因是不需要的引用。TWEET这个 <img src="https://cdn.auth0.com/blog/resources/twitter.svg" alt="img"></a></p>
</blockquote>
<h3 id="标记和扫描"><a href="#标记和扫描" class="headerlink" title="标记和扫描"></a>标记和扫描</h3><p>大多数垃圾收集器使用称为<em>标记和扫描</em>的算法。该算法由以下步骤组成：</p>
<ol>
<li>垃圾回收器构建“根”的列表。根通常是在代码中保存引用的全局变量。在JavaScript中，“window”对象是可以充当根的全局变量的示例。窗口对象总是存在，所以垃圾收集器可以考虑它和它的所有子对象总是存在（即不是垃圾）。</li>
<li>所有根被检查并标记为活动（即不是垃圾）。所有孩子也被递归检查。从根可以到达的一切都不被认为是垃圾。</li>
<li>所有未标记为活动的内存块现在可以被认为是垃圾。收集器现在可以释放该内存并将其返回到操作系统。</li>
</ol>
<p>现代垃圾收集器以不同的方式改进了该算法，但本质是相同的：可访问的内存段被标记为这样，其余被认为是垃圾。</p>
<p>不需要的引用是对开发者知道他或她将不再需要，但由于某种原因保存在活动根的树内部的存储器的引用。在JavaScript的上下文中，不需要的引用是保存在代码中某处的变量，它不再被使用，并指向可以被释放的一块内存。有些人会认为这些都是开发者的错误。</p>
<p>所以要了解哪些是JavaScript中最常见的内存泄漏，我们需要知道在哪些方式引用通常被遗忘。</p>
<h2 id="JavaScript内存泄漏的三种类型"><a href="#JavaScript内存泄漏的三种类型" class="headerlink" title="JavaScript内存泄漏的三种类型"></a>JavaScript内存泄漏的三种类型</h2><h3 id="1：意外全局变量"><a href="#1：意外全局变量" class="headerlink" title="1：意外全局变量"></a>1：意外全局变量</h3><p>JavaScript背后的目标之一是开发一种看起来像Java的语言，但是它允许足以被初学者使用。JavaScript允许的方式之一是处理未声明的变量：对未声明的变量的引用在<em>全局</em>对象内创建一个新的变量。在浏览器的情况下，全局对象是<code>window</code>。换一种说法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">    bar = <span class="string">"this is a hidden global variable"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">    <span class="built_in">window</span>.bar = <span class="string">"this is an explicit global variable"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>bar</code>应该在<code>foo</code>函数的范围内保存对变量的引用，并且您忘记使用<code>var</code>它来声明它，那么会创建一个意外的全局变量。在这个例子中，泄漏一个简单的字符串不会做很多伤害，但它肯定可能更糟。</p>
<p>可以创建偶然的全局变量的另一种方式是<code>this</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.variable = <span class="string">"potential accidental global"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Foo called on its own, this points to the global object (window)</span></div><div class="line"><span class="comment">// rather than being undefined.</span></div><div class="line">foo();</div></pre></td></tr></table></figure>
<blockquote>
<p>为了防止发生这些错误，请<code>&#39;use strict&#39;;</code>在JavaScript文件的开头添加。这使得可以更严格地解析JavaScript以防止意外全局变量。</p>
</blockquote>
<h4 id="关于全局变量的注释"><a href="#关于全局变量的注释" class="headerlink" title="关于全局变量的注释"></a>关于全局变量的注释</h4><p>即使我们谈论不可预测的全局变量，仍然是这样的情况，许多代码是与显式的全局变量。这些是根据定义不可收集的（除非被取消或重新分配）。特别地，用于临时存储和处理大量信息的全局变量是令人关注的。如果必须使用全局变量来存储大量数据，请确保将其置空或在完成后重新分配它。与全局变量有关的增加的内存消耗的一个常见原因是<a href="https://en.wikipedia.org/wiki/Cache_(computing" target="_blank" rel="external">高速缓存</a>）。缓存存储重复使用的数据。为了有效率，高速缓存必须具有其大小的上限。无限增长的缓存可能导致高内存消耗，因为无法收集其内容。</p>
<h3 id="2：被遗忘的计时器或回调"><a href="#2：被遗忘的计时器或回调" class="headerlink" title="2：被遗忘的计时器或回调"></a>2：被遗忘的计时器或回调</h3><p><code>setInterval</code>在JavaScript中使用是相当常见的。其他图书馆提供观察员和其他设施来接受回调。大多数这些库在自己的实例变得不可访问之后，负责使任何对回调的引用不可达。在setInterval的情况下，然而，像这样的代码是很常见的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> someResource = getData();</div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'Node'</span>);</div><div class="line">    <span class="keyword">if</span>(node) &#123;</div><div class="line">        <span class="comment">// Do stuff with node and someResource.</span></div><div class="line">        node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>此示例说明了可能发生的悬挂计时器：计时器，引用不再需要的节点或数据。由<code>node</code>未来表示的对象可能会被删除，使得区间处理程序内部的整个块不必要。但是，处理程序（因为时间间隔仍处于活动状态）无法收集（需要停止时间间隔才能发生这种情况）。如果无法收集间隔处理程序，则也无法收集其依赖项。这意味着，<code>someResource</code>不可能收集大概存储大小的数据。</p>
<p>对于观察者的情况，重要的是进行显式调用，以便在不再需要它们时删除它们（或者相关对象即将无法访问）。在过去，以前特别重要，因为某些浏览器（Internet Explorer 6）无法管理循环引用（参见下面的更多信息）。现在，大多数浏览器可以并将收集观察者处理程序，一旦观察到的对象变得不可达，即使没有明确删除侦听器。但是，在处理对象之前显式删除这些观察者仍然是良好的做法。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    element.innerHtml = <span class="string">'text'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">element.addEventListener(<span class="string">'click'</span>, onClick);</div><div class="line"><span class="comment">// Do stuff</span></div><div class="line">element.removeEventListener(<span class="string">'click'</span>, onClick);</div><div class="line">element.parentNode.removeChild(element);</div><div class="line"><span class="comment">// Now when element goes out of scope,</span></div><div class="line"><span class="comment">// both element and onClick will be collected even in old browsers that don't</span></div><div class="line"><span class="comment">// handle cycles well.</span></div></pre></td></tr></table></figure>
<h4 id="关于对象观察者和循环引用的注释"><a href="#关于对象观察者和循环引用的注释" class="headerlink" title="关于对象观察者和循环引用的注释"></a>关于对象观察者和循环引用的注释</h4><p>观察者和循环引用曾经是JavaScript开发者的祸根。这是由于Internet Explorer的垃圾回收器中的错误（或设计决策）。旧版本的Internet Explorer无法检测DOM节点和JavaScript代码之间的循环引用。这是典型的观察者，通常保持对可观察者的引用（如上例所示）。换句话说，每当观察者被添加到Internet Explorer中的一个节点时，它就会导致泄漏。这是开发人员在节点或在观察者内引用null引用之前显式删除处理程序的原因。现在，现代浏览器（包括Internet Explorer和Microsoft Edge）使用现代垃圾收集算法，可以检测这些周期并正确处理它们。换一种说法，<code>removeEventListener</code></p>
<p>框架和库（例如<em>jQuery）</em>在处理节点之前删除侦听器（当为其使用特定的API时）。这是由库内部处理，并确保不产生泄漏，即使在有问题的浏览器（如旧的Internet Explorer）下运行。</p>
<h3 id="3：超出DOM引用"><a href="#3：超出DOM引用" class="headerlink" title="3：超出DOM引用"></a>3：超出DOM引用</h3><p>有时，将DOM节点存储在数据结构中可能很有用。假设要快速更新表中多个行的内容。在字典或数组中存储对每个DOM行的引用可能是有意义的。当发生这种情况时，将保留对同一DOM元素的两个引用：一个在DOM树中，另一个在字典中。如果在将来的某个时候决定删除这些行，则需要使这两个引用不可访问。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elements = &#123;</div><div class="line">    button: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</div><div class="line">    image: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>),</div><div class="line">    text: <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    image.src = <span class="string">'http://some.url/image'</span>;</div><div class="line">    button.click();</div><div class="line">    <span class="built_in">console</span>.log(text.innerHTML);</div><div class="line">    <span class="comment">// Much more logic</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeButton</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// The button is a direct child of body.</span></div><div class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>));</div><div class="line"></div><div class="line">    <span class="comment">// At this point, we still have a reference to #button in the global</span></div><div class="line">    <span class="comment">// elements dictionary. In other words, the button element is still in</span></div><div class="line">    <span class="comment">// memory and cannot be collected by the GC.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对此的另外考虑与对DOM树内的内部或叶节点的引用有关。假设您<code>&lt;td&gt;</code>在JavaScript代码中保留对表（标签）的特定单元格的引用。在将来的某个时候，您决定从DOM中删除表，但保留对该单元格的引用。直观地，可以假定GC将收集除了该单元之外的所有东西。在实践中，这不会发生：单元格是该表的子节点，并且子级保持对其父级的引用。换句话说，从JavaScript代码对表单元格的引用导致整个表保留在内存中。在保持对DOM元素的引用时仔细考虑这一点。</p>
<h3 id="4：关闭"><a href="#4：关闭" class="headerlink" title="4：关闭"></a>4：关闭</h3><p>JavaScript开发的一个关键方面是闭包：从父作用域捕获变量的匿名函数。Meteor开发人员<a href="http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak" target="_blank" rel="external">发现了一种特殊情况</a>，由于JavaScript运行时的实现细节，可能以微妙的方式泄漏内存：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> originalThing = theThing;</div><div class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (originalThing)</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</div><div class="line">  &#125;;</div><div class="line">  theThing = &#123;</div><div class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</div><div class="line">    someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(someMessage);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line">setInterval(replaceThing, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>这个片段做了一件事：每次<code>replaceThing</code>调用，<code>theThing</code>获取一个包含大数组和一个新的闭包（<code>someMethod</code>）的新对象。同时，变量<code>unused</code>保存有一个引用<code>originalThing</code>（<code>theThing</code>从上一次调用<code>replaceThing</code>）的闭包。已经有点混乱了，是吗？重要的是，一旦为同一父作用域中的闭包创建了作用域，则该作用域是共享的。在这种情况下，为闭包创建的作用域由<code>someMethod</code>共享<code>unused</code>。<code>unused</code>有引用<code>originalThing</code>。即使<code>unused</code>从未使用，<code>someMethod</code>可以通过使用<code>theThing</code>。并且<code>someMethod</code>与封闭范围共享<code>unused</code>，即使<code>unused</code>从未使用，<code>originalThing</code>其引用强制其保持活动（防止其收集）。当此代码段重复运行时，可以观察到内存使用量的稳定增加。这在GC运行时不会变小。实质上，创建了闭包的链接列表（其根以<code>theThing</code>变量的形式），并且这些闭包的范围中的每一个都对大数组进行间接引用，导致相当大的泄漏。</p>
<blockquote>
<p>这是一个实现工件。可以处理这种情况的闭包的不同实现是可能的，如<a href="http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak" target="_blank" rel="external">Meteor博客文章中所解释的</a>。</p>
</blockquote>
<h2 id="垃圾收集者的不直观行为"><a href="#垃圾收集者的不直观行为" class="headerlink" title="垃圾收集者的不直观行为"></a>垃圾收集者的不直观行为</h2><p>虽然垃圾收集器很方便，他们有自己的一套权衡。这些权衡之一<em>是非确定性</em>。换句话说，GC是不可预测的。通常不可能确定何时执行收集。这意味着在某些情况下，正在使用比程序实际需要的更多的内存。在其他情况下，短暂停顿在特别敏感的应用中可能是明显的。虽然非确定性意味着无法确定何时执行集合，但大多数GC实现都在分配期间共享执行集合传递的常见模式。如果没有执行分配，则大多数GC保持静止。考虑以下情况：</p>
<ol>
<li>执行相当大的一组分配。</li>
<li>大多数这些元素（或所有这些元素）被标记为不可达（假设我们将指向我们不再需要的缓存的引用置空）。</li>
<li>不执行进一步的分配。</li>
</ol>
<p>在这种情况下，大多数GC将不会运行任何进一步的集合过程。换句话说，即使有不可达的引用可用于收集，收集器也不要求这些引用。这些不是严格的泄漏，但仍然导致高于通常的内存使用。</p>
<p>Google在他们的<a href="https://developer.chrome.com/devtools/docs/demos/memory/example2" target="_blank" rel="external">JavaScript内存分析文档中</a>提供了这种行为的一个很好的例子<a href="https://developer.chrome.com/devtools/docs/demos/memory/example2" target="_blank" rel="external">，示例＃2</a>。</p>
<h2 id="Chrome内存分析工具概述"><a href="#Chrome内存分析工具概述" class="headerlink" title="Chrome内存分析工具概述"></a>Chrome内存分析工具概述</h2><p>Chrome提供了一组很好的工具来分析JavaScript代码的内存使用情况。有两个与内存相关的基本视图：<em>时间轴</em>视图和<em>配置文件</em>视图。</p>
<h3 id="时间轴视图"><a href="#时间轴视图" class="headerlink" title="时间轴视图"></a>时间轴视图</h3><p><img src="https://cdn.auth0.com/blog/jsleaks/timeline.png" alt="Google开发工具时间表行动">时间轴视图对于在代码中发现异常内存模式至关重要。如果我们正在寻找大的泄漏，周期性的跳跃，不收缩，因为收集后他们长大了是一个红旗。在这个截图中，我们可以看到泄漏对象的稳定增长可能是什么样子。即使在大收集结束后，使用的内存总量高于开始时。节点计数也较高。这些都是代码中某处泄漏的DOM节点的迹象。</p>
<h3 id="配置文件视图"><a href="#配置文件视图" class="headerlink" title="配置文件视图"></a>配置文件视图</h3><p><img src="https://cdn.auth0.com/blog/jsleaks/profiles.png" alt="Google开发工具配置文件">这是你将花费大部分时间看的视图。配置文件视图允许您获取快照并比较JavaScript代码的内存使用快照。它还允许您记录分配的时间。在每个结果视图中，可以使用不同类型的列表，但对于我们的任务最相关的是摘要列表和比较列表。</p>
<p>摘要视图为我们概述了分配的不同类型的对象及其聚合大小：浅大小（特定类型的所有对象的总和）和保留大小（浅大小加上由于此对象保留的其他对象的大小）。它也给了我们一个对象相对于它的GC根（距离）有多远的概念。</p>
<p>比较列表给了我们相同的信息，但允许我们比较不同的快照。这是特别有用的找到泄漏。</p>
<h2 id="示例：使用Chrome查找泄漏"><a href="#示例：使用Chrome查找泄漏" class="headerlink" title="示例：使用Chrome查找泄漏"></a>示例：使用Chrome查找泄漏</h2><p>基本上有两种类型的泄漏：泄漏导致内存使用的周期性增加，以及一次发生的泄漏，并且不会进一步增加内存。由于显而易见的原因，当它们是周期性的时更容易发现泄漏。这些也是最麻烦的：如果内存在时间上增加，这种类型的泄漏将最终导致浏览器变慢或停止脚本的执行。非周期性泄漏可以很容易地发现，当它们足够大，在所有其他分配中显着。这通常不是这样，所以他们通常保持不被注意。在某种程度上，发生一次的小泄漏可以被认为是优化问题。然而，周期性的泄漏是错误并且必须是固定的。</p>
<p>对于我们的示例，我们将使用<a href="https://developer.chrome.com/devtools/docs/demos/memory/example1" target="_blank" rel="external">Chrome的文档中的</a>一个<a href="https://developer.chrome.com/devtools/docs/demos/memory/example1" target="_blank" rel="external">示例</a>。完整代码粘贴如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = [];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSomeNodes</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> div,</div><div class="line">        i = <span class="number">100</span>,</div><div class="line">        frag = <span class="built_in">document</span>.createDocumentFragment();</div><div class="line">    <span class="keyword">for</span> (;i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">        div.appendChild(<span class="built_in">document</span>.createTextNode(i + <span class="string">" - "</span>+ <span class="keyword">new</span> <span class="built_in">Date</span>().toTimeString()));</div><div class="line">        frag.appendChild(div);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"nodes"</span>).appendChild(frag);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">grow</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    x.push(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'x'</span>));</div><div class="line">    createSomeNodes();</div><div class="line">    setTimeout(grow,<span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当<code>grow</code>被调用时，它将开始创建div节点并将它们附加到DOM。它还将分配一个大数组，并将其附加到全局变量引用的数组。这将导致使用上述工具可以找到的内存的稳定增加。</p>
<blockquote>
<p>垃圾收集的语言通常显示振荡存储器使用的模式。如果代码在执行分配的循环中运行，这是预期的，这是通常的情况。我们将寻找在收集后不会回退到之前级别的内存的定期增加。</p>
</blockquote>
<h3 id="了解内存是否周期性增加"><a href="#了解内存是否周期性增加" class="headerlink" title="了解内存是否周期性增加"></a>了解内存是否周期性增加</h3><p>时间表视图是伟大的。在Chrome中打开<a href="https://developer.chrome.com/devtools/docs/demos/memory/example1" target="_blank" rel="external">示例</a>，打开开发工具，转到<em>时间轴</em>，选择<em>内存</em>并单击记录按钮。然后转到该页面并单击<code>The Button</code>以开始泄漏内存。过一会儿停止录音，看看结果：</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-timeline.png" alt="时间轴视图中的内存泄漏"></p>
<blockquote>
<p>此示例将继续每秒泄漏内存。停止录制后，请在<code>grow</code>函数中设置断点，以停止脚本强制Chrome关闭页面。</p>
</blockquote>
<p>在这个图像有两个大的迹象，显示我们正在泄漏的记忆。<em>节点</em>（绿线）和<em>JS堆</em>（蓝线）的图形。节点正在稳步增加，从不减少。这是一个大的警告标志。</p>
<p>JS堆还显示内存使用的稳定增长。这是很难看到由于垃圾回收器的影响。您可以看到初始内存增长的模式，随后是大幅下降，随后是增加，然后是峰值，继续记忆的下降。在这种情况下的关键在于事实，在每次内存使用后，堆的大小保持大于在上一次下降。换句话说，尽管垃圾收集器正在成功地收集大量的存储器，但是它的一些被周期性地泄漏。</p>
<p>我们现在确定我们有一个泄漏。让我们找到它。</p>
<h3 id="获取两个快照"><a href="#获取两个快照" class="headerlink" title="获取两个快照"></a>获取两个快照</h3><p>要查找泄漏，我们现在将转到Chrome的开发工具的<em>profiles</em>部分。要将内存使用限制在可管理的级别，请在执行此步骤之前重新加载页面。我们将使用<em>Take Heap Snapshot</em>函数。</p>
<p>重新加载页面，并在完成加载后立即获取堆快照。我们将使用此快照作为我们的基线。之后，<code>The Button</code>再次点击，等待几秒钟，并拍摄第二个快照。捕获快照后，建议在脚本中设置断点，以防止泄漏使用更多内存。</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-snapshots-1.png" alt="堆快照"></p>
<p>有两种方法可以查看两个快照之间的分配。选择<em>摘要</em>，然后选择右侧选择<em>在快照1和快照2之间分配的对象</em>，或选择<em>比较</em>而不是<em>摘要</em>。在这两种情况下，我们将看到在两个快照之间分配的对象的列表。</p>
<p>在这种情况下，很容易找到泄漏：他们很大。看看的<code>Size Delta</code>的的<code>(string)</code>构造函数。8MBs有58个新对象。这看起来很可疑：新对象被分配但是不被释放，并且8MB被消耗。</p>
<p>如果我们打开构造函数的<code>(string)</code>分配列表，我们会注意到在许多小的分配中有一些大的分配。大者立即引起我们的注意。如果我们选择其中的任何一个，我们在下面的<em>retainers</em>部分得到一些有趣的<em>东西</em>。</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-snapshots-2.png" alt="所选对象的保留位置"></p>
<p>我们看到我们选择的分配是数组的一部分。反过来，数组由<code>x</code>全局<code>window</code>对象内的变量引用。这给了我们从我们的大对象到其不可收回的根（<code>window</code>）的完整路径。我们发现我们的潜在泄漏和被引用的地方。</p>
<p>到现在为止还挺好。但我们的例子很容易：大分配，例如在这个例子中的分配不是常态。幸运的是，我们的例子也泄漏了DOM节点，它们更小。使用上面的快照很容易找到这些节点，但是在更大的网站中，事情变得更麻烦。最新版本的Chrome提供了一个最适合我们工作的附加工具：<em>记录堆分配</em>功能。</p>
<h3 id="记录堆分配以查找泄漏"><a href="#记录堆分配以查找泄漏" class="headerlink" title="记录堆分配以查找泄漏"></a>记录堆分配以查找泄漏</h3><p>禁用之前设置的断点，让脚本继续运行，然后返回Chrome的开发工具的“ <em>个人档案”</em>部分。现在点击<em>Record Heap Allocations</em>。当工具运行时，您会注意到在顶部的图中的蓝色尖峰。这些表示分配。每秒大的分配由我们的代码执行。让它运行几秒钟，然后停止它（不要忘记再次设置断点，以防止Chrome吃更多的内存）。</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-recordedallocs-overview.png" alt="记录的堆分配"></p>
<p>在此图像中，您可以看到此工具的杀手级功能：选择一段时间线以查看在该时间段内执行的分配。我们将选择设置为尽可能接近一个大峰值。列表中只显示了三个构造函数：其中一个是与我们的大泄漏（<code>(string)</code>）相关的，另一个是与DOM分配相关的，最后一个是<code>Text</code>构造函数（包含文本的叶DOM节点的构造函数）。</p>
<p><code>HTMLDivElement</code>从列表中选择一个构造函数，然后选择<code>Allocation stack</code>。</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-recordedallocs-selected.png" alt="堆分配结果中选择的元素"></p>
<p>BAM！我们现在知道该元素的分配位置（<code>grow</code>- &gt; <code>createSomeNodes</code>）。如果我们密切关注图中每个秒杀，我们会发现，<code>HTMLDivElement</code>构造函数被调用了很多。如果我们回到我们快照比较认为我们会发现，这个构造显示有多少拨款，但没有删除。换句话说，它是稳定，而不允许在GC收回一些它分配内存。这有泄漏的种种迹象加上我们确切地知道被分配这些对象（<code>createSomeNodes</code>函数）。现在它的时间回到代码，研究它，并修复内存泄漏。</p>
<h3 id="另一个有用的功能"><a href="#另一个有用的功能" class="headerlink" title="另一个有用的功能"></a>另一个有用的功能</h3><p>在堆分配结果视图中，我们可以选择<em>Allocation</em>视图而不是<em>Summary</em>。</p>
<p><img src="https://cdn.auth0.com/blog/jsleaks/example-recordedallocs-list.png" alt="结果是堆分配中的分配"></p>
<p>这个视图给了我们一个与它们相关的函数和内存分配的列表。我们可以立即看到<code>grow</code>和<code>createSomeNodes</code>站出来。当选择时，<code>grow</code>我们看看它所调用的关联对象构造函数。我们注意到<code>(string)</code>，<code>HTMLDivElement</code>和<code>Text</code>它现在我们已经知道是被泄露的对象的构造函数。</p>
<p>这些工具的组合可以大大有助于发现泄漏。玩他们。在生产站点中进行不同的分析运行（理想情况下使用非最小化或混淆代码）。看看你能找到的泄漏或对象被保留超过他们应该（提示：这些更难找到）。</p>
<blockquote>
<p>要使用此功能，请转到Dev Tools - &gt;设置并启用“记录堆分配堆栈跟踪”。在拍摄之前必须这样做。</p>
</blockquote>
<h2 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management" target="_blank" rel="external">内存管理 - Mozilla开发人员网络</a></li>
<li><a href="http://javascript.crockford.com/memory/leak.html" target="_blank" rel="external">JScript内存泄漏 - Douglas Crockford（旧的，关于Internet Explorer 6泄漏）</a></li>
<li><a href="https://developer.chrome.com/devtools/docs/javascript-memory-profiling" target="_blank" rel="external">JavaScript内存分析 - Chrome开发者文档</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/memory-diagnosis" target="_blank" rel="external">内存诊断 - Google Developers</a></li>
<li><a href="http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak" target="_blank" rel="external">有趣的JavaScript内存泄漏 - 流星博客</a></li>
<li><a href="http://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html" target="_blank" rel="external">Grokking V8关闭</a></li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>内存泄漏可以并且确实发生在垃圾收集语言中，如JavaScript。这些可以被忽视一段时间，最终他们将肆虐。因此，内存分析工具对于查找内存泄漏至关重要。分析运行应该是开发周期的一部分，特别是对于中型或大型应用程序。开始这样做，为您的用户提供最好的体验。Hack on！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/Node.js权限控制管理模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/Node.js权限控制管理模块/" itemprop="url">
                  Node.js权限控制管理模块
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T11:15:54+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <script src="https://gist.github.com/facultymatt/6370903.js"></script>

<p><a href="https://github.com/tenodi/permission" target="_blank" rel="external">https://github.com/tenodi/permission</a> Npm package for hangling user permissions for routes based on roles. </p>
<p><a href="https://github.com/kieronwiltshire/letu" target="_blank" rel="external">https://github.com/kieronwiltshire/letu</a>  Simple permission evaluation. </p>
<blockquote>
<p>current popularity rank (based on npmjs.com dowloads count)</p>
<ol>
<li>acl</li>
<li>connect-roles</li>
<li>authorized</li>
<li>virgen-acl</li>
<li>permission</li>
<li>ability</li>
<li>ability</li>
<li>simplepermissions</li>
<li>entitlement</li>
</ol>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://tomoat.github.io/blog/2017/03/项目中用到的用户权限管理系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tomoat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tomoat的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/项目中用到的用户权限管理系统/" itemprop="url">
                  项目中用到的用户权限管理系统
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T10:41:27+08:00">
                2017-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>权限管理是每个系统中用户管理必需的管理组件，通常需要通过判断用户所具有的权限来控制用户对系统的操作内容，并把资源调配给用户，限制用户的增删改查等操作。</p>
<p>通常权限管理的访问控制模型有以下两种方式：</p>
<p><a href="https://en.wikipedia.org/wiki/Access_control_list" target="_blank" rel="external">ACL</a>：Access Control List，访问控制列表（节点控制），是比较流行的设计方式。通过把用户和权限挂钩来实现。</p>
<p> <a href="https://en.wikipedia.org/wiki/Role-based_access_control" target="_blank" rel="external">RBAC</a>：Role Based Access Control，基于的角色访问控制系统，是另一个实现思路。、就是把用户和角色关联，角色来对应权限，用户和权限没有直接关联，对复杂的系统来说，更加容易管理。</p>
<h3 id="RBAC物理模型"><a href="#RBAC物理模型" class="headerlink" title="RBAC物理模型"></a>RBAC物理模型</h3><p><a href="http://dl.iteye.com/upload/attachment/425543/d2573c4d-dca7-380f-b2fc-6cda19d6eaf5.jpg" target="_blank" rel="external"><img src="http://dl.iteye.com/upload/attachment/425543/d2573c4d-dca7-380f-b2fc-6cda19d6eaf5.jpg" alt="img"></a></p>
<p>当用户的数量非常大时，要给系统每个用户逐一授权（授角色），是件非常烦琐的事情。这时，就需要给用户分组，每个用户组内有多个用户。除了可给用户授权外，还可以给用户组授权。这样一来，用户拥有的所有权限，就是用户个人拥有的权限与该用户所在用户组拥有的权限之和。（下图为用户组、用户与角色三者的关联关系）</p>
<p><img src="http://dl.iteye.com/upload/attachment/425558/90bf9805-c29d-3199-a905-c6ddc7fd4e81.jpg" alt="img"></p>
<p>​                                    “用户-角色-权限-资源” 授权模型</p>
<p><img src="http://dl.iteye.com/upload/attachment/425567/53bc63c4-52e6-3c6f-91d8-7e23a9aefe4a.jpg" alt="img"></p>
<p><img src="http://dl.iteye.com/upload/attachment/425569/c07d99bc-e19d-302d-8dea-dc98309bf919.jpg" alt="点击查看原始大小图片"></p>
<p><img src="http://img.blog.csdn.net/20140118135544281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNoOTE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="http://img.blog.csdn.net/20140118135551234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNoOTE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="http://img.blog.csdn.net/20140118135834234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNoOTE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h3 id="ACL实体模型"><a href="#ACL实体模型" class="headerlink" title="ACL实体模型"></a>ACL实体模型</h3><p><img src="http://img.blog.csdn.net/20140118135348656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNoOTE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>通过ACL（访问控制列表）把Role、User、Module、Permission、status（允许/禁止）关联起来。用于记录用户或者角色对资源拥有的权限</p>
<p><img src="http://img.blog.csdn.net/20140118135356750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGNoOTE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<blockquote>
<p><em>内容来源网络整理而成</em> </p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/blog/images/avatar.gif"
               alt="tomoat" />
          <p class="site-author-name" itemprop="name">tomoat</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/blog/archives">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tomoat</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
